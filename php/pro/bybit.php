<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\AuthenticationError;
use ccxt\BadRequest;
use ccxt\NotSupported;
use ccxt\Precise;
use React\Async;

class bybit extends \ccxt\async\bybit {

    use ClientTrait;

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => true,
                'watchMyTrades' => true,
                'watchOHLCV' => true,
                'watchOrderBook' => true,
                'watchOrders' => true,
                'watchTicker' => true,
                'watchTickers' => false, // for now
                'watchTrades' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'inverse' => array(
                            'public' => 'wss://stream.{hostname}/realtime',
                            'private' => 'wss://stream.{hostname}/realtime',
                        ),
                        'linear' => array(
                            'public' => 'wss://stream.{hostname}/realtime_public',
                            'private' => 'wss://stream.{hostname}/realtime_private',
                        ),
                        'spot' => array(
                            'public' => 'wss://stream.{hostname}/spot/quote/ws/v2',
                            'private' => 'wss://stream.{hostname}/spot/ws',
                        ),
                        'usdc' => array(
                            'option' => array(
                                'public' => 'wss://stream.{hostname}/trade/option/usdc/public/v1',
                                'private' => 'wss://stream.{hostname}/trade/option/usdc/private/v1',
                            ),
                            'swap' => array(
                                'public' => 'wss://stream.{hostname}/perpetual/ws/v1/realtime_public',
                                'private' => 'wss://stream.{hostname}/trade/option/usdc/private/v1',
                            ),
                        ),
                    ),
                ),
                'test' => array(
                    'ws' => array(
                        'inverse' => array(
                            'public' => 'wss://stream-testnet.{hostname}/realtime',
                            'private' => 'wss://stream-testnet.{hostname}/realtime',
                        ),
                        'linear' => array(
                            'public' => 'wss://stream-testnet.{hostname}/realtime_public',
                            'private' => 'wss://stream-testnet.{hostname}/realtime_private',
                        ),
                        'spot' => array(
                            'public' => 'wss://stream-testnet.{hostname}/spot/quote/ws/v2',
                            'private' => 'wss://stream-testnet.{hostname}/spot/ws',
                        ),
                        'usdc' => array(
                            'option' => array(
                                'public' => 'wss://stream-testnet.{hostname}/trade/option/usdc/public/v1',
                                'private' => 'wss://stream-testnet.{hostname}/trade/option/usdc/private/v1',
                            ),
                            'swap' => array(
                                'public' => 'wss://stream-testnet.{hostname}/perpetual/ws/v1/realtime_public',
                                'private' => 'wss://stream-testnet.{hostname}/trade/option/usdc/private/v1',
                            ),
                        ),
                    ),
                ),
            ),
            'options' => array(
                'watchTicker' => array(
                    'name' => 'realtimes', // or bookTicker
                ),
            ),
            'streaming' => array(
                'ping' => array($this, 'ping'),
                'keepAlive' => 20000,
            ),
            'exceptions' => array(
                'ws' => array(
                    'exact' => array(
                    ),
                ),
            ),
        ));
    }

    public function get_url_by_market_type($symbol = null, $isPrivate = false, $method = null, $params = array ()) {
        $accessibility = $isPrivate ? 'private' : 'public';
        $isUsdcSettled = null;
        $isSpot = null;
        $type = null;
        $isLinear = null;
        $market = null;
        $url = $this->urls['api']['ws'];
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $isUsdcSettled = $market['settle'] === 'USDC';
            $isSpot = $market['spot'];
            $type = $market['type'];
            $isLinear = $market['linear'];
        } else {
            list($type, $params) = $this->handle_market_type_and_params($method, null, $params);
            $defaultSubType = $this->safe_string($this->options, 'defaultSubType', 'linear');
            $subType = $this->safe_string($params, 'subType', $defaultSubType);
            $defaultSettle = $this->safe_string($this->options, 'defaultSettle');
            $defaultSettle = $this->safe_string_2($params, 'settle', 'defaultSettle', $defaultSettle);
            $isUsdcSettled = ($defaultSettle === 'USDC');
            $isSpot = ($type === 'spot');
            $isLinear = ($subType === 'linear');
        }
        if ($isSpot) {
            $url = $url['spot'][$accessibility];
        } elseif ($isUsdcSettled) {
            $url = $url['usdc'][$type][$accessibility];
        } elseif ($isLinear) {
            $url = $url['linear'][$accessibility];
        } else {
            // inverse
            $url = $url['inverse'][$accessibility];
        }
        $url = $this->implode_hostname($url);
        return $url;
    }

    public function clean_params($params) {
        $params = $this->omit($params, array( 'type', 'subType', 'settle', 'defaultSettle' ));
        return $params;
    }

    public function watch_ticker($symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $messageHash = 'ticker:' . $market['symbol'];
            $url = $this->get_url_by_market_type($symbol, false, $params);
            $params = $this->clean_params($params);
            if ($market['spot']) {
                $options = $this->safe_value($this->options, 'watchTicker', array());
                $channel = $this->safe_string($options, 'name', 'realtimes');
                $reqParams = array(
                    'symbol' => $market['id'],
                );
                return Async\await($this->watch_spot_public($url, $channel, $messageHash, $reqParams, $params));
            } else {
                $channel = 'instrument_info.100ms.' . $market['id'];
                $reqParams = array( $channel );
                return Async\await($this->watch_contract_public($url, $messageHash, $reqParams, $params));
            }
        }) ();
    }

    public function handle_ticker($client, $message) {
        //
        // {
        //     $topic => 'bookTicker',
        //     params => array( $symbol => 'BTCUSDT', binary => 'false', symbolName => 'BTCUSDT' ),
        //     $data => {
        //       $symbol => 'BTCUSDT',
        //       bidPrice => '29150.8',
        //       bidQty => '0.171947',
        //       askPrice => '29156.72',
        //       askQty => '0.017764',
        //       time => 1652956849565
        //     }
        // }
        //
        //  spot realtimes
        //    {
        //        $topic => 'realtimes',
        //        params => array( $symbol => 'BTCUSDT', binary => 'false', symbolName => 'BTCUSDT' ),
        //        $data => {
        //          t => 1652883737410,
        //          s => 'BTCUSDT',
        //          o => '30422.68',
        //          h => '30715',
        //          l => '29288.44',
        //          c => '29462.94',
        //          v => '4350.340495',
        //          qv => '130497543.0334267',
        //          m => '-0.0315'
        //        }
        //    }
        //
        // swap/futures use an incremental approach sending first the snapshot and then the $updates
        //
        // snapshot $message
        //     {
        //         "topic":"instrument_info.100ms.BTCUSDT",
        //         "type":"snapshot",
        //         "data":array(
        //            "id":1,
        //            "symbol":"BTCUSDT",
        //            "last_price_e4":"291050000",
        //            "last_price":"29105.00",
        //            "bid1_price_e4":"291045000",
        //            "bid1_price":"29104.50",
        //            "ask1_price_e4":"291050000",
        //            "ask1_price":"29105.00",
        //            "last_tick_direction":"ZeroPlusTick",
        //            "prev_price_24h_e4":"297900000",
        //            "prev_price_24h":"29790.00",
        //            "price_24h_pcnt_e6":"-22994",
        //            "high_price_24h_e4":"300200000",
        //            "high_price_24h":"30020.00",
        //            "low_price_24h_e4":"286330000",
        //            "low_price_24h":"28633.00",
        //            "prev_price_1h_e4":"291435000",
        //            "prev_price_1h":"29143.50",
        //            "price_1h_pcnt_e6":"-1321",
        //            "mark_price_e4":"291148200",
        //            "mark_price":"29114.82",
        //            "index_price_e4":"291173600",
        //            "index_price":"29117.36",
        //            "open_interest_e8":"2725210700000",
        //            "total_turnover_e8":"6184585271557950000",
        //            "turnover_24h_e8":"373066109692150560",
        //            "total_volume_e8":"3319897492699924",
        //            "volume_24h_e8":"12774825300000",
        //            "funding_rate_e6":"-97",
        //            "predicted_funding_rate_e6":"100",
        //            "cross_seq":"11834024892",
        //            "created_at":"1970-01-01T00:00:00.000Z",
        //            "updated_at":"2022-05-19T08:52:10.000Z",
        //            "next_funding_time":"2022-05-19T16:00:00Z",
        //            "count_down_hour":"8",
        //            "funding_rate_interval":"8",
        //            "settle_time_e9":"0",
        //            "delisting_status":"0"
        //         ),
        //         "cross_seq":"11834024953",
        //         "timestamp_e6":"1652950330515050"
        //     }
        //
        // $update $message
        //    {
        //        "topic":"instrument_info.100ms.BTCUSDT",
        //        "type":"delta",
        //        "data":{
        //           "update":array(
        //              array(
        //                 "id":1,
        //                 "symbol":"BTCUSDT",
        //                 "open_interest_e8":"2721359000000",
        //                 "cross_seq":"11834107074",
        //                 "created_at":"1970-01-01T00:00:00.000Z",
        //                 "updated_at":"2022-05-19T08:54:18.000Z"
        //              }
        //           )
        //        ),
        //        "cross_seq":"11834107125",
        //        "timestamp_e6":"1652950458616087"
        //    }
        //
        $topic = $this->safe_string($message, 'topic', '');
        if (($topic === 'realtimes') || ($topic === 'bookTicker')) {
            // spot markets
            $data = $this->safe_value($message, 'data');
            $ticker = $this->parse_ws_ticker($data);
            $symbol = $ticker['symbol'];
            $this->tickers[$symbol] = $ticker;
            $messageHash = 'ticker:' . $symbol;
            $client->resolve ($ticker, $messageHash);
            return;
        }
        $updateType = $this->safe_string($message, 'type', '');
        $data = $this->safe_value($message, 'data', array());
        $symbol = null;
        if ($updateType === 'snapshot') {
            $parsed = $this->parse_ws_ticker($data);
            $symbol = $parsed['symbol'];
            $this->tickers[$symbol] = $parsed;
        }
        if ($updateType === 'delta') {
            $topicParts = explode('.', $topic);
            $topicLength = count($topicParts);
            $marketId = $this->safe_string($topicParts, $topicLength - 1);
            $market = $this->market($marketId);
            $symbol = $market['symbol'];
            $updates = $this->safe_value($data, 'update', array());
            $ticker = $this->safe_value($this->tickers, $symbol, array());
            for ($i = 0; $i < count($updates); $i++) {
                $update = $updates[$i];
                $ticker = $this->update_ticker($ticker, $update);
            }
            $this->tickers[$symbol] = $ticker;
        }
        $messageHash = 'ticker:' . $symbol;
        $client->resolve ($this->tickers[$symbol], $messageHash);
    }

    public function update_ticker($ticker, $update) {
        // First we $update the raw $ticker with the new values
        // then we parse it again, although we could just
        // $update the changed values in the already $parsed $ticker
        // doing that would lead to an inconsistent info object
        // inside $ticker
        $rawTicker = $ticker['info'];
        $updateKeys = is_array($update) ? array_keys($update) : array();
        $updateLength = count($updateKeys);
        if ($updateLength > 0) {
            for ($i = 0; $i < count($updateKeys); $i++) {
                $key = $updateKeys[$i];
                if (is_array($rawTicker) && array_key_exists($key, $rawTicker)) {
                    $rawTicker[$key] = $update[$key];
                }
            }
            $parsed = $this->parse_ws_ticker($rawTicker);
            return $parsed;
        }
        return $ticker;
    }

    public function parse_ws_ticker($ticker, $market = null) {
        //
        // spot
        //   {
        //          $symbol => 'BTCUSDT',
        //          bidPrice => '29150.8',
        //          bidQty => '0.171947',
        //          askPrice => '29156.72',
        //          askQty => '0.017764',
        //          time => 1652956849565
        //   }
        //
        //   {
        //          t => 1652883737410,
        //          s => 'BTCUSDT',
        //          o => '30422.68',
        //          h => '30715',
        //          l => '29288.44',
        //          c => '29462.94',
        //          v => '4350.340495',
        //          qv => '130497543.0334267',
        //          m => '-0.0315'
        //    }
        //
        // swap
        //
        //   array(
        //            "id":1,
        //            "symbol":"BTCUSDT",
        //            "last_price_e4":"291050000",
        //            "last_price":"29105.00",
        //            "bid1_price_e4":"291045000",
        //            "bid1_price":"29104.50",
        //            "ask1_price_e4":"291050000",
        //            "ask1_price":"29105.00",
        //            "last_tick_direction":"ZeroPlusTick",
        //            "prev_price_24h_e4":"297900000",
        //            "prev_price_24h":"29790.00",
        //            "price_24h_pcnt_e6":"-22994",
        //            "high_price_24h_e4":"300200000",
        //            "high_price_24h":"30020.00",
        //            "low_price_24h_e4":"286330000",
        //            "low_price_24h":"28633.00",
        //            "prev_price_1h_e4":"291435000",
        //            "prev_price_1h":"29143.50",
        //            "price_1h_pcnt_e6":"-1321",
        //            "mark_price_e4":"291148200",
        //            "mark_price":"29114.82",
        //            "index_price_e4":"291173600",
        //            "index_price":"29117.36",
        //            "open_interest_e8":"2725210700000",
        //            "total_turnover_e8":"6184585271557950000",
        //            "turnover_24h_e8":"373066109692150560",
        //            "total_volume_e8":"3319897492699924",
        //            "volume_24h_e8":"12774825300000",
        //            "funding_rate_e6":"-97",
        //            "predicted_funding_rate_e6":"100",
        //            "cross_seq":"11834024892",
        //            "created_at":"1970-01-01T00:00:00.000Z",
        //            "updated_at":"2022-05-19T08:52:10.000Z",
        //            "next_funding_time":"2022-05-19T16:00:00Z",
        //            "count_down_hour":"8",
        //            "funding_rate_interval":"8",
        //            "settle_time_e9":"0",
        //            "delisting_status":"0"
        //         ),
        //         "cross_seq":"11834024953",
        //         "timestamp_e6":"1652950330515050"
        //     }
        //
        // option
        //    {
        //        "symbol":"BTC-19NOV21-58000-P",
        //        "bidPrice":"421",
        //        "askPrice":"465",
        //        "bidIv":"0.7785",
        //        "askIv":"0.8012",
        //        "bidSize":"17",
        //        "askSize":"18",
        //        "markPrice":"442.51157238",
        //        "markPriceIv":"0.7897",
        //        "indexPrice":"67102.13",
        //        "underlyingPrice":"67407.49",
        //        "lastPrice":"0",
        //        "delta":"-0.10385629",
        //        "gamma":"0.00002132",
        //        "theta":"-82.72572574",
        //        "vega":"19.33584131",
        //        "change24h":"0",
        //        "volume24h":"0",
        //        "turnover24h":"0",
        //        "high24h":"0",
        //        "low24h":"0",
        //        "totalVolume":"0",
        //        "totalTurnover":"0",
        //        "openInterest":"0",
        //        "predictedDeliveryPrice":"62330.90608575"
        //    }
        //
        $timestamp = $this->safe_integer_2($ticker, 'time', 't');
        if ($timestamp === null) {
            $timestamp = $this->parse8601($this->safe_string_2($ticker, 'updated_at', 'updatedAt'));
            if ($timestamp === null) {
                $timestampE9 = $this->safe_string($ticker, 'updated_at_e9');
                $timestamp = Precise::string_div($timestampE9, '1000000');
                $timestamp = $this->parse_number($timestamp);
                $timestamp = ($timestamp !== null) ? intval($timestamp) : null;
            }
        }
        $marketId = $this->safe_string_2($ticker, 'symbol', 's');
        $symbol = $this->safe_symbol($marketId, $market);
        $last = $this->safe_string_n($ticker, array( 'l', 'last_price', 'lastPrice' ));
        $open = $this->safe_string_n($ticker, array( 'prev_price_24h', 'o', 'prevPrice24h' ));
        $quoteVolume = $this->safe_string_n($ticker, array( 'v', 'turnover24h' ));
        if ($quoteVolume === null) {
            $quoteVolume = $this->safe_string_2($ticker, 'turnover_24h_e8', 'turnover24hE8');
            $quoteVolume = Precise::string_div($quoteVolume, '100000000');
        }
        $baseVolume = $this->safe_string_n($ticker, array( 'qv', 'volume24h', 'volume_24h' ));
        if ($baseVolume === null) {
            $baseVolume = $this->safe_string_2($ticker, 'volume_24h_e8', 'volume24hE8');
            $baseVolume = Precise::string_div($baseVolume, '100000000');
        }
        $bid = $this->safe_string_n($ticker, array( 'bidPrice', 'bid1_price', 'bid1Price' ));
        $ask = $this->safe_string_n($ticker, array( 'askPrice', 'ask1_price', 'ask1Price' ));
        $high = $this->safe_string_n($ticker, array( 'high_price_24h', 'high24h', 'h', 'highPrice24h' ));
        $low = $this->safe_string_n($ticker, array( 'low_price_24h', 'low24h', 'l', 'lowPrice24h' ));
        $percentage = $this->safe_string($ticker, 'm');
        if ($percentage === null) {
            $percentage = $this->safe_string_2($ticker, 'price_24h_pcnt_e6', 'price24hPcntE6');
            $percentage = Precise::string_div($percentage, '1000000');
        }
        $change = $this->safe_string($ticker, 'change24h');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $high,
            'low' => $low,
            'bid' => $bid,
            'bidVolume' => $this->safe_string_2($ticker, 'bidSize', 'bidQty'),
            'ask' => $ask,
            'askVolume' => $this->safe_string_2($ticker, 'askSize', 'askQty'),
            'vwap' => null,
            'open' => $open,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => $change,
            'percentage' => $percentage,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        ), $market);
    }

    public function watch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $interval = $this->timeframes[$timeframe];
            $url = $this->get_url_by_market_type($symbol, false, $params);
            $params = $this->clean_params($params);
            $messageHash = 'kline' . ':' . $timeframe . ':' . $symbol;
            $ohlcv = null;
            if ($market['spot']) {
                $channel = 'kline';
                $reqParams = array(
                    'symbol' => $market['id'],
                    'klineType' => $timeframe, // spot uses the same $timeframe as ours
                );
                $ohlcv = Async\await($this->watch_spot_public($url, $channel, $messageHash, $reqParams, $params));
            } else {
                $prefix = $market['linear'] ? 'candle' : 'klineV2';
                $channel = $prefix . '.' . $interval . '.' . $market['id'];
                $reqParams = array( $channel );
                $ohlcv = Async\await($this->watch_contract_public($url, $messageHash, $reqParams, $params));
            }
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function handle_ohlcv($client, $message) {
        //
        // swap
        //    {
        //        $topic => 'klineV2.1.LTCUSD',
        //        $data => array(
        //          {
        //            start => 1652893140,
        //            end => 1652893200,
        //            open => 67.9,
        //            close => 67.84,
        //            high => 67.91,
        //            low => 67.84,
        //            volume => 56,
        //            turnover => 0.82528936,
        //            timestamp => '1652893152874413',
        //            confirm => false,
        //            cross_seq => 63544166
        //          }
        //        ),
        //        timestamp_e6 => 1652893152874413
        //    }
        //
        // spot
        //    {
        //        $topic => 'kline',
        //        $params => array(
        //          $symbol => 'LTCUSDT',
        //          binary => 'false',
        //          klineType => '1m',
        //          symbolName => 'LTCUSDT'
        //        ),
        //        $data => {
        //          t => 1652893440000,
        //          s => 'LTCUSDT',
        //          sn => 'LTCUSDT',
        //          c => '67.92',
        //          h => '68.05',
        //          l => '67.92',
        //          o => '68.05',
        //          v => '9.71302'
        //        }
        //    }
        //
        $data = $this->safe_value($message, 'data', array());
        $topic = $this->safe_string($message, 'topic');
        if (gettype($data) === 'array' && array_keys($data) === array_keys(array_keys($data))) {
            // swap messages
            $topicParts = explode('.', $topic);
            $topicLength = count($topicParts);
            $marketId = $this->safe_string($topicParts, $topicLength - 1);
            $timeframe = $this->safe_string($topicParts, $topicLength - 2);
            $marketIds = array();
            for ($i = 0; $i < count($data); $i++) {
                $ohlcv = $data[$i];
                $market = $this->market($marketId);
                $symbol = $market['symbol'];
                $parsed = $this->parse_ws_ohlcv($ohlcv, $market);
                $stored = $this->safe_value($this->ohlcvs, $symbol);
                if ($stored === null) {
                    $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
                    $stored = new ArrayCacheByTimestamp ($limit);
                    $this->ohlcvs[$symbol] = $stored;
                }
                $stored->append ($parsed);
                $marketIds[$symbol] = $timeframe;
            }
            $keys = is_array($marketIds) ? array_keys($marketIds) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $symbol = $keys[$i];
                $interval = $marketIds[$symbol];
                $timeframe = $this->find_timeframe($interval);
                $messageHash = 'kline' . ':' . $timeframe . ':' . $symbol;
                $stored = $this->safe_value($this->ohlcvs, $symbol);
                $client->resolve ($stored, $messageHash);
            }
        } else {
            // spot messages
            $params = $this->safe_value($message, 'params', array());
            $data = $this->safe_value($message, 'data');
            $marketId = $this->safe_string($params, 'symbol');
            $timeframe = $this->safe_string($params, 'klineType');
            $market = $this->market($marketId);
            $parsed = $this->parse_ws_ohlcv($data, $market);
            $symbol = $market['symbol'];
            $stored = $this->safe_value($this->ohlcvs, $symbol);
            if ($stored === null) {
                $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
                $stored = new ArrayCacheByTimestamp ($limit);
                $this->ohlcvs[$symbol] = $stored;
            }
            $stored->append ($parsed);
            $messageHash = 'kline' . ':' . $timeframe . ':' . $symbol;
            $client->resolve ($stored, $messageHash);
        }
    }

    public function parse_ws_ohlcv($ohlcv, $market = null) {
        //
        // swap
        //   {
        //      start => 1652893140,
        //      end => 1652893200,
        //      open => 67.9,
        //      close => 67.84,
        //      high => 67.91,
        //      low => 67.84,
        //      volume => 56,
        //      turnover => 0.82528936,
        //      $timestamp => '1652893152874413', // microseconds
        //      confirm => false,
        //      cross_seq => 63544166
        //   }
        //
        // spot
        //
        //   {
        //      t => 1652893440000,
        //      s => 'LTCUSDT',
        //      sn => 'LTCUSDT',
        //      c => '67.92',
        //      h => '68.05',
        //      l => '67.92',
        //      o => '68.05',
        //      v => '9.71302'
        //   }
        //
        $timestamp = $this->safe_integer($ohlcv, 't');
        if ($timestamp === null) {
            $timestamp = $this->safe_timestamp($ohlcv, 'start');
        }
        return array(
            $timestamp,
            $this->safe_number_2($ohlcv, 'open', 'o'),
            $this->safe_number_2($ohlcv, 'high', 'h'),
            $this->safe_number_2($ohlcv, 'low', 'l'),
            $this->safe_number_2($ohlcv, 'close', 'c'),
            $this->safe_number_2($ohlcv, 'volume', 'v'),
        );
    }

    public function watch_order_book($symbol, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $url = $this->get_url_by_market_type($symbol, false, $params);
            $params = $this->clean_params($params);
            $messageHash = 'orderbook' . ':' . $symbol;
            $orderbook = null;
            if ($market['spot']) {
                $channel = 'depth';
                $reqParams = array(
                    'symbol' => $market['id'],
                );
                $orderbook = Async\await($this->watch_spot_public($url, $channel, $messageHash, $reqParams, $params));
            } else {
                $channel = null;
                if ($market['option']) {
                    $channel = 'delta.orderbook100' . '.' . $market['marketId'];
                } else {
                    if ($limit !== null) {
                        if ($limit !== 25 && $limit !== 200) {
                            throw new BadRequest($this->id . ' watchOrderBook $limit argument must be either 25 or 200');
                        }
                    } else {
                        $limit = 25;
                    }
                    $prefix = ($limit === 25) ? 'orderBookL2_25' : 'orderBook_200.100ms';
                    $channel = $prefix . '.' . $market['id'];
                }
                $reqParams = array( $channel );
                $orderbook = Async\await($this->watch_contract_public($url, $messageHash, $reqParams, $params));
            }
            return $orderbook->limit ($limit);
        }) ();
    }

    public function handle_order_book($client, $message) {
        //
        // spot $snapshot
        // {
        //     $topic => 'depth',
        //     params => array( $symbol => 'BTCUSDT', binary => 'false', symbolName => 'BTCUSDT' ),
        //     $data => {
        //       s => 'BTCUSDT',
        //       t => 1652970523792,
        //       v => '34407758_140450607_2',
        //       b => array(
        //            array(
        //                "9780.79",
        //                "0.01"
        //            ),
        //       ),
        //       a => array(
        //            array(
        //               "9781.21",
        //               "0.042842"
        //            )
        //       )
        //     }
        //   }
        //
        // contract $snapshot
        //    {
        //        $topic => 'orderBookL2_25.BTCUSDT',
        //        $type => 'snapshot',
        //        $data => {
        //          order_book => array(
        //              array(
        //                  "price":"29907.50",
        //                  "symbol":"BTCUSDT",
        //                  "id":"299075000",
        //                  "side":"Buy",
        //                  "size":0.763
        //              }
        //          )
        //        ),
        //        cross_seq => '11846360142',
        //        timestamp_e6 => '1652973544516741'
        //    }
        //
        // contract delta
        //
        // {
        //     $topic => 'orderBookL2_25.BTCUSDT',
        //     $type => 'delta',
        //     $data => {
        //         "delete" => array(
        //             {
        //                   "price" => "3001.00",
        //                   "symbol" => "BTCUSDT",
        //                   "id" => 30010000,
        //                   "side" => "Sell"
        //             }
        //          ),
        //          "update" => array(
        //             {
        //                   "price" => "2999.00",
        //                   "symbol" => "BTCUSDT",
        //                   "id" => 29990000,
        //                   "side" => "Buy",
        //                   "size" => 8
        //             }
        //          ),
        //          "insert" => array(
        //             array(
        //                   "price" => "2998.00",
        //                   "symbol" => "BTCUSDT",
        //                   "id" => 29980000,
        //                   "side" => "Buy",
        //                   "size" => 8
        //             }
        //            ),
        //          ),
        //          cross_seq => '11848736847',
        //          timestamp_e6 => '1652976712534987'
        //     }
        //
        $topic = $this->safe_string($message, 'topic', '');
        $data = $this->safe_value($message, 'data', array());
        if ($topic === 'depth') {
            // spot branch, we get the $snapshot in every $message
            $marketId = $this->safe_string($data, 's');
            $market = $this->market($marketId);
            $symbol = $market['symbol'];
            $timestamp = $this->safe_integer($data, 't');
            $snapshot = $this->parse_order_book($data, $symbol, $timestamp, 'b', 'a');
            $orderbook = null;
            if (!(is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks))) {
                $orderbook = $this->order_book($snapshot);
                $this->orderbooks[$symbol] = $orderbook;
            } else {
                $orderbook = $this->orderbooks[$symbol];
                $orderbook->reset ($snapshot);
            }
            $messageHash = 'orderbook' . ':' . $symbol;
            $client->resolve ($orderbook, $messageHash);
            return;
        }
        if (mb_strpos($topic, 'orderBook') !== false) {
            // contract branch
            $type = $this->safe_string($message, 'type');
            $topicParts = explode('.', $topic);
            $topicLength = count($topicParts);
            $marketId = $this->safe_string($topicParts, $topicLength - 1);
            $market = $this->market($marketId);
            $symbol = $market['symbol'];
            $messageHash = 'orderbook' . ':' . $symbol;
            $nonce = $this->safe_integer_2($message, 'cross_seq', 'crossSeq');
            $timestamp = $this->safe_integer_product_2($message, 'timestamp_e6', 'timestampE6', 0.001);
            if ($type === 'snapshot') {
                $rawOrderBook = $this->safe_value_2($data, 'order_book', 'orderBook', $data);
                $snapshot = $this->parse_order_book($rawOrderBook, $symbol, $timestamp, 'Buy', 'Sell', 'price', 'size');
                $snapshot['nonce'] = $nonce;
                $orderbook = null;
                if (!(is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks))) {
                    $orderbook = $this->order_book($snapshot);
                    $this->orderbooks[$symbol] = $orderbook;
                } else {
                    $orderbook = $this->orderbooks[$symbol];
                    $orderbook->reset ($snapshot);
                }
            } elseif ($type === 'delta') {
                $deleted = $this->safe_value($data, 'delete', array());
                $updated = $this->safe_value($data, 'update', array());
                $inserted = $this->safe_value($data, 'insert', array());
                $updatedDeleted = array();
                for ($i = 0; $i < count($deleted); $i++) {
                    $entry = $deleted[$i];
                    $entry['size'] = 0;
                    $updatedDeleted[] = $entry;
                }
                $deltas = $updatedDeleted;
                $deltas = $this->array_concat($deltas, $updated);
                $deltas = $this->array_concat($deltas, $inserted);
                $orderbook = $this->safe_value($this->orderbooks, $symbol);
                $orderbook['nonce'] = $nonce;
                $orderbook['timestamp'] = $timestamp;
                $orderbook['datetime'] = $this->iso8601($timestamp);
                $this->handle_deltas($orderbook, $deltas);
            }
            $client->resolve ($this->orderbooks[$symbol], $messageHash);
        }
    }

    public function handle_deltas($orderbook, $deltas) {
        //
        //   array(
        //      {
        //            "price" => "2999.00",
        //            "symbol" => "BTCUSDT",
        //            "id" => 29990000,
        //            "side" => "Buy",
        //            "size" => 8
        //      }
        //   )
        //
        for ($i = 0; $i < count($deltas); $i++) {
            $delta = $deltas[$i];
            $side = $this->safe_string($delta, 'side');
            if ($side === 'Buy') {
                $this->handle_delta($orderbook['bids'], $deltas[$i]);
            } else {
                $this->handle_delta($orderbook['asks'], $deltas[$i]);
            }
        }
    }

    public function handle_delta($bookside, $delta) {
        //
        //   {
        //         "price" => "2999.00",
        //         "symbol" => "BTCUSDT",
        //         "id" => 29990000,
        //         "side" => "Buy",
        //         "size" => 8
        //   }
        //
        $price = $this->safe_number($delta, 'price');
        $amount = $this->safe_number($delta, 'size');
        $bookside->store ($price, $amount);
    }

    public function watch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $trades made by the user
             * @param {string} $symbol unified $market $symbol of the $market orders were made in
             * @param {int|null} $since the earliest time in ms to fetch orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the bybit api endpoint
             * @return {[array]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $symbol = $market['symbol'];
            $commonChannel = 'trade';
            $url = $this->get_url_by_market_type($symbol, false, $params);
            $params = $this->clean_params($params);
            $messageHash = $commonChannel . ':' . $symbol;
            $trades = null;
            if ($market['spot']) {
                $reqParams = array(
                    'symbol' => $market['id'],
                );
                $trades = Async\await($this->watch_spot_public($url, $commonChannel, $messageHash, $reqParams, $params));
            } else {
                $channel = null;
                if ($market['option']) {
                    $channel = 'recenttrades' . '.' . $market['baseId'];
                } else {
                    $channel = $commonChannel . '.' . $market['id'];
                }
                $reqParams = array( $channel );
                $trades = Async\await($this->watch_contract_public($url, $messageHash, $reqParams, $params));
            }
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_trades($client, $message) {
        //
        // swap
        //    {
        //        $topic => 'trade.BTCUSDT',
        //        $data => array(
        //          {
        //            $symbol => 'BTCUSDT',
        //            tick_direction => 'ZeroPlusTick',
        //            price => '29678.00',
        //            size => 0.025,
        //            timestamp => '2022-05-19T13:36:01.000Z',
        //            trade_time_ms => '1652967361915',
        //            side => 'Buy',
        //            trade_id => '78352b1f-17b7-522a-9eea-b06f0deaf23e'
        //          }
        //        )
        //    }
        //
        // spot
        //
        //    {
        //        $topic => 'trade',
        //        $params => array( $symbol => 'BTCUSDT', binary => 'false', symbolName => 'BTCUSDT' ),
        //        $data => {
        //          v => '2290000000003002848',
        //          t => 1652967602261,
        //          p => '29698.82',
        //          q => '0.189531',
        //          m => true
        //        }
        //    }
        //
        $marketId = null;
        $data = $this->safe_value($message, 'data', array());
        $topic = $this->safe_string($message, 'topic');
        $trades = null;
        if (gettype($data) !== 'array' || array_keys($data) !== array_keys(array_keys($data))) {
            // spot markets
            $params = $this->safe_value($message, 'params', array());
            $marketId = $this->safe_string($params, 'symbol');
            // injecting $marketId in trade
            $data['symbol'] = $marketId;
            $trades = array( $data );
        } else {
            // contract markets
            $parts = explode('.', $topic);
            $marketId = $this->safe_string($parts, 1);
            $trades = $data;
        }
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $stored = $this->safe_value($this->trades, $symbol);
        if ($stored === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $stored = new ArrayCache ($limit);
            $this->trades[$symbol] = $stored;
        }
        for ($j = 0; $j < count($trades); $j++) {
            $parsed = $this->parse_ws_trade($trades[$j], $market);
            $stored->append ($parsed);
        }
        $messageHash = 'trade' . ':' . $symbol;
        $client->resolve ($stored, $messageHash);
    }

    public function parse_ws_trade($trade, $market = null) {
        //
        // swap public
        //
        //     {
        //       $symbol => 'BTCUSDT',
        //       tick_direction => 'ZeroPlusTick',
        //       $price => '29678.00',
        //       size => 0.025,
        //       $timestamp => '2022-05-19T13:36:01.000Z',
        //       trade_time_ms => '1652967361915',
        //       $side => 'Buy',
        //       trade_id => '78352b1f-17b7-522a-9eea-b06f0deaf23e'
        //     }
        //
        // swap private
        //    {
        //        $symbol => 'LTCUSDT',
        //        $side => 'Buy',
        //        order_id => '6773a86c-24c3-4066-90b6-d45c6653f35f',
        //        exec_id => '91d4962c-828f-58f1-9a1e-388c357d9344',
        //        order_link_id => '',
        //        $price => 71.8,
        //        order_qty => 0.1,
        //        exec_type => 'Trade',
        //        exec_qty => 0.1,
        //        exec_fee => 0.004308,
        //        leaves_qty => 0,
        //        is_maker => false,
        //        trade_time => '2022-05-23T14:08:08.875206Z'
        //    }
        //
        // option
        //
        //     {
        //         "symbol":"BTC-31DEC21-36000-P",
        //         "tradeId":"787bf079-b6a5-5bc0-a76d-59dad9036e7b",
        //         "price":"371",
        //         "size":"0.01",
        //         "tradeTime":"1636510323144",
        //         "side":"Buy",
        //         "crossSeq":"118388"
        //     }
        //
        // usdc
        //   {
        //       "orderId":"290b1b83-b6bb-4327-9839-8c5b9c322b4c",
        //       "orderLinkId":"",
        //       "tradeId":"3a69833e-f23c-5530-83a9-ccbb4af34926",
        //       "symbol":"BTCPERP",
        //       "side":"Sell",
        //       "execPrice":"30331",
        //       "execQty":"0.001",
        //       "execFee":"0.0181986",
        //       "feeRate":"0.0006",
        //       "tradeTime":1653321686805,
        //       "lastLiquidityInd":"TAKER",
        //       "execValue":"30.331",
        //       "execType":"TRADE"
        //   }
        //
        // spot public
        //
        //    {
        //      'symbol' => 'BTCUSDT', // artificially added
        //       v => '2290000000003002848', // $trade $id
        //       t => 1652967602261,
        //       p => '29698.82',
        //       q => '0.189531',
        //       m => true
        //     }
        //
        // spot private
        //
        //     {
        //         'e' => 'ticketInfo',
        //         'E' => '1653313467249', // event time
        //         's' => 'LTCUSDT',
        //         'q' => '0.13621',
        //         't' => '1653313467227', // $timestamp
        //         'p' => '72.43',
        //         'T' => '2200000000004436641', // $trade Id
        //         'o' => '1162472050160422400', // order Id
        //         'c' => '1653313466834', // client Id
        //         'O' => '1162471954312183040',
        //         'a' => '24478790', // account $id
        //         'A' => '18478961',
        //         'm' => false, // $isMaker
        //     }
        //
        $id = $this->safe_string_n($trade, array( 'trade_id', 'v', 'tradeId', 'T', 'exec_id' ));
        $marketId = $this->safe_string_2($trade, 'symbol', 's');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $price = $this->safe_string_n($trade, array( 'p', 'price', 'execPrice' ));
        $amount = $this->safe_string_n($trade, array( 'q', 'size', 'exec_qty', 'execQty' ));
        $cost = $this->safe_string_2($trade, 'exec_value', 'execValue');
        $timestamp = $this->safe_integer_n($trade, array( 'trade_time_ms', 't', 'tradeTime', 'tradeTimeMs' ));
        if ($timestamp === null) {
            $timestamp = $this->parse8601($this->safe_string($trade, 'trade_time'));
        }
        $side = $this->safe_string_lower($trade, 'side');
        $isMaker = $this->safe_value_2($trade, 'm', 'is_maker');
        if ($isMaker === null) {
            $lastLiquidityInd = $this->safe_string($trade, 'lastLiquidityInd');
            $isMaker = ($lastLiquidityInd === 'MAKER');
        }
        $takerOrMaker = $isMaker ? 'maker' : 'taker';
        $orderId = $this->safe_string_n($trade, array( 'o', 'order_id', 'tradeTime' ));
        $fee = null;
        $isContract = $this->safe_value($market, 'contract');
        if ($isContract) {
            $feeCost = $this->safe_string_2($trade, 'exec_fee', 'execFee');
            if ($feeCost !== null) {
                $feeCurrency = $market['linear'] ? $market['quote'] : $market['base'];
                $fee = array(
                    'cost' => $feeCost,
                    'currency' => $feeCurrency,
                );
            }
        }
        return $this->safe_trade(array(
            'id' => $id,
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'order' => $orderId,
            'type' => null,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => $fee,
        ), $market);
    }

    public function watch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            $method = 'watchMyTrades';
            $messageHash = 'usertrade';
            Async\await($this->load_markets());
            $market = null;
            $type = null;
            $isUsdcSettled = null;
            $url = $this->get_url_by_market_type($symbol, true, $method, $params);
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
                $messageHash .= ':' . $symbol;
                $type = $market['type'];
                $isUsdcSettled = $market['settle'] === 'USDC';
            } else {
                list($type, $params) = $this->handle_market_type_and_params($method, null, $params);
                $settle = $this->safe_string($this->options, 'defaultSettle');
                $settle = $this->safe_string_2($params, 'settle', 'defaultSettle', $settle);
                $isUsdcSettled = $settle === 'USDC';
            }
            $params = $this->clean_params($params);
            $trades = null;
            if ($type === 'spot') {
                $trades = Async\await($this->watch_spot_private($url, $messageHash, $params));
            } else {
                $channel = null;
                if ($isUsdcSettled) {
                    $channel = ($type === 'option') ? 'user.openapi.option.trade' : 'user.openapi.perp.trade';
                } else {
                    $channel = 'execution';
                }
                $reqParams = array( $channel );
                $messageHash .= ':' . $channel;
                $trades = Async\await($this->watch_contract_private($url, $messageHash, $reqParams, $params));
            }
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_my_trades($client, $message) {
        //
        // spot
        //
        //   array(
        //       {
        //           'e' => 'ticketInfo',
        //           'E' => '1653313467249',
        //           's' => 'LTCUSDT',
        //           'q' => '0.13621',
        //           't' => '1653313467227',
        //           'p' => '72.43',
        //           'T' => '2200000000004436641',
        //           'o' => '1162472050160422400',
        //           'c' => '1653313466834',
        //           'O' => '1162471954312183040',
        //           'a' => '24478790',
        //           'A' => '18478961',
        //           'm' => false,
        //       }
        //   )
        //
        // usdc
        //
        //   {
        //       "id":"b4c38cdc-5708-4c24-9f26-b3468f7b9658",
        //       "topic":"user.openapi.perp.trade",
        //       "creationTime":1653321605512,
        //       "data":{
        //          "result":array(
        //             {
        //                "orderId":"cfafeaae-f4a5-4ee5-bd03-b899251b1557",
        //                "orderLinkId":"",
        //                "tradeId":"29a3b7da-f593-55c4-9f23-afd9d6715668",
        //                "symbol":"BTCPERP",
        //                "side":"Buy",
        //                "execPrice":"30333.5",
        //                "execQty":"0.001",
        //                "execFee":"0.0182001",
        //                "feeRate":"0.0006",
        //                "tradeTime":1653321605486,
        //                "lastLiquidityInd":"TAKER",
        //                "execValue":"30.3335",
        //                "execType":"TRADE"
        //             }
        //          ),
        //          "version":5,
        //          "baseLine":1
        //       }
        //   }
        //
        $topic = $this->safe_string($message, 'topic', '');
        $data = array();
        if (gettype($message) === 'array' && array_keys($message) === array_keys(array_keys($message))) {
            $data = $message;
        } else {
            $data = $this->safe_value($message, 'data', array());
            if (is_array($data) && array_key_exists('result', $data)) {
                // usdc
                $data = $data['result'];
            }
        }
        if ($this->myTrades === null) {
            $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
            $this->myTrades = new ArrayCacheBySymbolById ($limit);
        }
        $trades = $this->myTrades;
        $marketSymbols = array();
        for ($i = 0; $i < count($data); $i++) {
            $rawTrade = $data[$i];
            $parsed = $this->parse_ws_trade($rawTrade);
            $symbol = $parsed['symbol'];
            $marketSymbols[$symbol] = true;
            $trades->append ($parsed);
        }
        $symbols = is_array($marketSymbols) ? array_keys($marketSymbols) : array();
        for ($i = 0; $i < count($symbols); $i++) {
            $symbol = $symbols[$i];
            $messageHash = 'usertrade:' . $symbol . ':' . $topic;
            $client->resolve ($trades, $messageHash);
        }
        // non-$symbol specific
        $messageHash = 'usertrade:' . $topic;
        $client->resolve ($trades, $messageHash);
    }

    public function watch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * watches information on multiple $orders made by the user
             * @param {string|null} $symbol unified $market $symbol of the $market $orders were made in
             * @param {int|null} $since the earliest time in ms to fetch $orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {array} $params extra parameters specific to the bybit api endpoint
             * @return {[array]} a list of [order structures]{@link https://docs.ccxt.com/en/latest/manual.html#order-structure
             */
            $method = 'watchOrders';
            $messageHash = 'order';
            Async\await($this->load_markets());
            $market = null;
            $type = null;
            $isUsdcSettled = null;
            $url = $this->get_url_by_market_type($symbol, true, $method, $params);
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
                $messageHash .= ':' . $symbol;
                $type = $market['type'];
                $isUsdcSettled = $market['settle'] === 'USDC';
            } else {
                list($type, $params) = $this->handle_market_type_and_params($method, null, $params);
                $settle = $this->safe_string($this->options, 'defaultSettle');
                $settle = $this->safe_string_2($params, 'settle', 'defaultSettle', $settle);
                $isUsdcSettled = $settle === 'USDC';
            }
            $params = $this->clean_params($params);
            $orders = null;
            if ($type === 'spot') {
                $orders = Async\await($this->watch_spot_private($url, $messageHash, $params));
            } else {
                $channel = null;
                if ($isUsdcSettled) {
                    $channel = ($type === 'option') ? 'user.openapi.option.order' : 'user.openapi.perp.order';
                } else {
                    $orderType = $this->safe_string($params, 'orderType');
                    $stop = $this->safe_value($params, 'stop', false);
                    $isStopOrder = $stop || ($orderType === 'stop') || ($orderType === 'conditional');
                    $params = $this->omit($params, array( 'stop', 'orderType' ));
                    $channel = $isStopOrder ? 'stop_order' : 'order';
                }
                $reqParams = array( $channel );
                $messageHash .= ':' . $channel;
                $orders = Async\await($this->watch_contract_private($url, $messageHash, $reqParams, $params));
            }
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
        }) ();
    }

    public function handle_order($client, $message, $subscription = null) {
        //
        // spot order
        //
        //     array(
        //         {
        //           e => 'executionReport',
        //           E => '1653297251061',
        //           s => 'LTCUSDT',
        //           c => '1653297250740',
        //           S => 'SELL',
        //           o => 'MARKET_OF_BASE',
        //           f => 'GTC',
        //           q => '0.16233',
        //           p => '0',
        //           X => 'NEW',
        //           $i => '1162336018974750208',
        //           M => '0',
        //           l => '0',
        //           z => '0',
        //           L => '0',
        //           n => '0',
        //           N => '',
        //           u => true,
        //           w => true,
        //           m => false,
        //           O => '1653297251042',
        //           Z => '0',
        //           A => '0',
        //           C => false,
        //           v => '0',
        //           d => 'NO_LIQ'
        //         }
        //     )
        //
        // swap order
        //     {
        //         $topic => 'order',
        //         action => '',
        //         $data => array(
        //           {
        //             order_id => 'f52071fd-6604-4cff-8112-82958ec55d3f',
        //             order_link_id => '',
        //             $symbol => 'LTCUSDT',
        //             side => 'Buy',
        //             order_type => 'Market',
        //             price => 75.5,
        //             qty => 0.1,
        //             leaves_qty => 0,
        //             last_exec_price => 71.93,
        //             cum_exec_qty => 0.1,
        //             cum_exec_value => 7.193,
        //             cum_exec_fee => 0.0043158,
        //             time_in_force => 'ImmediateOrCancel',
        //             create_type => 'CreateByUser',
        //             cancel_type => 'UNKNOWN',
        //             order_status => 'Filled',
        //             take_profit => 0,
        //             stop_loss => 0,
        //             trailing_stop => 0,
        //             create_time => '2022-05-23T09:32:34.266539338Z',
        //             update_time => '2022-05-23T09:32:34.270607105Z',
        //             reduce_only => false,
        //             close_on_trigger => false,
        //             position_idx => '1'
        //           }
        //         )
        //     }
        // usdc order
        //
        //     {
        //         "id":"401a6485-5701-49f2-9d0b-c09d97d56748",
        //         "topic":"user.openapi.perp.order",
        //         "creationTime":1653304042137,
        //         "data":{
        //            "result":array(
        //               {
        //                  "orderId":"fe2e0765-fa47-4516-a962-fb021b9418e7",
        //                  "orderLinkId":"",
        //                  "createdAt":1653304042104,
        //                  "updatedAt":1653304042107,
        //                  "symbol":"BTCPERP",
        //                  "orderStatus":"New",
        //                  "side":"Buy",
        //                  "price":"20000.0000",
        //                  "qty":"0.001",
        //                  "cumExecQty":"0",
        //                  "leavesQty":"0.001",
        //                  "orderIM":"20.012",
        //                  "realisedPnl":null,
        //                  "orderType":"Limit",
        //                  "reduceOnly":0,
        //                  "timeInForce":"GoodTillCancel",
        //                  "cumExecFee":"0",
        //                  "orderPnl":"",
        //                  "basePrice":"",
        //                  "cumExecValue":"0",
        //                  "closeOnTrigger":"false",
        //                  "triggerBy":"UNKNOWN",
        //                  "takeProfit":"0",
        //                  "stopLoss":"0",
        //                  "tpTriggerBy":"UNKNOWN",
        //                  "slTriggerBy":"UNKNOWN",
        //                  "triggerPrice":"0",
        //                  "stopOrderType":"UNKNOWN",
        //                  "cancelType":"UNKNOWN"
        //               }
        //            ),
        //            "version":2,
        //            "baseLine":1,
        //            "dataType":"CHANGE"
        //         }
        //      }
        //
        $topic = $this->safe_string($message, 'topic', '');
        $data = array();
        $isSpot = false;
        if (gettype($message) === 'array' && array_keys($message) === array_keys(array_keys($message))) {
            $data = $message;
            $isSpot = true;
        } else {
            $data = $this->safe_value($message, 'data', array());
            if (is_array($data) && array_key_exists('result', $data)) {
                // usdc
                $data = $data['result'];
            }
        }
        $dataLength = count($data);
        if ($dataLength === 0) {
            return;
        }
        if ($this->orders === null) {
            $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
            $this->orders = new ArrayCacheBySymbolById ($limit);
        }
        $orders = $this->orders;
        $marketSymbols = array();
        for ($i = 0; $i < count($data); $i++) {
            $rawOrder = $data[$i];
            $parsed = null;
            if ($isSpot) {
                // spot $orders have a different format
                // from the REST API
                $parsed = $this->parse_ws_order($rawOrder);
            } else {
                $parsed = $this->parse_order($rawOrder);
            }
            $symbol = $parsed['symbol'];
            $marketSymbols[$symbol] = true;
            $orders->append ($parsed);
        }
        $symbols = is_array($marketSymbols) ? array_keys($marketSymbols) : array();
        for ($i = 0; $i < count($symbols); $i++) {
            $symbol = $symbols[$i];
            $messageHash = 'order:' . $symbol . ':' . $topic;
            $client->resolve ($orders, $messageHash);
        }
        $messageHash = 'order:' . $topic;
        // non-$symbol specific
        $client->resolve ($orders, $messageHash);
    }

    public function parse_ws_order($order, $market = null) {
        //
        //    {
        //        e => 'executionReport',
        //        E => '1653297251061', // $timestamp
        //        s => 'LTCUSDT', // $symbol
        //        c => '1653297250740', // user $id
        //        S => 'SELL', // $side
        //        o => 'MARKET_OF_BASE', // $order $type
        //        f => 'GTC', // time in force
        //        q => '0.16233', // quantity
        //        p => '0', // $price
        //        X => 'NEW', // $status
        //        i => '1162336018974750208', // $order $id
        //        M => '0',
        //        l => '0', // last $filled
        //        z => '0', // total $filled
        //        L => '0', // last traded $price
        //        n => '0', // trading $fee
        //        N => '', // $fee asset
        //        u => true,
        //        w => true,
        //        m => false, // is limit_maker
        //        O => '1653297251042', // $order creation
        //        Z => '0', // total $filled
        //        A => '0', // account $id
        //        C => false, // is close
        //        v => '0', // leverage
        //        d => 'NO_LIQ'
        //    }
        //
        $id = $this->safe_string($order, 'i');
        $marketId = $this->safe_string($order, 's');
        $symbol = $this->safe_symbol($marketId, $market);
        $timestamp = $this->safe_integer($order, 'O');
        $price = $this->safe_string($order, 'p');
        if ($price === '0') {
            $price = null; // $market orders
        }
        $amount = $this->safe_string($order, 'q');
        $filled = $this->safe_string($order, 'z');
        $status = $this->parse_order_status($this->safe_string($order, 'X'));
        $side = $this->safe_string_lower($order, 'S');
        $lastTradeTimestamp = $this->safe_string($order, 'E');
        $timeInForce = $this->safe_string($order, 'f');
        $type = $this->safe_string_lower($order, 'o');
        if (mb_strpos($type, 'market') !== false) {
            $type = 'market';
        }
        $fee = null;
        $feeCost = $this->safe_string($order, 'n');
        if ($feeCost !== null && $feeCost !== '0') {
            $feeCurrencyId = $this->safe_string($order, 'N');
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrencyCode,
            );
        }
        return $this->safe_order(array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $lastTradeTimestamp,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => null,
            'side' => $side,
            'price' => $price,
            'stopPrice' => null,
            'amount' => $amount,
            'cost' => null,
            'average' => null,
            'filled' => $filled,
            'remaining' => null,
            'status' => $status,
            'fee' => $fee,
            'trades' => null,
        ), $market);
    }

    public function watch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            $method = 'watchBalance';
            $type = null;
            list($type, $params) = $this->handle_market_type_and_params($method, null, $params);
            if ($type !== 'spot' && $type !== 'swap') {
                throw new NotSupported($this->id . ' watchBalance does not support ' . $type . ' type');
            }
            $messageHash = 'balance:' . $type;
            $url = $this->get_url_by_market_type(null, true, $method, $params);
            $params = $this->clean_params($params);
            if ($type === 'spot') {
                return Async\await($this->watch_spot_private($url, $messageHash, $params));
            } else {
                $reqParams = array(
                    'wallet',
                );
                return Async\await($this->watch_contract_private($url, $messageHash, $reqParams, $params));
            }
        }) ();
    }

    public function handle_balance($client, $message) {
        //
        // swap
        //
        //   {
        //       "topic":"wallet",
        //       "data":array(
        //          {
        //             "wallet_balance":10.052857,
        //             "available_balance":5.049857
        //             "coin" => "BTC", // if not available = usdt
        //          }
        //       )
        //   }
        //
        // spot $message
        //
        // array(
        //     {
        //        "e":"outboundAccountInfo",
        //        "E":"1653039590765",
        //        "T":true,
        //        "W":true,
        //        "D":true,
        //        "B":array(
        //           {
        //              "a":"USDT",
        //              "f":"14.6634752497",
        //              "l":"10"
        //           }
        //        )
        //     }
        // )
        //
        $topic = $this->safe_string($message, 'topic');
        $messageHash = 'balance';
        if ($topic === 'wallet') {
            $data = $this->safe_value($message, 'data', array());
            // swap
            for ($i = 0; $i < count($data); $i++) {
                $account = $this->account();
                $balance = $data[$i];
                $currencyId = $this->safe_string($balance, 'coin', 'USDT');
                $code = $this->safe_currency_code($currencyId);
                $account['free'] = $this->safe_string($balance, 'available_balance');
                $account['total'] = $this->safe_string($balance, 'wallet_balance');
                $this->balance[$code] = $account;
                $this->balance = $this->safe_balance($this->balance);
            }
            $messageHash .= ':' . 'swap';
            $client->resolve ($this->balance, $messageHash);
            return;
        }
        if (gettype($message) === 'array' && array_keys($message) === array_keys(array_keys($message))) {
            // spot $balance
            for ($i = 0; $i < count($message); $i++) {
                $balances = $this->safe_value($message[$i], 'B', array());
                for ($j = 0; $j < count($balances); $j++) {
                    $balance = $balances[$j];
                    $account = $this->account();
                    $code = $this->safe_currency_code($this->safe_string($balance, 'a'));
                    $account['free'] = $this->safe_string($balance, 'f');
                    $account['used'] = $this->safe_string($balance, 'l');
                    $this->balance[$code] = $account;
                    $this->balance = $this->safe_balance($this->balance);
                }
            }
            $messageHash .= ':' . 'spot';
            $client->resolve ($this->balance, $messageHash);
        }
    }

    public function watch_contract_public($url, $messageHash, $reqParams = array (), $params = array ()) {
        return Async\async(function () use ($url, $messageHash, $reqParams, $params) {
            $request = array(
                'op' => 'subscribe',
                'args' => $reqParams,
            );
            $message = array_merge($request, $params);
            return Async\await($this->watch($url, $messageHash, $message, $messageHash));
        }) ();
    }

    public function watch_spot_public($url, $channel, $messageHash, $reqParams = array (), $params = array ()) {
        return Async\async(function () use ($url, $channel, $messageHash, $reqParams, $params) {
            $reqParams = array_merge($reqParams, array(
                'binary' => false,
            ));
            $request = array(
                'topic' => $channel,
                'event' => 'sub',
                'params' => $reqParams,
            );
            $message = array_merge($request, $params);
            return Async\await($this->watch($url, $messageHash, $message, $messageHash));
        }) ();
    }

    public function watch_spot_private($url, $messageHash, $params = array ()) {
        return Async\async(function () use ($url, $messageHash, $params) {
            $channel = 'private';
            // sending the authentication message automatically
            // subscribes to all 3 private topics.
            $this->check_required_credentials();
            $expires = $this->milliseconds() + 10000;
            $expires = (string) $expires;
            $path = 'GET/realtime';
            $auth = $path . $expires;
            $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256', 'hex');
            $request = array(
                'op' => 'auth',
                'args' => array(
                    $this->apiKey, $expires, $signature,
                ),
            );
            return Async\await($this->watch($url, $messageHash, $request, $channel));
        }) ();
    }

    public function watch_contract_private($url, $messageHash, $reqParams, $params = array ()) {
        return Async\async(function () use ($url, $messageHash, $reqParams, $params) {
            Async\await($this->authenticate_contract($url, $params));
            return Async\await($this->watch_contract_public($url, $messageHash, $reqParams, $params));
        }) ();
    }

    public function authenticate_contract($url, $params = array ()) {
        return Async\async(function () use ($url, $params) {
            $this->check_required_credentials();
            $messageHash = 'login';
            $client = $this->client($url);
            $future = $this->safe_value($client->subscriptions, $messageHash);
            if ($future === null) {
                $future = $client->future ('authenticated');
                $expires = $this->milliseconds() + 10000;
                $expires = (string) $expires;
                $path = 'GET/realtime';
                $auth = $path . $expires;
                $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256', 'hex');
                $request = array(
                    'op' => 'auth',
                    'args' => array(
                        $this->apiKey, $expires, $signature,
                    ),
                );
                $this->spawn(array($this, 'watch'), $url, $messageHash, $request, $messageHash, $future);
            }
            return Async\await($future);
        }) ();
    }

    public function handle_error_message($client, $message) {
        //
        //   {
        //       $success => false,
        //       $ret_msg => 'error:invalid op',
        //       conn_id => '5e079fdd-9c7f-404d-9dbf-969d650838b5',
        //       $request => array( $op => '', args => null )
        //   }
        //
        // auth error
        //
        //   {
        //       $success => false,
        //       $ret_msg => 'error:USVC1111',
        //       conn_id => 'e73770fb-a0dc-45bd-8028-140e20958090',
        //       $request => {
        //         $op => 'auth',
        //         args => array(
        //           '9rFT6uR4uz9Imkw4Wx',
        //           '1653405853543',
        //           '542e71bd85597b4db0290f0ce2d13ed1fd4bb5df3188716c1e9cc69a879f7889'
        //         )
        //   }
        //
        //   array( $code => '-10009', desc => 'Invalid period!' )
        //
        $code = $this->safe_integer($message, 'code');
        try {
            if ($code !== null) {
                $feedback = $this->id . ' ' . $this->json($message);
                $this->throw_exactly_matched_exception($this->exceptions['exact'], $code, $feedback);
            }
            $success = $this->safe_value($message, 'success', false);
            if (!$success) {
                $ret_msg = $this->safe_string($message, 'ret_msg');
                $request = $this->safe_value($message, 'request', array());
                $op = $this->safe_string($request, 'op');
                if ($op === 'auth') {
                    throw new AuthenticationError('Authentication failed => ' . $ret_msg);
                }
            }
        } catch (Exception $e) {
            if ($e instanceof AuthenticationError) {
                $client->reject ($e, 'authenticated');
                $method = 'login';
                if (is_array($client->subscriptions) && array_key_exists($method, $client->subscriptions)) {
                    unset($client->subscriptions[$method]);
                }
                return false;
            }
        }
        return $message;
    }

    public function handle_message($client, $message) {
        //
        //    {
        //        $topic => 'realtimes',
        //        params => array( symbol => 'BTCUSDT', binary => 'false', symbolName => 'BTCUSDT' ),
        //        data => {
        //          t => 1652883737410,
        //          s => 'BTCUSDT',
        //          o => '30422.68',
        //          h => '30715',
        //          l => '29288.44',
        //          c => '29462.94',
        //          v => '4350.340495',
        //          qv => '130497543.0334267',
        //          m => '-0.0315'
        //        }
        //    }
        //    {
        //        $topic => 'klineV2.1.LTCUSD',
        //        data => array(
        //          {
        //            start => 1652893140,
        //            end => 1652893200,
        //            open => 67.9,
        //            close => 67.84,
        //            high => 67.91,
        //            low => 67.84,
        //            volume => 56,
        //            turnover => 0.82528936,
        //            timestamp => '1652893152874413',
        //            confirm => false,
        //            cross_seq => 63544166
        //          }
        //        ),
        //        timestamp_e6 => 1652893152874413
        //    }
        //
        //    {
        //        $topic => 'kline',
        //        $event => 'sub',
        //        params => array(
        //          symbol => 'LTCUSDT',
        //          binary => 'false',
        //          klineType => '1m',
        //          symbolName => 'LTCUSDT'
        //        ),
        //        code => '0',
        //        msg => 'Success'
        //    }
        //
        //    {
        //        $topic => 'trade.BTCUSDT',
        //        data => array(
        //          {
        //            symbol => 'BTCUSDT',
        //            tick_direction => 'ZeroPlusTick',
        //            price => '29678.00',
        //            size => 0.025,
        //            timestamp => '2022-05-19T13:36:01.000Z',
        //            trade_time_ms => '1652967361915',
        //            side => 'Buy',
        //            trade_id => '78352b1f-17b7-522a-9eea-b06f0deaf23e'
        //          }
        //        )
        //    }
        //    {
        //        success => true,
        //        $ret_msg => '',
        //        conn_id => '55f508ad-d17b-48d8-8b19-669280a25a72',
        //        $request => {
        //          $op => 'auth',
        //          args => array(
        //            'cH4MQfkrFNKYiLfpVB',
        //            '1653038985746',
        //            'eede78af3eb916ffc569a5c1466b83e36034324f480ca2684728d17fb606acae'
        //          )
        //        }
        //    }
        //
        if (!$this->handle_error_message($client, $message)) {
            return;
        }
        // contract $pong
        $ret_msg = $this->safe_string($message, 'ret_msg');
        if ($ret_msg === 'pong') {
            $this->handle_pong($client, $message);
            return;
        }
        // spot $pong
        $pong = $this->safe_integer($message, 'pong');
        if ($pong !== null) {
            $this->handle_pong($client, $message);
            return;
        }
        // usdc $pong
        $op = $this->safe_string($message, 'op');
        if ($op === 'pong') {
            $this->handle_pong($client, $message);
            return;
        }
        $event = $this->safe_string($message, 'event');
        if ($event === 'sub') {
            $this->handle_subscription_status($client, $message);
            return;
        }
        // contract public and private
        $topic = $this->safe_string($message, 'topic', '');
        if ((mb_strpos($topic, 'kline') !== false || mb_strpos($topic, 'candle') !== false)) {
            $this->handle_ohlcv($client, $message);
            return;
        }
        if ((mb_strpos($topic, 'realtimes') !== false || mb_strpos($topic, 'instrument_info') !== false)) {
            $this->handle_ticker($client, $message);
            return;
        }
        if ((mb_strpos($topic, 'trade') !== false)) {
            if ((mb_strpos($topic, 'user') !== false)) {
                $this->handle_my_trades($client, $message);
                return;
            }
            $this->handle_trades($client, $message);
        }
        if (mb_strpos($topic, 'orderBook') !== false) {
            $this->handle_order_book($client, $message);
            return;
        }
        if (mb_strpos($topic, 'order') !== false) {
            $this->handle_order($client, $message);
            return;
        }
        $methods = array(
            'realtimes' => array($this, 'handle_ticker'),
            'bookTicker' => array($this, 'handle_ticker'),
            'depth' => array($this, 'handle_order_book'),
            'wallet' => array($this, 'handle_balance'),
            'execution' => array($this, 'handle_my_trades'),
        );
        $method = $this->safe_value($methods, $topic);
        if ($method !== null) {
            $method($client, $message);
        }
        // contract auth acknowledgement
        $request = $this->safe_value($message, 'request', array());
        $reqOp = $this->safe_string($request, 'op');
        if ($reqOp === 'auth') {
            $this->handle_authenticate($client, $message);
        }
        // usdc auth
        $type = $this->safe_string($message, 'type');
        if ($type === 'AUTH_RESP') {
            $this->handle_authenticate($client, $message);
        }
        // private spot topics
        if (gettype($message) === 'array' && array_keys($message) === array_keys(array_keys($message))) {
            $first = $this->safe_value($message, 0);
            $topic = $this->safe_string($first, 'e');
            if ($topic === 'outboundAccountInfo') {
                $this->handle_balance($client, $message);
            }
            if ($topic === 'executionReport') {
                $this->handle_order($client, $message);
            }
            if ($topic === 'ticketInfo') {
                $this->handle_my_trades($client, $message);
            }
        }
    }

    public function ping($client) {
        $url = $client->url;
        $timestamp = $this->milliseconds();
        if (mb_strpos($url, 'spot') !== false) {
            return array( 'ping' => $timestamp );
        }
        return array( 'op' => 'ping' );
    }

    public function handle_pong($client, $message) {
        //
        //   {
        //       success => true,
        //       ret_msg => 'pong',
        //       conn_id => 'db3158a0-8960-44b9-a9de-ac350ee13158',
        //       request => array( op => 'ping', args => null )
        //   }
        //
        //   array( pong => 1653296711335 )
        //
        $client->lastPong = $this->safe_integer($message, 'pong');
        return $message;
    }

    public function handle_authenticate($client, $message) {
        //
        //    {
        //        success => true,
        //        ret_msg => '',
        //        conn_id => '55f508ad-d17b-48d8-8b19-669280a25a72',
        //        request => {
        //          op => 'auth',
        //          args => array(
        //            'cH4MQfkrFNKYiLfpVB',
        //            '1653038985746',
        //            'eede78af3eb916ffc569a5c1466b83e36034324f480ca2684728d17fb606acae'
        //          )
        //        }
        //    }
        //
        // this will only be effective for swap markets,
        // spot markets don't have this 'authenticated' future
        $client->resolve ($message, 'authenticated');
        return $message;
    }

    public function handle_subscription_status($client, $message) {
        //
        //    {
        //        topic => 'kline',
        //        event => 'sub',
        //        params => array(
        //          symbol => 'LTCUSDT',
        //          binary => 'false',
        //          klineType => '1m',
        //          symbolName => 'LTCUSDT'
        //        ),
        //        code => '0',
        //        msg => 'Success'
        //    }
        //
        return $message;
    }
}
