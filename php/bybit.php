<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import

class bybit extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'bybit',
            'name' => 'Bybit',
            'countries' => array( 'VG' ), // British Virgin Islands
            'version' => 'v3',
            'userAgent' => null,
            'rateLimit' => 20,
            'hostname' => 'bybit.com', // bybit.com, bytick.com
            'pro' => true,
            'certified' => true,
            'has' => array(
                'CORS' => true,
                'spot' => true,
                'margin' => true,
                'swap' => true,
                'future' => true,
                'option' => null,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'createOrder' => true,
                'createStopLimitOrder' => true,
                'createStopMarketOrder' => true,
                'createStopOrder' => true,
                'editOrder' => true,
                'fetchBalance' => true,
                'fetchBorrowInterest' => false, // temporarily disabled, as it does not work
                'fetchBorrowRate' => true,
                'fetchBorrowRateHistories' => false,
                'fetchBorrowRateHistory' => false,
                'fetchBorrowRates' => false,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => true,
                'fetchDepositAddresses' => false,
                'fetchDepositAddressesByNetwork' => true,
                'fetchDeposits' => true,
                'fetchFundingRate' => true,
                'fetchFundingRateHistory' => true,
                'fetchIndexOHLCV' => true,
                'fetchLedger' => true,
                'fetchMarketLeverageTiers' => true,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterest' => true,
                'fetchOpenInterestHistory' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchOrderTrades' => true,
                'fetchPosition' => true,
                'fetchPositions' => true,
                'fetchPremiumIndexOHLCV' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => true,
                'fetchTradingFees' => true,
                'fetchTransactions' => null,
                'fetchTransfers' => true,
                'fetchWithdrawals' => true,
                'setLeverage' => true,
                'setMarginMode' => true,
                'setPositionMode' => true,
                'transfer' => true,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1',
                '3m' => '3',
                '5m' => '5',
                '15m' => '15',
                '30m' => '30',
                '1h' => '60',
                '2h' => '120',
                '4h' => '240',
                '6h' => '360',
                '12h' => '720',
                '1d' => 'D',
                '1w' => 'W',
                '1M' => 'M',
                '1y' => 'Y',
            ),
            'urls' => array(
                'test' => array(
                    'spot' => 'https://api-testnet.{hostname}',
                    'futures' => 'https://api-testnet.{hostname}',
                    'v2' => 'https://api-testnet.{hostname}',
                    'public' => 'https://api-testnet.{hostname}',
                    'private' => 'https://api-testnet.{hostname}',
                ),
                'logo' => 'https://user-images.githubusercontent.com/51840849/76547799-daff5b80-649e-11ea-87fb-3be9bac08954.jpg',
                'api' => array(
                    'spot' => 'https://api.{hostname}',
                    'futures' => 'https://api.{hostname}',
                    'v2' => 'https://api.{hostname}',
                    'public' => 'https://api.{hostname}',
                    'private' => 'https://api.{hostname}',
                ),
                'www' => 'https://www.bybit.com',
                'doc' => array(
                    'https://bybit-exchange.github.io/docs/inverse/',
                    'https://bybit-exchange.github.io/docs/linear/',
                    'https://github.com/bybit-exchange',
                ),
                'fees' => 'https://help.bybit.com/hc/en-us/articles/360039261154',
                'referral' => 'https://www.bybit.com/register?affiliate_id=35953',
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        // inverse swap
                        'v2/public/orderBook/L2' => 1,
                        'v2/public/kline/list' => 3,
                        'v2/public/tickers' => 1,
                        'v2/public/trading-records' => 1,
                        'v2/public/symbols' => 1,
                        'v2/public/mark-price-kline' => 3,
                        'v2/public/index-price-kline' => 3,
                        'v2/public/premium-index-kline' => 2,
                        'v2/public/open-interest' => 1,
                        'v2/public/big-deal' => 1,
                        'v2/public/account-ratio' => 1,
                        'v2/public/funding-rate' => 1,
                        'v2/public/elite-ratio' => 1,
                        'v2/public/funding/prev-funding-rate' => 1,
                        'v2/public/risk-limit/list' => 1,
                        // linear swap USDT
                        'public/linear/kline' => 3,
                        'public/linear/recent-trading-records' => 1,
                        'public/linear/risk-limit' => 1,
                        'public/linear/funding/prev-funding-rate' => 1,
                        'public/linear/mark-price-kline' => 1,
                        'public/linear/index-price-kline' => 1,
                        'public/linear/premium-index-kline' => 1,
                        // spot
                        'spot/v1/time' => 1,
                        'spot/v1/symbols' => 1,
                        'spot/quote/v1/depth' => 1,
                        'spot/quote/v1/depth/merged' => 1,
                        'spot/quote/v1/trades' => 1,
                        'spot/quote/v1/kline' => 1,
                        'spot/quote/v1/ticker/24hr' => 1,
                        'spot/quote/v1/ticker/price' => 1,
                        'spot/quote/v1/ticker/book_ticker' => 1,
                        'spot/v3/public/symbols' => 1,
                        'spot/v3/public/quote/depth' => 1,
                        'spot/v3/public/quote/depth/merged' => 1,
                        'spot/v3/public/quote/trades' => 1,
                        'spot/v3/public/quote/kline' => 1,
                        'spot/v3/public/quote/ticker/24hr' => 1,
                        'spot/v3/public/quote/ticker/price' => 1,
                        'spot/v3/public/quote/ticker/bookTicker' => 1,
                        'spot/v3/public/server-time' => 1,
                        'spot/v3/public/infos' => 1,
                        // data
                        'v2/public/time' => 1,
                        'v3/public/time' => 1,
                        'v2/public/announcement' => 1,
                        // USDC endpoints
                        // option USDC
                        'option/usdc/openapi/public/v1/order-book' => 1,
                        'option/usdc/openapi/public/v1/symbols' => 1,
                        'option/usdc/openapi/public/v1/tick' => 1,
                        'option/usdc/openapi/public/v1/delivery-price' => 1,
                        'option/usdc/openapi/public/v1/query-trade-latest' => 1,
                        'option/usdc/openapi/public/v1/query-historical-volatility' => 1,
                        'option/usdc/openapi/public/v1/all-tickers' => 1,
                        // perpetual swap USDC
                        'perpetual/usdc/openapi/public/v1/order-book' => 1,
                        'perpetual/usdc/openapi/public/v1/symbols' => 1,
                        'perpetual/usdc/openapi/public/v1/tick' => 1,
                        'perpetual/usdc/openapi/public/v1/kline/list' => 1,
                        'perpetual/usdc/openapi/public/v1/mark-price-kline' => 1,
                        'perpetual/usdc/openapi/public/v1/index-price-kline' => 1,
                        'perpetual/usdc/openapi/public/v1/premium-index-kline' => 1,
                        'perpetual/usdc/openapi/public/v1/open-interest' => 1,
                        'perpetual/usdc/openapi/public/v1/big-deal' => 1,
                        'perpetual/usdc/openapi/public/v1/account-ratio' => 1,
                        'perpetual/usdc/openapi/public/v1/prev-funding-rate' => 1,
                        'perpetual/usdc/openapi/public/v1/risk-limit/list' => 1,
                        // account
                        'asset/v1/public/deposit/allowed-deposit-list' => 1,
                        'contract/v3/public/copytrading/symbol/list' => 1,
                        // derivative
                        'derivatives/v3/public/order-book/L2' => 1,
                        'derivatives/v3/public/kline' => 1,
                        'derivatives/v3/public/tickers' => 1,
                        'derivatives/v3/public/instruments-info' => 1,
                        'derivatives/v3/public/mark-price-kline' => 1,
                        'derivatives/v3/public/index-price-kline' => 1,
                        'derivatives/v3/public/funding/history-funding-rate' => 1,
                        'derivatives/v3/public/risk-limit/list' => 1,
                        'derivatives/v3/public/delivery-price' => 1,
                        'derivatives/v3/public/recent-trade' => 1,
                        'derivatives/v3/public/open-interest' => 1,
                        'derivatives/v3/public/insurance' => 1,
                    ),
                ),
                'private' => array(
                    'get' => array(
                        // inverse swap
                        'v2/private/order/list' => 5,
                        'v2/private/order' => 5,
                        'v2/private/stop-order/list' => 5,
                        'v2/private/stop-order' => 1,
                        'v2/private/position/list' => 25,
                        'v2/private/position/fee-rate' => 40,
                        'v2/private/execution/list' => 25,
                        'v2/private/trade/closed-pnl/list' => 1,
                        'v2/public/risk-limit/list' => 1, // TODO check
                        'v2/public/funding/prev-funding-rate' => 25, // TODO check
                        'v2/private/funding/prev-funding' => 25,
                        'v2/private/funding/predicted-funding' => 25,
                        'v2/private/account/api-key' => 5,
                        'v2/private/account/lcp' => 1,
                        'v2/private/wallet/balance' => 25, // 120 per minute = 2 per second => cost = 50 / 2 = 25
                        'v2/private/wallet/fund/records' => 25,
                        'v2/private/wallet/withdraw/list' => 25,
                        'v2/private/exchange-order/list' => 1,
                        // linear swap USDT
                        'private/linear/order/list' => 5, // 600 per minute = 10 per second => cost = 50 / 10 =  5
                        'private/linear/order/search' => 5,
                        'private/linear/stop-order/list' => 5,
                        'private/linear/stop-order/search' => 5,
                        'private/linear/position/list' => 25,
                        'private/linear/trade/execution/list' => 25,
                        'private/linear/trade/closed-pnl/list' => 25,
                        'public/linear/risk-limit' => 1,
                        'private/linear/funding/predicted-funding' => 25,
                        'private/linear/funding/prev-funding' => 25,
                        // inverse futures
                        'futures/private/order/list' => 5,
                        'futures/private/order' => 5,
                        'futures/private/stop-order/list' => 5,
                        'futures/private/stop-order' => 5,
                        'futures/private/position/list' => 25,
                        'futures/private/execution/list' => 25,
                        'futures/private/trade/closed-pnl/list' => 1,
                        // spot
                        'spot/v1/account' => 2.5,
                        'spot/v1/order' => 2.5,
                        'spot/v1/open-orders' => 2.5,
                        'spot/v1/history-orders' => 2.5,
                        'spot/v1/myTrades' => 2.5,
                        'spot/v1/cross-margin/order' => 10,
                        'spot/v1/cross-margin/accounts/balance' => 10,
                        'spot/v1/cross-margin/loan-info' => 10,
                        'spot/v1/cross-margin/repay/history' => 10,
                        'spot/v3/private/order' => 2.5,
                        'spot/v3/private/open-orders' => 2.5,
                        'spot/v3/private/history-orders' => 2.5,
                        'spot/v3/private/my-trades' => 2.5,
                        'spot/v3/private/account' => 2.5,
                        'spot/v3/private/reference' => 2.5,
                        'spot/v3/private/record' => 2.5,
                        'spot/v3/private/cross-margin-orders' => 10,
                        'spot/v3/private/cross-margin-account' => 10,
                        'spot/v3/private/cross-margin-loan-info' => 10,
                        'spot/v3/private/cross-margin-repay-history' => 10,
                        // account
                        'asset/v1/private/transfer/list' => 50, // 60 per minute = 1 per second => cost = 50 / 1 = 50
                        'asset/v3/private/transfer/inter-transfer/list/query' => 0.84, // 60/s
                        'asset/v1/private/sub-member/transfer/list' => 50,
                        'asset/v3/private/transfer/sub-member/list/query' => 0.84, // 60/s
                        'asset/v3/private/transfer/sub-member-transfer/list/query' => 0.84, // 60/s
                        'asset/v3/private/transfer/universal-transfer/list/query' => 0.84, // 60/s
                        'asset/v1/private/sub-member/member-ids' => 50,
                        'asset/v1/private/deposit/record/query' => 50,
                        'asset/v1/private/withdraw/record/query' => 25,
                        'asset/v1/private/coin-info/query' => 25,
                        'asset/v3/private/coin-info/query' => 25, // 2/s
                        'asset/v1/private/asset-info/query' => 50,
                        'asset/v1/private/deposit/address' => 100,
                        'asset/v3/private/deposit/address/query' => 0.17, // 300/s
                        'asset/v1/private/universal/transfer/list' => 50,
                        'contract/v3/private/copytrading/order/list' => 1,
                        'contract/v3/private/copytrading/position/list' => 1,
                        'contract/v3/private/copytrading/wallet/balance' => 1,
                        'contract/v3/private/position/limit-info' => 25, // 120 per minute = 2 per second => cost = 50 / 2 = 25
                        'contract/v3/private/order/unfilled-orders' => 1,
                        'contract/v3/private/order/list' => 1,
                        'contract/v3/private/position/list' => 1,
                        'contract/v3/private/execution/list' => 1,
                        'contract/v3/private/position/closed-pnl' => 1,
                        'contract/v3/private/account/wallet/balance' => 1,
                        'contract/v3/private/account/fee-rate' => 1,
                        'contract/v3/private/account/wallet/fund-records' => 1,
                        // derivative
                        'unified/v3/private/order/unfilled-orders' => 1,
                        'unified/v3/private/order/list' => 1,
                        'unified/v3/private/position/list' => 1,
                        'unified/v3/private/execution/list' => 1,
                        'unified/v3/private/delivery-record' => 1,
                        'unified/v3/private/settlement-record' => 1,
                        'unified/v3/private/account/wallet/balance' => 1,
                        'unified/v3/private/account/transaction-log' => 1,
                        'asset/v2/private/exchange/exchange-order-all' => 1,
                        'unified/v3/private/account/borrow-history' => 1,
                        'unified/v3/private/account/borrow-rate' => 1,
                        'user/v3/private/frozen-sub-member' => 10, // 5/s
                        'user/v3/private/query-sub-members' => 5, // 10/s
                        'user/v3/private/query-api' => 5, // 10/s
                        'asset/v3/private/transfer/transfer-coin/list/query' => 0.84, // 60/s
                        'asset/v3/private/transfer/account-coin/balance/query' => 0.84, // 60/s
                        'asset/v3/private/transfer/asset-info/query' => 0.84, // 60/s
                        'asset/v3/public/deposit/allowed-deposit-list/query' => 0.17, // 300/s
                        'asset/v3/private/deposit/record/query' => 0.17, // 300/s
                        'asset/v3/private/withdraw/record/query' => 0.17, // 300/s
                    ),
                    'post' => array(
                        // inverse swap
                        'v2/private/order/create' => 30,
                        'v2/private/order/cancel' => 30,
                        'v2/private/order/cancelAll' => 300, // 100 per minute . 'consumes 10 requests'
                        'v2/private/order/replace' => 30,
                        'v2/private/stop-order/create' => 30,
                        'v2/private/stop-order/cancel' => 30,
                        'v2/private/stop-order/cancelAll' => 300,
                        'v2/private/stop-order/replace' => 30,
                        'v2/private/position/change-position-margin' => 40,
                        'v2/private/position/trading-stop' => 40,
                        'v2/private/position/leverage/save' => 40,
                        'v2/private/tpsl/switch-mode' => 40,
                        'v2/private/position/switch-isolated' => 2.5,
                        'v2/private/position/risk-limit' => 2.5,
                        'v2/private/position/switch-mode' => 2.5,
                        // linear swap USDT
                        'private/linear/order/create' => 30, // 100 per minute = 1.666 per second => cost = 50 / 1.6666 = 30
                        'private/linear/order/cancel' => 30,
                        'private/linear/order/cancel-all' => 300, // 100 per minute . 'consumes 10 requests'
                        'private/linear/order/replace' => 30,
                        'private/linear/stop-order/create' => 30,
                        'private/linear/stop-order/cancel' => 30,
                        'private/linear/stop-order/cancel-all' => 300,
                        'private/linear/stop-order/replace' => 30,
                        'private/linear/position/set-auto-add-margin' => 40,
                        'private/linear/position/switch-isolated' => 40,
                        'private/linear/position/switch-mode' => 40,
                        'private/linear/tpsl/switch-mode' => 2.5,
                        'private/linear/position/add-margin' => 40,
                        'private/linear/position/set-leverage' => 40, // 75 per minute = 1.25 per second => cost = 50 / 1.25 = 40
                        'private/linear/position/trading-stop' => 40,
                        'private/linear/position/set-risk' => 2.5,
                        // inverse futures
                        'futures/private/order/create' => 30,
                        'futures/private/order/cancel' => 30,
                        'futures/private/order/cancelAll' => 30,
                        'futures/private/order/replace' => 30,
                        'futures/private/stop-order/create' => 30,
                        'futures/private/stop-order/cancel' => 30,
                        'futures/private/stop-order/cancelAll' => 30,
                        'futures/private/stop-order/replace' => 30,
                        'futures/private/position/change-position-margin' => 40,
                        'futures/private/position/trading-stop' => 40,
                        'futures/private/position/leverage/save' => 40,
                        'futures/private/position/switch-mode' => 40,
                        'futures/private/tpsl/switch-mode' => 40,
                        'futures/private/position/switch-isolated' => 40,
                        'futures/private/position/risk-limit' => 2.5,
                        // spot
                        'spot/v1/order' => 2.5,
                        'spot/v1/cross-margin/loan' => 10,
                        'spot/v1/cross-margin/repay' => 10,
                        'spot/v3/private/order' => 2.5,
                        'spot/v3/private/cancel-order' => 2.5,
                        'spot/v3/private/cancel-orders' => 2.5,
                        'spot/v3/private/cancel-orders-by-ids' => 2.5,
                        'spot/v3/private/purchase' => 2.5,
                        'spot/v3/private/redeem' => 2.5,
                        'spot/v3/private/cross-margin-loan' => 10,
                        'spot/v3/private/cross-margin-repay' => 10,
                        // account
                        'asset/v1/private/transfer' => 150, // 20 per minute = 0.333 per second => cost = 50 / 0.3333 = 150
                        'asset/v3/private/transfer/inter-transfer' => 2.5, // 20/s
                        'asset/v1/private/sub-member/transfer' => 150,
                        'asset/v1/private/withdraw' => 50,
                        'asset/v3/private/withdraw/create' => 1, // 10/s
                        'asset/v1/private/withdraw/cancel' => 50,
                        'asset/v3/private/withdraw/cancel' => 0.84, // 60/s
                        'asset/v1/private/transferable-subs/save' => 3000,
                        'asset/v1/private/universal/transfer' => 1500,
                        'asset/v3/private/transfer/sub-member-transfer' => 2.5, // 20/s
                        'asset/v3/private/transfer/transfer-sub-member-save' => 2.5, // 20/s
                        'asset/v3/private/transfer/universal-transfer' => 2.5, // 20/s
                        'user/v3/private/create-sub-member' => 10, // 5/s
                        'user/v3/private/create-sub-api' => 10, // 5/s
                        'user/v3/private/update-api' => 10, // 5/s
                        'user/v3/private/delete-api' => 10, // 5/s
                        'user/v3/private/update-sub-api' => 10, // 5/s
                        'user/v3/private/delete-sub-api' => 10, // 5/s
                        // USDC endpoints
                        // option USDC
                        'option/usdc/openapi/private/v1/place-order' => 2.5,
                        'option/usdc/openapi/private/v1/batch-place-order' => 2.5,
                        'option/usdc/openapi/private/v1/replace-order' => 2.5,
                        'option/usdc/openapi/private/v1/batch-replace-orders' => 2.5,
                        'option/usdc/openapi/private/v1/cancel-order' => 2.5,
                        'option/usdc/openapi/private/v1/batch-cancel-orders' => 2.5,
                        'option/usdc/openapi/private/v1/cancel-all' => 2.5,
                        'option/usdc/openapi/private/v1/query-active-orders' => 2.5,
                        'option/usdc/openapi/private/v1/query-order-history' => 2.5,
                        'option/usdc/openapi/private/v1/execution-list' => 2.5,
                        'option/usdc/openapi/private/v1/query-transaction-log' => 2.5,
                        'option/usdc/openapi/private/v1/query-wallet-balance' => 2.5,
                        'option/usdc/openapi/private/v1/query-asset-info' => 2.5,
                        'option/usdc/openapi/private/v1/query-margin-info' => 2.5,
                        'option/usdc/openapi/private/v1/query-position' => 2.5,
                        'option/usdc/openapi/private/v1/query-delivery-list' => 2.5,
                        'option/usdc/openapi/private/v1/query-position-exp-date' => 2.5,
                        'option/usdc/openapi/private/v1/mmp-modify' => 2.5,
                        'option/usdc/openapi/private/v1/mmp-reset' => 2.5,
                        // perpetual swap USDC
                        'perpetual/usdc/openapi/private/v1/place-order' => 2.5,
                        'perpetual/usdc/openapi/private/v1/replace-order' => 2.5,
                        'perpetual/usdc/openapi/private/v1/cancel-order' => 2.5,
                        'perpetual/usdc/openapi/private/v1/cancel-all' => 2.5,
                        'perpetual/usdc/openapi/private/v1/position/leverage/save' => 2.5,
                        'option/usdc/openapi/private/v1/session-settlement' => 2.5,
                        'option/usdc/private/asset/account/setMarginMode' => 2.5,
                        'perpetual/usdc/openapi/public/v1/risk-limit/list' => 2.5,
                        'perpetual/usdc/openapi/private/v1/position/set-risk-limit' => 2.5,
                        'perpetual/usdc/openapi/private/v1/predicted-funding' => 2.5,
                        'contract/v3/private/copytrading/order/create' => 2.5,
                        'contract/v3/private/copytrading/order/cancel' => 2.5,
                        'contract/v3/private/copytrading/order/close' => 2.5,
                        'contract/v3/private/copytrading/position/close' => 2.5,
                        'contract/v3/private/copytrading/position/set-leverage' => 2.5,
                        'contract/v3/private/copytrading/wallet/transfer' => 2.5,
                        'contract/v3/private/copytrading/order/trading-stop' => 2.5,
                        'contract/v3/private/order/create' => 1,
                        'contract/v3/private/order/cancel' => 1,
                        'contract/v3/private/order/cancel-all' => 1,
                        'contract/v3/private/order/replace' => 1,
                        'contract/v3/private/position/set-auto-add-margin' => 1,
                        'contract/v3/private/position/switch-isolated' => 1,
                        'contract/v3/private/position/switch-mode' => 1,
                        'contract/v3/private/position/switch-tpsl-mode' => 1,
                        'contract/v3/private/position/set-leverage' => 1,
                        'contract/v3/private/position/trading-stop' => 1,
                        'contract/v3/private/position/set-risk-limit' => 1,
                        'contract/v3/private/account/setMarginMode' => 1,
                        // derivative
                        'unified/v3/private/order/create' => 2.5,
                        'unified/v3/private/order/replace' => 2.5,
                        'unified/v3/private/order/cancel' => 2.5,
                        'unified/v3/private/order/create-batch' => 2.5,
                        'unified/v3/private/order/replace-batch' => 2.5,
                        'unified/v3/private/order/cancel-batch' => 2.5,
                        'unified/v3/private/order/cancel-all' => 2.5,
                        'unified/v3/private/position/set-leverage' => 2.5,
                        'unified/v3/private/position/tpsl/switch-mode' => 2.5,
                        'unified/v3/private/position/set-risk-limit' => 2.5,
                        'unified/v3/private/position/trading-stop' => 2.5,
                        'unified/v3/private/account/upgrade-unified-account' => 2.5,
                    ),
                    'delete' => array(
                        // spot
                        'spot/v1/order' => 2.5,
                        'spot/v1/order/fast' => 2.5,
                        'spot/order/batch-cancel' => 2.5,
                        'spot/order/batch-fast-cancel' => 2.5,
                        'spot/order/batch-cancel-by-ids' => 2.5,
                    ),
                ),
            ),
            'httpExceptions' => array(
                '403' => '\\ccxt\\RateLimitExceeded', // Forbidden -- You request too many times
            ),
            'exceptions' => array(
                // Uncodumented explanation of error strings:
                // - oc_diff => order cost needed to place this order
                // - new_oc => total order cost of open orders including the order you are trying to open
                // - ob => order balance - the total cost of current open orders
                // - ab => available balance
                'exact' => array(
                    '-10009' => '\\ccxt\\BadRequest', // array("ret_code":-10009,"ret_msg":"Invalid period!","result":null,"token":null)
                    '-1004' => '\\ccxt\\BadRequest', // array("ret_code":-1004,"ret_msg":"Missing required parameter \u0027symbol\u0027","ext_code":null,"ext_info":null,"result":null)
                    '-1021' => '\\ccxt\\BadRequest', // array("ret_code":-1021,"ret_msg":"Timestamp for this request is outside of the recvWindow.","ext_code":null,"ext_info":null,"result":null)
                    '-1103' => '\\ccxt\\BadRequest', // An unknown parameter was sent.
                    '-1140' => '\\ccxt\\InvalidOrder', // array("ret_code":-1140,"ret_msg":"Transaction amount lower than the minimum.","result":array(),"ext_code":"","ext_info":null,"time_now":"1659204910.248576")
                    '-1197' => '\\ccxt\\InvalidOrder', // array("ret_code":-1197,"ret_msg":"Your order quantity to buy is too large. The filled price may deviate significantly from the market price. Please try again","result":array(),"ext_code":"","ext_info":null,"time_now":"1659204531.979680")
                    '-2013' => '\\ccxt\\InvalidOrder', // array("ret_code":-2013,"ret_msg":"Order does not exist.","ext_code":null,"ext_info":null,"result":null)
                    '-2015' => '\\ccxt\\AuthenticationError', // Invalid API-key, IP, or permissions for action.
                    '-6017' => '\\ccxt\\BadRequest', // Repayment amount has exceeded the total liability
                    '-6025' => '\\ccxt\\BadRequest', // Amount to borrow cannot be lower than the min. amount to borrow (per transaction)
                    '-6029' => '\\ccxt\\BadRequest', // Amount to borrow has exceeded the user's estimated max amount to borrow
                    '5004' => '\\ccxt\\ExchangeError', // array("retCode":5004,"retMsg":"Server Timeout","result":null,"retExtInfo":array(),"time":1667577060106)
                    '7001' => '\\ccxt\\BadRequest', // array("retCode":7001,"retMsg":"request params type error")
                    '10001' => '\\ccxt\\BadRequest', // parameter error
                    '10002' => '\\ccxt\\InvalidNonce', // request expired, check your timestamp and recv_window
                    '10003' => '\\ccxt\\AuthenticationError', // Invalid apikey
                    '10004' => '\\ccxt\\AuthenticationError', // invalid sign
                    '10005' => '\\ccxt\\PermissionDenied', // permission denied for current apikey
                    '10006' => '\\ccxt\\RateLimitExceeded', // too many requests
                    '10007' => '\\ccxt\\AuthenticationError', // api_key not found in your request parameters
                    '10008' => '\\ccxt\\AuthenticationError', // User had been banned
                    '10009' => '\\ccxt\\AuthenticationError', // IP had been banned
                    '10010' => '\\ccxt\\PermissionDenied', // request ip mismatch
                    '10014' => '\\ccxt\\BadRequest', // Request is duplicate
                    '10016' => '\\ccxt\\ExchangeError', // array("retCode":10016,"retMsg":"System error. Please try again later.")
                    '10017' => '\\ccxt\\BadRequest', // request path not found or request method is invalid
                    '10018' => '\\ccxt\\RateLimitExceeded', // exceed ip rate limit
                    '10020' => '\\ccxt\\PermissionDenied', // array("retCode":10020,"retMsg":"your account is not a unified margin account, please update your account","result":null,"retExtInfo":null,"time":1664783731123)
                    '10027' => '\\ccxt\\PermissionDenied', // Trading Banned
                    '12201' => '\\ccxt\\BadRequest', // array("retCode":12201,"retMsg":"Invalid orderCategory parameter.","result":array(),"retExtInfo":null,"time":1666699391220)
                    '110001' => '\\ccxt\\InvalidOrder', // Order does not exist
                    '110003' => '\\ccxt\\InvalidOrder', // Order price is out of permissible range
                    '110004' => '\\ccxt\\InsufficientFunds', // Insufficient wallet balance
                    '110005' => '\\ccxt\\InvalidOrder', // position status
                    '110006' => '\\ccxt\\InsufficientFunds', // cannot afford estimated position_margin
                    '110007' => '\\ccxt\\InsufficientFunds', // array("retCode":110007,"retMsg":"ab not enough for new order","result":array(),"retExtInfo":array(),"time":1668838414793)
                    '110008' => '\\ccxt\\InvalidOrder', // Order has been finished or canceled
                    '110009' => '\\ccxt\\InvalidOrder', // The number of stop orders exceeds maximum limit allowed
                    '110010' => '\\ccxt\\InvalidOrder', // Order already cancelled
                    '110011' => '\\ccxt\\InvalidOrder', // Any adjustments made will trigger immediate liquidation
                    '110012' => '\\ccxt\\InsufficientFunds', // Available balance not enough
                    '110013' => '\\ccxt\\BadRequest', // Due to risk limit, cannot set leverage
                    '110014' => '\\ccxt\\InsufficientFunds', // Available balance not enough to add margin
                    '110015' => '\\ccxt\\BadRequest', // the position is in cross_margin
                    '110016' => '\\ccxt\\InvalidOrder', // Requested quantity of contracts exceeds risk limit, please adjust your risk limit level before trying again
                    '110017' => '\\ccxt\\InvalidOrder', // Reduce-only rule not satisfied
                    '110018' => '\\ccxt\\BadRequest', // userId illegal
                    '110019' => '\\ccxt\\InvalidOrder', // orderId illegal
                    '110020' => '\\ccxt\\InvalidOrder', // number of active orders greater than 500
                    '110021' => '\\ccxt\\InvalidOrder', // Open Interest exceeded
                    '110022' => '\\ccxt\\InvalidOrder', // qty has been limited, cannot modify the order to add qty
                    '110023' => '\\ccxt\\InvalidOrder', // This contract only supports position reduction operation, please contact customer service for details
                    '110024' => '\\ccxt\\InvalidOrder', // You have an existing position, so position mode cannot be switched
                    '110025' => '\\ccxt\\InvalidOrder', // Position mode is not modified
                    '110026' => '\\ccxt\\InvalidOrder', // Cross/isolated margin mode is not modified
                    '110027' => '\\ccxt\\InvalidOrder', // Margin is not modified
                    '110028' => '\\ccxt\\InvalidOrder', // Open orders exist, so you cannot change position mode
                    '110029' => '\\ccxt\\InvalidOrder', // Hedge mode is not available for this symbol
                    '110030' => '\\ccxt\\InvalidOrder', // Duplicate orderId
                    '110031' => '\\ccxt\\InvalidOrder', // risk limit info does not exists
                    '110032' => '\\ccxt\\InvalidOrder', // Illegal order
                    '110033' => '\\ccxt\\InvalidOrder', // Margin cannot be set without open position
                    '110034' => '\\ccxt\\InvalidOrder', // There is no net position
                    '110035' => '\\ccxt\\InvalidOrder', // Cancel order is not completed before liquidation
                    '110036' => '\\ccxt\\InvalidOrder', // Cross margin mode is not allowed to change leverage
                    '110037' => '\\ccxt\\InvalidOrder', // User setting list does not have this symbol
                    '110038' => '\\ccxt\\InvalidOrder', // Portfolio margin mode is not allowed to change leverage
                    '110039' => '\\ccxt\\InvalidOrder', // Maintain margin rate is too high, which may trigger liquidation
                    '110040' => '\\ccxt\\InvalidOrder', // Order will trigger forced liquidation, please resubmit the order
                    '110041' => '\\ccxt\\InvalidOrder', // Skip liquidation is not allowed when a position or maker order exists
                    '110042' => '\\ccxt\\InvalidOrder', // Pre-delivery status can only reduce positions
                    '110043' => '\\ccxt\\BadRequest', // Set leverage not modified
                    '110044' => '\\ccxt\\InsufficientFunds', // Insufficient available margin
                    '110045' => '\\ccxt\\InsufficientFunds', // Insufficient wallet balance
                    '110046' => '\\ccxt\\BadRequest', // Any adjustments made will trigger immediate liquidation
                    '110047' => '\\ccxt\\BadRequest', // Risk limit cannot be adjusted due to insufficient available margin
                    '110048' => '\\ccxt\\BadRequest', // Risk limit cannot be adjusted as the current/expected position value held exceeds the revised risk limit
                    '110049' => '\\ccxt\\BadRequest', // Tick notes can only be numbers
                    '110050' => '\\ccxt\\BadRequest', // Coin is not in the range of selected
                    '110051' => '\\ccxt\\InsufficientFunds', // The user's available balance cannot cover the lowest price of the current market
                    '110052' => '\\ccxt\\InsufficientFunds', // User's available balance is insufficient to set a price
                    '110053' => '\\ccxt\\InsufficientFunds', // The user's available balance cannot cover the current market price and upper limit price
                    '110054' => '\\ccxt\\InvalidOrder', // This position has at least one take profit link order, so the take profit and stop loss mode cannot be switched
                    '110055' => '\\ccxt\\InvalidOrder', // This position has at least one stop loss link order, so the take profit and stop loss mode cannot be switched
                    '110056' => '\\ccxt\\InvalidOrder', // This position has at least one trailing stop link order, so the take profit and stop loss mode cannot be switched
                    '110057' => '\\ccxt\\InvalidOrder', // Conditional order or limit order contains TP/SL related params
                    '110058' => '\\ccxt\\InvalidOrder', // Insufficient number of remaining position size to set take profit and stop loss
                    '110059' => '\\ccxt\\InvalidOrder', // In the case of partial filled of the open order, it is not allowed to modify the take profit and stop loss settings of the open order
                    '110060' => '\\ccxt\\BadRequest', // Under full TP/SL mode, it is not allowed to modify TP/SL
                    '110061' => '\\ccxt\\BadRequest', // Under partial TP/SL mode, TP/SL set more than 20
                    '110062' => '\\ccxt\\BadRequest', // Institution MMP profile not found.
                    '110063' => '\\ccxt\\ExchangeError', // Settlement in progress! xxx not available for trades.
                    '110064' => '\\ccxt\\InvalidOrder', // The number of contracts modified cannot be less than or equal to the filled quantity
                    '110065' => '\\ccxt\\PermissionDenied', // MMP hasn't yet been enabled for your account. Please contact your BD manager.
                    '110066' => '\\ccxt\\ExchangeError', // No trading is allowed at the current time
                    '110067' => '\\ccxt\\PermissionDenied', // unified account is not support
                    '110068' => '\\ccxt\\PermissionDenied', // Leveraged user trading is not allowed
                    '110069' => '\\ccxt\\PermissionDenied', // Do not allow OTC lending users to trade
                    '110070' => '\\ccxt\\InvalidOrder', // ETP symbols are not allowed to be traded
                    '130006' => '\\ccxt\\InvalidOrder', // array("ret_code":130006,"ret_msg":"The number of contracts exceeds maximum limit allowed => too large","ext_code":"","ext_info":"","result":null,"time_now":"1658397095.099030","rate_limit_status":99,"rate_limit_reset_ms":1658397095097,"rate_limit":100)
                    '130021' => '\\ccxt\\InsufficientFunds', // array("ret_code":130021,"ret_msg":"orderfix price failed for CannotAffordOrderCost.","ext_code":"","ext_info":"","result":null,"time_now":"1644588250.204878","rate_limit_status":98,"rate_limit_reset_ms":1644588250200,"rate_limit":100) |  array("ret_code":130021,"ret_msg":"oc_diff[1707966351], new_oc[1707966351] with ob[....]+AB[....]","ext_code":"","ext_info":"","result":null,"time_now":"1658395300.872766","rate_limit_status":99,"rate_limit_reset_ms":1658395300855,"rate_limit":100) caused issues/9149#issuecomment-1146559498
                    '130074' => '\\ccxt\\InvalidOrder', // array("ret_code":130074,"ret_msg":"expect Rising, but trigger_price[190000000] \u003c= current[211280000]??LastPrice","ext_code":"","ext_info":"","result":null,"time_now":"1655386638.067076","rate_limit_status":97,"rate_limit_reset_ms":1655386638065,"rate_limit":100)
                    '131001' => '\\ccxt\\InsufficientFunds', // array("retCode":131001,"retMsg":"the available balance is not sufficient to cover the handling fee","result":array(),"retExtInfo":array(),"time":1666892821245)
                    '140003' => '\\ccxt\\InvalidOrder', // Order price is out of permissible range
                    '140004' => '\\ccxt\\InsufficientFunds', // Insufficient wallet balance
                    '140005' => '\\ccxt\\InvalidOrder', // position status
                    '140006' => '\\ccxt\\InsufficientFunds', // cannot afford estimated position_margin
                    '140007' => '\\ccxt\\InsufficientFunds', // Insufficient available balance
                    '140008' => '\\ccxt\\InvalidOrder', // Order has been finished or canceled
                    '140009' => '\\ccxt\\InvalidOrder', // The number of stop orders exceeds maximum limit allowed
                    '140010' => '\\ccxt\\InvalidOrder', // Order already cancelled
                    '140011' => '\\ccxt\\InvalidOrder', // Any adjustments made will trigger immediate liquidation
                    '140012' => '\\ccxt\\InsufficientFunds', // Available balance not enough
                    '140013' => '\\ccxt\\BadRequest', // Due to risk limit, cannot set leverage
                    '140014' => '\\ccxt\\InsufficientFunds', // Available balance not enough to add margin
                    '140015' => '\\ccxt\\InvalidOrder', // the position is in cross_margin
                    '140016' => '\\ccxt\\InvalidOrder', // Requested quantity of contracts exceeds risk limit, please adjust your risk limit level before trying again
                    '140017' => '\\ccxt\\InvalidOrder', // Reduce-only rule not satisfied
                    '140018' => '\\ccxt\\BadRequest', // userId illegal
                    '140019' => '\\ccxt\\InvalidOrder', // orderId illegal
                    '140020' => '\\ccxt\\InvalidOrder', // number of active orders greater than 500
                    '140021' => '\\ccxt\\InvalidOrder', // Open Interest exceeded
                    '140022' => '\\ccxt\\InvalidOrder', // qty has been limited, cannot modify the order to add qty
                    '140023' => '\\ccxt\\InvalidOrder', // This contract only supports position reduction operation, please contact customer service for details
                    '140024' => '\\ccxt\\BadRequest', // You have an existing position, so position mode cannot be switched
                    '140025' => '\\ccxt\\BadRequest', // Position mode is not modified
                    '140026' => '\\ccxt\\BadRequest', // Cross/isolated margin mode is not modified
                    '140027' => '\\ccxt\\BadRequest', // Margin is not modified
                    '140028' => '\\ccxt\\InvalidOrder', // Open orders exist, so you cannot change position mode
                    '140029' => '\\ccxt\\BadRequest', // Hedge mode is not available for this symbol
                    '140030' => '\\ccxt\\InvalidOrder', // Duplicate orderId
                    '140031' => '\\ccxt\\BadRequest', // risk limit info does not exists
                    '140032' => '\\ccxt\\InvalidOrder', // Illegal order
                    '140033' => '\\ccxt\\InvalidOrder', // Margin cannot be set without open position
                    '140034' => '\\ccxt\\InvalidOrder', // There is no net position
                    '140035' => '\\ccxt\\InvalidOrder', // Cancel order is not completed before liquidation
                    '140036' => '\\ccxt\\BadRequest', // Cross margin mode is not allowed to change leverage
                    '140037' => '\\ccxt\\InvalidOrder', // User setting list does not have this symbol
                    '140038' => '\\ccxt\\BadRequest', // Portfolio margin mode is not allowed to change leverage
                    '140039' => '\\ccxt\\BadRequest', // Maintain margin rate is too high, which may trigger liquidation
                    '140040' => '\\ccxt\\InvalidOrder', // Order will trigger forced liquidation, please resubmit the order
                    '140041' => '\\ccxt\\InvalidOrder', // Skip liquidation is not allowed when a position or maker order exists
                    '140042' => '\\ccxt\\InvalidOrder', // Pre-delivery status can only reduce positions
                    '140043' => '\\ccxt\\BadRequest', // Set leverage not modified
                    '140044' => '\\ccxt\\InsufficientFunds', // Insufficient available margin
                    '140045' => '\\ccxt\\InsufficientFunds', // Insufficient wallet balance
                    '140046' => '\\ccxt\\BadRequest', // Any adjustments made will trigger immediate liquidation
                    '140047' => '\\ccxt\\BadRequest', // Risk limit cannot be adjusted due to insufficient available margin
                    '140048' => '\\ccxt\\BadRequest', // Risk limit cannot be adjusted as the current/expected position value held exceeds the revised risk limit
                    '140049' => '\\ccxt\\BadRequest', // Tick notes can only be numbers
                    '140050' => '\\ccxt\\InvalidOrder', // Coin is not in the range of selected
                    '140051' => '\\ccxt\\InsufficientFunds', // The user's available balance cannot cover the lowest price of the current market
                    '140052' => '\\ccxt\\InsufficientFunds', // User's available balance is insufficient to set a price
                    '140053' => '\\ccxt\\InsufficientFunds', // The user's available balance cannot cover the current market price and upper limit price
                    '140054' => '\\ccxt\\InvalidOrder', // This position has at least one take profit link order, so the take profit and stop loss mode cannot be switched
                    '140055' => '\\ccxt\\InvalidOrder', // This position has at least one stop loss link order, so the take profit and stop loss mode cannot be switched
                    '140056' => '\\ccxt\\InvalidOrder', // This position has at least one trailing stop link order, so the take profit and stop loss mode cannot be switched
                    '140057' => '\\ccxt\\InvalidOrder', // Conditional order or limit order contains TP/SL related params
                    '140058' => '\\ccxt\\InvalidOrder', // Insufficient number of remaining position size to set take profit and stop loss
                    '140059' => '\\ccxt\\InvalidOrder', // In the case of partial filled of the open order, it is not allowed to modify the take profit and stop loss settings of the open order
                    '140060' => '\\ccxt\\BadRequest', // Under full TP/SL mode, it is not allowed to modify TP/SL
                    '140061' => '\\ccxt\\BadRequest', // Under partial TP/SL mode, TP/SL set more than 20
                    '140062' => '\\ccxt\\BadRequest', // Institution MMP profile not found.
                    '140063' => '\\ccxt\\ExchangeError', // Settlement in progress! xxx not available for trades.
                    '140064' => '\\ccxt\\InvalidOrder', // The number of contracts modified cannot be less than or equal to the filled quantity
                    '140065' => '\\ccxt\\PermissionDenied', // MMP hasn't yet been enabled for your account. Please contact your BD manager.
                    '140066' => '\\ccxt\\ExchangeError', // No trading is allowed at the current time
                    '140067' => '\\ccxt\\PermissionDenied', // unified account is not support
                    '140068' => '\\ccxt\\PermissionDenied', // Leveraged user trading is not allowed
                    '140069' => '\\ccxt\\PermissionDenied', // Do not allow OTC lending users to trade
                    '140070' => '\\ccxt\\InvalidOrder', // ETP symbols are not allowed to be traded
                    '20001' => '\\ccxt\\OrderNotFound', // Order not exists
                    '20003' => '\\ccxt\\InvalidOrder', // missing parameter side
                    '20004' => '\\ccxt\\InvalidOrder', // invalid parameter side
                    '20005' => '\\ccxt\\InvalidOrder', // missing parameter symbol
                    '20006' => '\\ccxt\\InvalidOrder', // invalid parameter symbol
                    '20007' => '\\ccxt\\InvalidOrder', // missing parameter order_type
                    '20008' => '\\ccxt\\InvalidOrder', // invalid parameter order_type
                    '20009' => '\\ccxt\\InvalidOrder', // missing parameter qty
                    '20010' => '\\ccxt\\InvalidOrder', // qty must be greater than 0
                    '20011' => '\\ccxt\\InvalidOrder', // qty must be an integer
                    '20012' => '\\ccxt\\InvalidOrder', // qty must be greater than zero and less than 1 million
                    '20013' => '\\ccxt\\InvalidOrder', // missing parameter price
                    '20014' => '\\ccxt\\InvalidOrder', // price must be greater than 0
                    '20015' => '\\ccxt\\InvalidOrder', // missing parameter time_in_force
                    '20016' => '\\ccxt\\InvalidOrder', // invalid value for parameter time_in_force
                    '20017' => '\\ccxt\\InvalidOrder', // missing parameter order_id
                    '20018' => '\\ccxt\\InvalidOrder', // invalid date format
                    '20019' => '\\ccxt\\InvalidOrder', // missing parameter stop_px
                    '20020' => '\\ccxt\\InvalidOrder', // missing parameter base_price
                    '20021' => '\\ccxt\\InvalidOrder', // missing parameter stop_order_id
                    '20022' => '\\ccxt\\BadRequest', // missing parameter leverage
                    '20023' => '\\ccxt\\BadRequest', // leverage must be a number
                    '20031' => '\\ccxt\\BadRequest', // leverage must be greater than zero
                    '20070' => '\\ccxt\\BadRequest', // missing parameter margin
                    '20071' => '\\ccxt\\BadRequest', // margin must be greater than zero
                    '20084' => '\\ccxt\\BadRequest', // order_id or order_link_id is required
                    '30001' => '\\ccxt\\BadRequest', // order_link_id is repeated
                    '30003' => '\\ccxt\\InvalidOrder', // qty must be more than the minimum allowed
                    '30004' => '\\ccxt\\InvalidOrder', // qty must be less than the maximum allowed
                    '30005' => '\\ccxt\\InvalidOrder', // price exceeds maximum allowed
                    '30007' => '\\ccxt\\InvalidOrder', // price exceeds minimum allowed
                    '30008' => '\\ccxt\\InvalidOrder', // invalid order_type
                    '30009' => '\\ccxt\\ExchangeError', // no position found
                    '30010' => '\\ccxt\\InsufficientFunds', // insufficient wallet balance
                    '30011' => '\\ccxt\\PermissionDenied', // operation not allowed as position is undergoing liquidation
                    '30012' => '\\ccxt\\PermissionDenied', // operation not allowed as position is undergoing ADL
                    '30013' => '\\ccxt\\PermissionDenied', // position is in liq or adl status
                    '30014' => '\\ccxt\\InvalidOrder', // invalid closing order, qty should not greater than size
                    '30015' => '\\ccxt\\InvalidOrder', // invalid closing order, side should be opposite
                    '30016' => '\\ccxt\\ExchangeError', // TS and SL must be cancelled first while closing position
                    '30017' => '\\ccxt\\InvalidOrder', // estimated fill price cannot be lower than current Buy liq_price
                    '30018' => '\\ccxt\\InvalidOrder', // estimated fill price cannot be higher than current Sell liq_price
                    '30019' => '\\ccxt\\InvalidOrder', // cannot attach TP/SL params for non-zero position when placing non-opening position order
                    '30020' => '\\ccxt\\InvalidOrder', // position already has TP/SL params
                    '30021' => '\\ccxt\\InvalidOrder', // cannot afford estimated position_margin
                    '30022' => '\\ccxt\\InvalidOrder', // estimated buy liq_price cannot be higher than current mark_price
                    '30023' => '\\ccxt\\InvalidOrder', // estimated sell liq_price cannot be lower than current mark_price
                    '30024' => '\\ccxt\\InvalidOrder', // cannot set TP/SL/TS for zero-position
                    '30025' => '\\ccxt\\InvalidOrder', // trigger price should bigger than 10% of last price
                    '30026' => '\\ccxt\\InvalidOrder', // price too high
                    '30027' => '\\ccxt\\InvalidOrder', // price set for Take profit should be higher than Last Traded Price
                    '30028' => '\\ccxt\\InvalidOrder', // price set for Stop loss should be between Liquidation price and Last Traded Price
                    '30029' => '\\ccxt\\InvalidOrder', // price set for Stop loss should be between Last Traded Price and Liquidation price
                    '30030' => '\\ccxt\\InvalidOrder', // price set for Take profit should be lower than Last Traded Price
                    '30031' => '\\ccxt\\InsufficientFunds', // insufficient available balance for order cost
                    '30032' => '\\ccxt\\InvalidOrder', // order has been filled or cancelled
                    '30033' => '\\ccxt\\RateLimitExceeded', // The number of stop orders exceeds maximum limit allowed
                    '30034' => '\\ccxt\\OrderNotFound', // no order found
                    '30035' => '\\ccxt\\RateLimitExceeded', // too fast to cancel
                    '30036' => '\\ccxt\\ExchangeError', // the expected position value after order execution exceeds the current risk limit
                    '30037' => '\\ccxt\\InvalidOrder', // order already cancelled
                    '30041' => '\\ccxt\\ExchangeError', // no position found
                    '30042' => '\\ccxt\\InsufficientFunds', // insufficient wallet balance
                    '30043' => '\\ccxt\\InvalidOrder', // operation not allowed as position is undergoing liquidation
                    '30044' => '\\ccxt\\InvalidOrder', // operation not allowed as position is undergoing AD
                    '30045' => '\\ccxt\\InvalidOrder', // operation not allowed as position is not normal status
                    '30049' => '\\ccxt\\InsufficientFunds', // insufficient available balance
                    '30050' => '\\ccxt\\ExchangeError', // any adjustments made will trigger immediate liquidation
                    '30051' => '\\ccxt\\ExchangeError', // due to risk limit, cannot adjust leverage
                    '30052' => '\\ccxt\\ExchangeError', // leverage can not less than 1
                    '30054' => '\\ccxt\\ExchangeError', // position margin is invalid
                    '30057' => '\\ccxt\\ExchangeError', // requested quantity of contracts exceeds risk limit
                    '30063' => '\\ccxt\\ExchangeError', // reduce-only rule not satisfied
                    '30067' => '\\ccxt\\InsufficientFunds', // insufficient available balance
                    '30068' => '\\ccxt\\ExchangeError', // exit value must be positive
                    '30074' => '\\ccxt\\InvalidOrder', // can't create the stop order, because you expect the order will be triggered when the LastPrice(or IndexPrice、 MarkPrice, determined by trigger_by) is raising to stop_px, but the LastPrice(or IndexPrice、 MarkPrice) is already equal to or greater than stop_px, please adjust base_price or stop_px
                    '30075' => '\\ccxt\\InvalidOrder', // can't create the stop order, because you expect the order will be triggered when the LastPrice(or IndexPrice、 MarkPrice, determined by trigger_by) is falling to stop_px, but the LastPrice(or IndexPrice、 MarkPrice) is already equal to or less than stop_px, please adjust base_price or stop_px
                    '30078' => '\\ccxt\\ExchangeError', // array("ret_code":30078,"ret_msg":"","ext_code":"","ext_info":"","result":null,"time_now":"1644853040.916000","rate_limit_status":73,"rate_limit_reset_ms":1644853040912,"rate_limit":75)
                    // '30084' => '\\ccxt\\BadRequest', // Isolated not modified, see handleErrors below
                    '33004' => '\\ccxt\\AuthenticationError', // apikey already expired
                    '34026' => '\\ccxt\\ExchangeError', // the limit is no change
                    '34036' => '\\ccxt\\BadRequest', // array("ret_code":34036,"ret_msg":"leverage not modified","ext_code":"","ext_info":"","result":null,"time_now":"1652376449.258918","rate_limit_status":74,"rate_limit_reset_ms":1652376449255,"rate_limit":75)
                    '35015' => '\\ccxt\\BadRequest', // array("ret_code":35015,"ret_msg":"Qty not in range","ext_code":"","ext_info":"","result":null,"time_now":"1652277215.821362","rate_limit_status":99,"rate_limit_reset_ms":1652277215819,"rate_limit":100)
                    '3100116' => '\\ccxt\\BadRequest', // array("retCode":3100116,"retMsg":"Order quantity below the lower limit 0.01.","result":null,"retExtMap":array("key0":"0.01"))
                    '3100198' => '\\ccxt\\BadRequest', // array("retCode":3100198,"retMsg":"orderLinkId can not be empty.","result":null,"retExtMap":array())
                    '3200300' => '\\ccxt\\InsufficientFunds', // array("retCode":3200300,"retMsg":"Insufficient margin balance.","result":null,"retExtMap":array())
                ),
                'broad' => array(
                    'unknown orderInfo' => '\\ccxt\\OrderNotFound', // array("ret_code":-1,"ret_msg":"unknown orderInfo","ext_code":"","ext_info":"","result":null,"time_now":"1584030414.005545","rate_limit_status":99,"rate_limit_reset_ms":1584030414003,"rate_limit":100)
                    'invalid api_key' => '\\ccxt\\AuthenticationError', // array("ret_code":10003,"ret_msg":"invalid api_key","ext_code":"","ext_info":"","result":null,"time_now":"1599547085.415797")
                    // the below two issues are caused as described => issues/9149#issuecomment-1146559498, when response is such =>  array("ret_code":130021,"ret_msg":"oc_diff[1707966351], new_oc[1707966351] with ob[....]+AB[....]","ext_code":"","ext_info":"","result":null,"time_now":"1658395300.872766","rate_limit_status":99,"rate_limit_reset_ms":1658395300855,"rate_limit":100)
                    'oc_diff' => '\\ccxt\\InsufficientFunds',
                    'new_oc' => '\\ccxt\\InsufficientFunds',
                    'openapi sign params error!' => '\\ccxt\\AuthenticationError', // array("retCode":10001,"retMsg":"empty value => apiTimestamparray() apiKeyarray() apiSignature[xxxxxxxxxxxxxxxxxxxxxxx] => openapi sign params error!","result":null,"retExtInfo":null,"time":1664789597123)
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'options' => array(
                'createMarketBuyOrderRequiresPrice' => true,
                'createUnifiedMarginAccount' => false,
                'defaultType' => 'swap',  // 'swap', 'future', 'option', 'spot'
                'defaultSubType' => 'linear',  // 'linear', 'inverse'
                'defaultSettle' => 'USDT', // USDC for USDC settled markets
                'code' => 'BTC',
                'recvWindow' => 5 * 1000, // 5 sec default
                'timeDifference' => 0, // the difference between system clock and exchange server clock
                'adjustForTimeDifference' => false, // controls the adjustment logic upon instantiation
                'brokerId' => 'CCXT',
                'accountsByType' => array(
                    'spot' => 'SPOT',
                    'margin' => 'SPOT',
                    'future' => 'CONTRACT',
                    'swap' => 'CONTRACT',
                    'option' => 'OPTION',
                    'investment' => 'INVESTMENT',
                    'unified' => 'UNIFIED',
                    'funding' => 'FUND',
                ),
                'accountsById' => array(
                    'SPOT' => 'spot',
                    'MARGIN' => 'spot',
                    'CONTRACT' => 'contract',
                    'OPTION' => 'option',
                    'INVESTMENT' => 'investment',
                    'UNIFIED' => 'unified',
                ),
                'networks' => array(
                    'ERC20' => 'ETH',
                    'TRC20' => 'TRX',
                    'BEP20' => 'BSC',
                    'OMNI' => 'OMNI',
                    'SPL' => 'SOL',
                ),
                'networksById' => array(
                    'ETH' => 'ERC20',
                    'TRX' => 'TRC20',
                    'BSC' => 'BEP20',
                    'OMNI' => 'OMNI',
                    'SPL' => 'SOL',
                ),
                'defaultNetwork' => 'ERC20',
                'defaultNetworks' => array(
                    'USDT' => 'TRC20',
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'feeSide' => 'get',
                    'tierBased' => true,
                    'percentage' => true,
                    'taker' => 0.00075,
                    'maker' => 0.0001,
                ),
                'funding' => array(
                    'tierBased' => false,
                    'percentage' => false,
                    'withdraw' => array(),
                    'deposit' => array(),
                ),
            ),
        ));
    }

    public function nonce() {
        return $this->milliseconds() - $this->options['timeDifference'];
    }

    public function is_unified_margin_enabled($params = array ()) {
        //  The API key of user id must own one of permissions will be allowed to call following API endpoints.
        // SUB UID => "Account Transfer"
        // MASTER UID => "Account Transfer", "Subaccount Transfer", "Withdrawal"
        $enableUnifiedMargin = $this->safe_value($this->options, 'enableUnifiedMargin');
        if ($enableUnifiedMargin === null) {
            $response = $this->privateGetUserV3PrivateQueryApi ($params);
            //
            //     {
            //         "retCode":0,
            //         "retMsg":"OK",
            //         "result":array(
            //             "id":"88888888",
            //             "note":"ccxt-moon",
            //             "apiKey":"8s8c808v8u8",
            //             "readOnly":0,
            //             "secret":"",
            //             "permissions":array(
            //                 "ContractTrade":[""],
            //                 "Spot":[""],
            //                 "Wallet":[""],
            //                 "Options":[""],
            //                 "Derivatives":[""],
            //                 "CopyTrading":[""],
            //                 "BlockTrade":array(),
            //                 "Exchange":[""],
            //                 "NFT":[""]
            //             ),
            //             "ips":[""],
            //             "type":1,
            //             "deadlineDay":27,
            //             "expiredAt":"",
            //             "createdAt":"",
            //             "unified":1
            //         ),
            //         "retExtInfo":null,
            //         "time":1669735171649
            //     }
            //
            $result = $this->safe_value($response, 'result', array());
            $this->options['enableUnifiedMargin'] = $this->safe_integer($result, 'unified') === 1;
        }
        return $this->options['enableUnifiedMargin'];
    }

    public function upgrade_unified_account($params = array ()) {
        $createUnifiedMarginAccount = $this->safe_value($this->options, 'createUnifiedMarginAccount');
        if (!$createUnifiedMarginAccount) {
            throw new NotSupported($this->id . ' upgradeUnifiedAccount() warning this method can only be called once, it is not reverseable and you will be stuck with a unified margin account, you also need at least 5000 USDT in your bybit account to do $this-> If you want to disable this warning set exchange.options["createUnifiedMarginAccount"]=true.');
        }
        return $this->privatePostUnifiedV3PrivateAccountUpgradeUnifiedAccount ($params);
    }

    public function fetch_time($params = array ()) {
        /**
         * fetches the current integer timestamp in milliseconds from the exchange server
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {int} the current integer timestamp in milliseconds from the exchange server
         */
        $response = $this->publicGetV3PublicTime ($params);
        //
        //    {
        //         "retCode" => "0",
        //         "retMsg" => "OK",
        //         "result" => array(
        //             "timeSecond" => "1666879482",
        //             "timeNano" => "1666879482792685914"
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => "1666879482792"
        //     }
        //
        return $this->safe_integer($response, 'time');
    }

    public function fetch_currencies($params = array ()) {
        /**
         * fetches all available currencies on an exchange
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} an associative dictionary of currencies
         */
        if (!$this->check_required_credentials(false)) {
            return null;
        }
        $response = $this->privateGetAssetV3PrivateCoinInfoQuery ($params);
        //
        //    {
        //        "retCode" => "0",
        //        "retMsg" => "OK",
        //        "result" => {
        //            "rows" => array(
        //                array(
        //                    "name" => "MATIC",
        //                    "coin" => "MATIC",
        //                    "remainAmount" => "1652850",
        //                    "chains" => array(
        //                        array(
        //                            "chainType" => "MATIC",
        //                            "confirmation" => "128",
        //                            "withdrawFee" => "0.1",
        //                            "depositMin" => "0",
        //                            "withdrawMin" => "0.1",
        //                            "chain" => "MATIC",
        //                            "chainDeposit" => "1",
        //                            "chainWithdraw" => "1",
        //                            "minAccuracy" => "8"
        //                        ),
        //                        array(
        //                            "chainType" => "ERC20",
        //                            "confirmation" => "12",
        //                            "withdrawFee" => "10",
        //                            "depositMin" => "0",
        //                            "withdrawMin" => "20",
        //                            "chain" => "ETH",
        //                            "chainDeposit" => "1",
        //                            "chainWithdraw" => "1",
        //                            "minAccuracy" => "8"
        //                        ),
        //                        array(
        //                            "chainType" => "BSC (BEP20)",
        //                            "confirmation" => "15",
        //                            "withdrawFee" => "1",
        //                            "depositMin" => "0",
        //                            "withdrawMin" => "1",
        //                            "chain" => "BSC",
        //                            "chainDeposit" => "1",
        //                            "chainWithdraw" => "1",
        //                            "minAccuracy" => "8"
        //                        }
        //                    )
        //                ),
        //            )
        //        ),
        //        "retExtInfo" => null,
        //        "time" => "1666728888775"
        //    }
        //
        $data = $this->safe_value($response, 'result', array());
        $rows = $this->safe_value($data, 'rows', array());
        $result = array();
        for ($i = 0; $i < count($rows); $i++) {
            $currency = $rows[$i];
            $currencyId = $this->safe_string($currency, 'coin');
            $code = $this->safe_currency_code($currencyId);
            $name = $this->safe_string($currency, 'name');
            $chains = $this->safe_value($currency, 'chains', array());
            $networks = array();
            $minPrecision = null;
            for ($j = 0; $j < count($chains); $j++) {
                $chain = $chains[$j];
                $networkId = $this->safe_string($chain, 'chain');
                $networkCode = $this->network_id_to_code($networkId);
                $precision = $this->parse_number($this->parse_precision($this->safe_string($chain, 'minAccuracy')));
                $minPrecision = ($minPrecision === null) ? $precision : min ($minPrecision, $precision);
                $depositAllowed = $this->safe_integer($chain, 'chainDeposit') === 1;
                $withdrawAllowed = $this->safe_integer($chain, 'chainWithdraw') === 1;
                $networks[$networkCode] = array(
                    'info' => $chain,
                    'id' => $networkId,
                    'network' => $networkCode,
                    'active' => null,
                    'deposit' => $depositAllowed,
                    'withdraw' => $withdrawAllowed,
                    'fee' => $this->safe_number($chain, 'withdrawFee'),
                    'precision' => $precision,
                    'limits' => array(
                        'withdraw' => array(
                            'min' => $this->safe_number($chain, 'withdrawMin'),
                            'max' => null,
                        ),
                        'deposit' => array(
                            'min' => $this->safe_number($chain, 'depositMin'),
                            'max' => null,
                        ),
                    ),
                );
            }
            $result[$code] = array(
                'info' => $currency,
                'code' => $code,
                'id' => $currencyId,
                'name' => $name,
                'active' => null,
                'deposit' => null,
                'withdraw' => null,
                'fee' => null,
                'precision' => $minPrecision,
                'limits' => array(
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
                'networks' => $networks,
            );
        }
        return $result;
    }

    public function fetch_markets($params = array ()) {
        /**
         * retrieves data on all $markets for bybit
         * @param {array} $params extra parameters specific to the exchange api endpoint
         * @return {[array]} an array of objects representing market data
         */
        if ($this->options['adjustForTimeDifference']) {
            $this->load_time_difference();
        }
        list($type, $query) = $this->handle_market_type_and_params('fetchMarkets', null, $params);
        if ($type === 'spot') {
            // spot and swap ids are equal
            // so they can't be loaded together
            return $this->fetch_spot_markets($query);
        }
        $promises = array(
            $this->fetch_derivatives_markets(array( 'category' => 'linear' )),
            $this->fetch_derivatives_markets(array( 'category' => 'inverse' )),
            $this->fetch_derivatives_markets(array( 'category' => 'option' )),
        );
        $linearMarkets = $promises[0];
        $inverseMarkets = $promises[1];
        $optionMarkets = $promises[2];
        $markets = $linearMarkets;
        $markets = $this->array_concat($markets, $inverseMarkets);
        return $this->array_concat($markets, $optionMarkets);
    }

    public function fetch_spot_markets($params) {
        $response = $this->publicGetSpotV3PublicSymbols ($params);
        //
        //    {
        //        "retCode" => "0",
        //        "retMsg" => "OK",
        //        "result" => array(
        //            "list" => array(
        //                array(
        //                    "name" => "BTCUSDT",
        //                    "alias" => "BTCUSDT",
        //                    "baseCoin" => "BTC",
        //                    "quoteCoin" => "USDT",
        //                    "basePrecision" => "0.000001",
        //                    "quotePrecision" => "0.00000001",
        //                    "minTradeQty" => "0.00004",
        //                    "minTradeAmt" => "1",
        //                    "maxTradeQty" => "46.13",
        //                    "maxTradeAmt" => "938901",
        //                    "minPricePrecision" => "0.01",
        //                    "category" => "1",
        //                    "showStatus" => "1",
        //                    "innovation" => "0"
        //                ),
        //            )
        //        ),
        //        "retExtMap" => array(),
        //        "retExtInfo" => null,
        //        "time" => "1666729450457"
        //    }
        //
        $responseResult = $this->safe_value($response, 'result', array());
        $markets = $this->safe_value($responseResult, 'list', array());
        $result = array();
        $takerFee = $this->parse_number('0.001');
        $makerFee = $this->parse_number('0.001');
        for ($i = 0; $i < count($markets); $i++) {
            $market = $markets[$i];
            $id = $this->safe_string($market, 'name');
            $baseId = $this->safe_string($market, 'baseCoin');
            $quoteId = $this->safe_string($market, 'quoteCoin');
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $symbol = $base . '/' . $quote;
            $active = $this->safe_integer($market, 'showStatus') === 1;
            $quotePrecision = $this->safe_number($market, 'quotePrecision');
            $result[] = array(
                'id' => $id,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'settle' => null,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'settleId' => null,
                'type' => 'spot',
                'spot' => true,
                'margin' => null,
                'swap' => false,
                'future' => false,
                'option' => false,
                'active' => $active,
                'contract' => false,
                'linear' => null,
                'inverse' => null,
                'taker' => $takerFee,
                'maker' => $makerFee,
                'contractSize' => null,
                'expiry' => null,
                'expiryDatetime' => null,
                'strike' => null,
                'optionType' => null,
                'precision' => array(
                    'amount' => $this->safe_number($market, 'basePrecision'),
                    'price' => $this->safe_number($market, 'minPricePrecision', $quotePrecision),
                ),
                'limits' => array(
                    'leverage' => array(
                        'min' => $this->parse_number('1'),
                        'max' => null,
                    ),
                    'amount' => array(
                        'min' => $this->safe_number($market, 'minTradeQty'),
                        'max' => $this->safe_number($market, 'maxTradeQty'),
                    ),
                    'price' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => $this->safe_number($market, 'minTradeAmt'),
                        'max' => $this->safe_number($market, 'maxTradeAmt'),
                    ),
                ),
                'info' => $market,
            );
        }
        return $result;
    }

    public function fetch_derivatives_markets($params) {
        $params['limit'] = 1000; // minimize number of requests
        $response = $this->publicGetDerivativesV3PublicInstrumentsInfo ($params);
        $data = $this->safe_value($response, 'result', array());
        $markets = $this->safe_value_2($data, 'list', 'dataList', array());
        $paginationCursor = $this->safe_string($data, 'cursor');
        if ($paginationCursor !== null) {
            while ($paginationCursor !== null) {
                $params['cursor'] = $paginationCursor;
                $response = $this->publicGetDerivativesV3PublicInstrumentsInfo ($params);
                $data = $this->safe_value($response, 'result', array());
                $rawMarkets = $this->safe_value_2($data, 'list', 'dataList', array());
                $rawMarketsLength = count($rawMarkets);
                if ($rawMarketsLength === 0) {
                    break;
                }
                $markets = $this->array_concat($rawMarkets, $markets);
                $paginationCursor = $this->safe_string($data, 'nextPageCursor');
            }
        }
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => {
        //             "category" => "linear",
        //             "list" => array(
        //                 {
        //                     "symbol" => "BTCUSDT",
        //                     "contractType" => "LinearPerpetual",
        //                     "status" => "Trading",
        //                     "baseCoin" => "BTC",
        //                     "quoteCoin" => "USDT",
        //                     "launchTime" => "1584230400000",
        //                     "deliveryTime" => "0",
        //                     "deliveryFeeRate" => "",
        //                     "priceScale" => "2",
        //                     "leverageFilter" => array(
        //                         "minLeverage" => "1",
        //                         "maxLeverage" => "100",
        //                         "leverageStep" => "0.01"
        //                     ),
        //                     "priceFilter" => array(
        //                         "minPrice" => "0.50",
        //                         "maxPrice" => "999999.00",
        //                         "tickSize" => "0.50"
        //                     ),
        //                     "lotSizeFilter" => array(
        //                         "maxTradingQty" => "420.000",
        //                         "minTradingQty" => "0.001",
        //                         "qtyStep" => "0.001"
        //                     }
        //                 }
        //             ),
        //             "nextPageCursor" => ""
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => 1667533491917
        //     }
        //
        // $option $response
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "success",
        //         "result" => {
        //             "resultTotalSize" => 1,
        //             "cursor" => "",
        //             "dataList" => array(
        //                 {
        //                     "category" => "option",
        //                     "symbol" => "BTC-30SEP22-35000-P",
        //                     "status" => "ONLINE",
        //                     "baseCoin" => "BTC",
        //                     "quoteCoin" => "USD",
        //                     "settleCoin" => "USDC",
        //                     "optionsType" => "Put",
        //                     "launchTime" => "1649923200000",
        //                     "deliveryTime" => "1664524800000",
        //                     "deliveryFeeRate" => "0.00015",
        //                     "priceFilter" => array(
        //                         "minPrice" => "5",
        //                         "maxPrice" => "10000000",
        //                         "tickSize" => "5"
        //                     ),
        //                     "lotSizeFilter" => array(
        //                         "maxOrderQty" => "200",
        //                         "minOrderQty" => "0.01",
        //                         "qtyStep" => "0.01"
        //                     }
        //                 }
        //             )
        //         ),
        //         "time" => 1657777124431
        //     }
        //
        // $inverse $response
        //
        //     {
        //         "symbol" => "ETHUSDZ22",
        //         "contractType" => "InverseFutures",
        //         "status" => "Trading",
        //         "baseCoin" => "ETH",
        //         "quoteCoin" => "USD",
        //         "launchTime" => "1654848000000",
        //         "deliveryTime" => "1672387200000",
        //         "deliveryFeeRate" => "",
        //         "priceScale" => "2",
        //         "leverageFilter" => array(
        //             "minLeverage" => "1",
        //             "maxLeverage" => "50",
        //             "leverageStep" => "0.01"
        //         ),
        //         "priceFilter" => array(
        //             "minPrice" => "0.05",
        //             "maxPrice" => "99999.90",
        //             "tickSize" => "0.05"
        //         ),
        //         "lotSizeFilter" => {
        //             "maxTradingQty" => "1000000",
        //             "minTradingQty" => "1",
        //             "qtyStep" => "1"
        //         }
        //     }
        //
        $result = array();
        $category = $this->safe_string($data, 'category');
        for ($i = 0; $i < count($markets); $i++) {
            $market = $markets[$i];
            if ($category === null) {
                $category = $this->safe_string($market, 'category');
            }
            $linear = ($category === 'linear');
            $inverse = ($category === 'inverse');
            $contractType = $this->safe_string($market, 'contractType');
            $inverseFutures = ($contractType === 'InverseFutures');
            $linearPerpetual = ($contractType === 'LinearPerpetual');
            $inversePerpetual = ($contractType === 'InversePerpetual');
            $id = $this->safe_string($market, 'symbol');
            $baseId = $this->safe_string($market, 'baseCoin');
            $quoteId = $this->safe_string($market, 'quoteCoin');
            $defaultSettledId = $linear ? $quoteId : $baseId;
            $settleId = $this->safe_string($market, 'settleCoin', $defaultSettledId);
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $settle = null;
            if ($linearPerpetual && ($settleId === 'USD')) {
                $settle = 'USDC';
            } else {
                $settle = $this->safe_currency_code($settleId);
            }
            $symbol = $base . '/' . $quote;
            $lotSizeFilter = $this->safe_value($market, 'lotSizeFilter', array());
            $priceFilter = $this->safe_value($market, 'priceFilter', array());
            $leverage = $this->safe_value($market, 'leverageFilter', array());
            $status = $this->safe_string($market, 'status');
            $active = null;
            if ($status !== null) {
                $active = ($status === 'Trading');
            }
            $swap = $linearPerpetual || $inversePerpetual;
            $future = $inverseFutures;
            $option = ($category === 'option');
            $type = null;
            if ($swap) {
                $type = 'swap';
            } elseif ($future) {
                $type = 'future';
            } elseif ($option) {
                $type = 'option';
            }
            $expiry = $this->omit_zero($this->safe_string($market, 'deliveryTime'));
            if ($expiry !== null) {
                $expiry = intval($expiry);
            }
            $expiryDatetime = $this->iso8601($expiry);
            $strike = null;
            $optionType = null;
            $symbol = $symbol . ':' . $settle;
            if ($expiry !== null) {
                $symbol = $symbol . '-' . $this->yymmdd($expiry);
                if ($option) {
                    $splitId = explode('-', $id);
                    $strike = $this->safe_string($splitId, 2);
                    $optionLetter = $this->safe_string($splitId, 3);
                    $symbol = $symbol . '-' . $strike . '-' . $optionLetter;
                    if ($optionLetter === 'P') {
                        $optionType = 'put';
                    } elseif ($optionLetter === 'C') {
                        $optionType = 'call';
                    }
                }
            }
            $contractSize = $inverse ? $this->safe_number_2($lotSizeFilter, 'minTradingQty', 'minOrderQty') : $this->parse_number('1');
            $result[] = array(
                'id' => $id,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'settle' => $settle,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'settleId' => $settleId,
                'type' => $type,
                'spot' => false,
                'margin' => null,
                'swap' => $swap,
                'future' => $future,
                'option' => $option,
                'active' => $active,
                'contract' => true,
                'linear' => $linear,
                'inverse' => $inverse,
                'taker' => $this->safe_number($market, 'taker_fee'),
                'maker' => $this->safe_number($market, 'maker_fee'),
                'contractSize' => $contractSize,
                'expiry' => $expiry,
                'expiryDatetime' => $expiryDatetime,
                'strike' => $strike,
                'optionType' => $optionType,
                'precision' => array(
                    'amount' => $this->safe_number($lotSizeFilter, 'qtyStep'),
                    'price' => $this->safe_number($priceFilter, 'tickSize'),
                ),
                'limits' => array(
                    'leverage' => array(
                        'min' => $this->safe_number($leverage, 'minLeverage'),
                        'max' => $this->safe_number($leverage, 'maxLeverage'),
                    ),
                    'amount' => array(
                        'min' => $this->safe_number_2($lotSizeFilter, 'minTradingQty', 'minOrderQty'),
                        'max' => $this->safe_number_2($lotSizeFilter, 'maxTradingQty', 'maxOrderQty'),
                    ),
                    'price' => array(
                        'min' => $this->safe_number($priceFilter, 'minPrice'),
                        'max' => $this->safe_number($priceFilter, 'maxPrice'),
                    ),
                    'cost' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
                'info' => $market,
            );
        }
        return $result;
    }

    public function parse_ticker($ticker, $market = null) {
        if (is_array($ticker) && array_key_exists('s', $ticker)) {
            return $this->parse_spot_ticker($ticker, $market);
        } else {
            return $this->parse_contract_ticker($ticker, $market);
        }
    }

    public function parse_spot_ticker($ticker, $market = null) {
        //
        // spot
        //
        //     {
        //         "t" => "1666771860025",
        //         "s" => "AAVEUSDT",
        //         "lp" => "83.8",
        //         "h" => "86.4",
        //         "l" => "81",
        //         "o" => "82.9",
        //         "bp" => "83.5",
        //         "ap" => "83.7",
        //         "v" => "7433.527",
        //         "qv" => "619835.8676"
        //     }
        // spot - bookticker
        //     {
        //         "s" => "BTCUSDT",
        //         "bp" => "19693.04",
        //         "bq" => "0.913957",
        //         "ap" => "19694.27",
        //         "aq" => "0.705447",
        //         "t" => 1661742216108
        //     }
        //
        $marketId = $this->safe_string($ticker, 's');
        $symbol = $this->safe_symbol($marketId, $market);
        $timestamp = $this->safe_integer($ticker, 't');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_string($ticker, 'h'),
            'low' => $this->safe_string($ticker, 'l'),
            'bid' => $this->safe_string($ticker, 'bp'),
            'bidVolume' => $this->safe_string($ticker, 'bq'),
            'ask' => $this->safe_string($ticker, 'ap'),
            'askVolume' => $this->safe_string($ticker, 'aq'),
            'vwap' => null,
            'open' => $this->safe_string($ticker, 'o'),
            'close' => $this->safe_string_2($ticker, 'lp', 'c'),
            'last' => null,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $this->safe_string($ticker, 'v'),
            'quoteVolume' => $this->safe_string($ticker, 'qv'),
            'info' => $ticker,
        ), $market);
    }

    public function parse_contract_ticker($ticker, $market = null) {
        //
        // linear usdt/ inverse swap and future
        //     {
        //         "symbol" => "BTCUSDT",
        //         "bid_price" => "39458",
        //         "ask_price" => "39458.5",
        //         "last_price" => "39458.00",
        //         "last_tick_direction" => "ZeroMinusTick",
        //         "prev_price_24h" => "39059.50",
        //         "price_24h_pcnt" => "0.010202",
        //         "high_price_24h" => "40058.50",
        //         "low_price_24h" => "38575.50",
        //         "prev_price_1h" => "39534.00",
        //         "price_1h_pcnt" => "-0.001922",
        //         "mark_price" => "39472.49",
        //         "index_price" => "39469.81",
        //         "open_interest" => "28343.61",
        //         "open_value" => "0.00",
        //         "total_turnover" => "85303326477.54",
        //         "turnover_24h" => "4221589085.06",
        //         "total_volume" => "30628792.45",
        //         "volume_24h" => "107569.75",
        //         "funding_rate" => "0.0001",
        //         "predicted_funding_rate" => "0.0001",
        //         "next_funding_time" => "2022-05-05T16:00:00Z",
        //         "countdown_hour" => "7",
        //         "delivery_fee_rate" => "",
        //         "predicted_delivery_price" => "",
        //         "delivery_time" => ""
        //     }
        //
        // usdc option/ swap
        //     {
        //          "symbol" => "BTC-30SEP22-400000-C",
        //          "bid" => "0",
        //          "bidIv" => "0",
        //          "bidSize" => "0",
        //          "ask" => "15",
        //          "askIv" => "1.1234",
        //          "askSize" => "0.01",
        //          "lastPrice" => "5",
        //          "openInterest" => "0.03",
        //          "indexPrice" => "39458.6",
        //          "markPrice" => "0.51901394",
        //          "markPriceIv" => "0.9047",
        //          "change24h" => "0",
        //          "high24h" => "0",
        //          "low24h" => "0",
        //          "volume24h" => "0",
        //          "turnover24h" => "0",
        //          "totalVolume" => "1",
        //          "totalTurnover" => "4",
        //          "predictedDeliveryPrice" => "0",
        //          "underlyingPrice" => "40129.73",
        //          "delta" => "0.00010589",
        //          "gamma" => "0.00000002",
        //          "vega" => "0.10670892",
        //          "theta" => "-0.03262827"
        //      }
        //
        // Unified Margin
        //
        //     {
        //         "symbol" => "BTCUSDT",
        //         "bidPrice" => "19255",
        //         "askPrice" => "19255.5",
        //         "lastPrice" => "19255.50",
        //         "lastTickDirection" => "ZeroPlusTick",
        //         "prevPrice24h" => "18634.50",
        //         "price24hPcnt" => "0.033325",
        //         "highPrice24h" => "19675.00",
        //         "lowPrice24h" => "18610.00",
        //         "prevPrice1h" => "19278.00",
        //         "markPrice" => "19255.00",
        //         "indexPrice" => "19260.68",
        //         "openInterest" => "48069.549",
        //         "turnover24h" => "4686694853.047006",
        //         "volume24h" => "243730.252",
        //         "fundingRate" => "0.0001",
        //         "nextFundingTime" => "1663689600000",
        //         "predictedDeliveryPrice" => "",
        //         "basisRate" => "",
        //         "deliveryFeeRate" => "",
        //         "deliveryTime" => "0"
        //     }
        //
        $timestamp = $this->safe_integer($ticker, 'time');
        $marketId = $this->safe_string($ticker, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market);
        $last = $this->safe_string_2($ticker, 'last_price', 'lastPrice');
        $open = $this->safe_string_n($ticker, array( 'prev_price_24h', 'openPrice', 'prevPrice24h' ));
        $percentage = $this->safe_string_n($ticker, array( 'price_24h_pcnt', 'change24h', 'price24hPcnt' ));
        $percentage = Precise::string_mul($percentage, '100');
        $quoteVolume = $this->safe_string_n($ticker, array( 'turnover_24h', 'turnover24h', 'quoteVolume' ));
        $baseVolume = $this->safe_string_n($ticker, array( 'volume_24h', 'volume24h', 'volume' ));
        $bid = $this->safe_string_n($ticker, array( 'bid_price', 'bid', 'bestBidPrice', 'bidPrice' ));
        $ask = $this->safe_string_n($ticker, array( 'ask_price', 'ask', 'bestAskPrice', 'askPrice' ));
        $high = $this->safe_string_n($ticker, array( 'high_price_24h', 'high24h', 'highPrice', 'highPrice24h' ));
        $low = $this->safe_string_n($ticker, array( 'low_price_24h', 'low24h', 'lowPrice', 'lowPrice24h' ));
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $high,
            'low' => $low,
            'bid' => $bid,
            'bidVolume' => $this->safe_string($ticker, 'bidSize'),
            'ask' => $ask,
            'askVolume' => $this->safe_string($ticker, 'askSize'),
            'vwap' => null,
            'open' => $open,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => $percentage,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_ticker($symbol, $params = array ()) {
        /**
         * fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
         * @param {string} $symbol unified $symbol of the $market to fetch the ticker for
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure ticker structure}
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $method = null;
        if ($market['spot']) {
            $method = 'publicGetSpotV3PublicQuoteTicker24hr';
        } else {
            $method = 'publicGetDerivativesV3PublicTickers';
            if ($market['option']) {
                $request['category'] = 'option';
            } elseif ($market['linear']) {
                $request['category'] = 'linear';
            } elseif ($market['inverse']) {
                $request['category'] = 'inverse';
            }
        }
        $response = $this->$method (array_merge($request, $params));
        //
        // spot
        //
        //    {
        //         "retCode" => "0",
        //         "retMsg" => "OK",
        //         "result" => array(
        //             "t" => "1666771860025",
        //             "s" => "AAVEUSDT",
        //             "lp" => "83.8",
        //             "h" => "86.4",
        //             "l" => "81",
        //             "o" => "82.9",
        //             "bp" => "83.5",
        //             "ap" => "83.7",
        //             "v" => "7433.527",
        //             "qv" => "619835.8676"
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => "1666771898218"
        //     }
        //
        //     {
        //         ret_code => 0,
        //         ret_msg => 'OK',
        //         ext_code => '',
        //         ext_info => '',
        //         $result => array(
        //             {
        //                 $symbol => 'BTCUSD',
        //                 bid_price => '7680',
        //                 ask_price => '7680.5',
        //                 last_price => '7680.00',
        //                 last_tick_direction => 'MinusTick',
        //                 prev_price_24h => '7870.50',
        //                 price_24h_pcnt => '-0.024204',
        //                 high_price_24h => '8035.00',
        //                 low_price_24h => '7671.00',
        //                 prev_price_1h => '7780.00',
        //                 price_1h_pcnt => '-0.012853',
        //                 mark_price => '7683.27',
        //                 index_price => '7682.74',
        //                 open_interest => 188829147,
        //                 open_value => '23670.06',
        //                 total_turnover => '25744224.90',
        //                 turnover_24h => '102997.83',
        //                 total_volume => 225448878806,
        //                 volume_24h => 809919408,
        //                 funding_rate => '0.0001',
        //                 predicted_funding_rate => '0.0001',
        //                 next_funding_time => '2020-03-12T00:00:00Z',
        //                 countdown_hour => 7
        //             }
        //         ),
        //         time_now => '1583948195.818255'
        //     }
        //  usdc ticker
        //     {
        //         "retCode" => 0,
        //           "retMsg" => "SUCCESS",
        //           "result" => {
        //                  "symbol" => "BTC-28JAN22-250000-C",
        //                    "bid" => "0",
        //                    "bidIv" => "0",
        //                    "bidSize" => "0",
        //                    "ask" => "0",
        //                    "askIv" => "0",
        //                    "askSize" => "0",
        //                    "lastPrice" => "0",
        //                    "openInterest" => "0",
        //                    "indexPrice" => "56171.79000000",
        //                    "markPrice" => "12.72021285",
        //                    "markPriceIv" => "1.1701",
        //                    "change24h" => "0",
        //                    "high24h" => "0",
        //                    "low24h" => "0",
        //                    "volume24h" => "0",
        //                    "turnover24h" => "0",
        //                    "totalVolume" => "0",
        //                    "totalTurnover" => "0",
        //                    "predictedDeliveryPrice" => "0",
        //                    "underlyingPrice" => "57039.61000000",
        //                    "delta" => "0.00184380",
        //                    "gamma" => "0.00000022",
        //                    "vega" => "1.35132531",
        //                    "theta" => "-1.33819821"
        //          }
        //     }
        //
        // unified margin
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => {
        //             "category" => "linear",
        //             "list" => array(
        //                 array(
        //                     "symbol" => "BTCUSDT",
        //                     "bidPrice" => "19255",
        //                     "askPrice" => "19255.5",
        //                     "lastPrice" => "19255.50",
        //                     "lastTickDirection" => "ZeroPlusTick",
        //                     "prevPrice24h" => "18634.50",
        //                     "price24hPcnt" => "0.033325",
        //                     "highPrice24h" => "19675.00",
        //                     "lowPrice24h" => "18610.00",
        //                     "prevPrice1h" => "19278.00",
        //                     "markPrice" => "19255.00",
        //                     "indexPrice" => "19260.68",
        //                     "openInterest" => "48069.549",
        //                     "turnover24h" => "4686694853.047006",
        //                     "volume24h" => "243730.252",
        //                     "fundingRate" => "0.0001",
        //                     "nextFundingTime" => "1663689600000",
        //                     "predictedDeliveryPrice" => "",
        //                     "basisRate" => "",
        //                     "deliveryFeeRate" => "",
        //                     "deliveryTime" => "0"
        //                 }
        //             )
        //         ),
        //         "retExtInfo" => null,
        //         "time" => 1663670053454
        //
        $result = $this->safe_value($response, 'result', array());
        $rawTicker = null;
        if (gettype($result) === 'array' && array_keys($result) === array_keys(array_keys($result))) {
            $rawTicker = $this->safe_value($result, 0);
        } else {
            $tickers = $this->safe_value($result, 'list');
            if ($tickers !== null) {
                $rawTicker = $this->safe_value($tickers, 0);
            } else {
                $rawTicker = $result;
            }
        }
        return $this->parse_ticker($rawTicker, $market);
    }

    public function fetch_spot_tickers($symbols = null, $params = array ()) {
        $this->load_markets();
        $symbols = $this->market_symbols($symbols);
        $response = $this->publicGetSpotV3PublicQuoteTicker24hr ($params);
        //
        //     {
        //         "ret_code":0,
        //         "ret_msg":null,
        //         "result":array(
        //             {
        //                 "time":1667198103209,
        //                 "symbol":"XDCUSDT",
        //                 "bestBidPrice":"0.03092",
        //                 "bestAskPrice":"0.03093",
        //                 "volume":"393311",
        //                 "quoteVolume":"12189.678747",
        //                 "lastPrice":"0.03092",
        //                 "highPrice":"0.03111",
        //                 "lowPrice":"0.0309",
        //                 "openPrice":"0.0309"
        //             }
        //         ),
        //         "ext_code" => null,
        //         "ext_info" => null
        //     }
        //
        $list = $this->safe_value($response, 'result', array());
        $tickerList = $this->safe_value($list, 'list');
        $tickers = array();
        for ($i = 0; $i < count($tickerList); $i++) {
            $ticker = $this->parse_ticker($tickerList[$i]);
            $symbol = $ticker['symbol'];
            $tickers[$symbol] = $ticker;
        }
        return $this->filter_by_array($tickers, 'symbol', $symbols);
    }

    public function fetch_derivatives_tickers($symbols = null, $params = array ()) {
        $this->load_markets();
        $symbols = $this->market_symbols($symbols);
        $request = array();
        list($subType, $query) = $this->handle_sub_type_and_params('fetchTickers', null, $params);
        if ($subType === 'option') {
            // bybit requires a $symbol when $query tockers for options markets
            throw new NotSupported($this->id . ' fetchTickers() is not supported for option markets');
        } else {
            $request['category'] = $subType;
        }
        $response = $this->publicGetDerivativesV3PublicTickers (array_merge($request, $query));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => {
        //             "category" => "linear",
        //             "list" => array(
        //                 array(
        //                     "symbol" => "BTCUSDT",
        //                     "bidPrice" => "19255",
        //                     "askPrice" => "19255.5",
        //                     "lastPrice" => "19255.50",
        //                     "lastTickDirection" => "ZeroPlusTick",
        //                     "prevPrice24h" => "18634.50",
        //                     "price24hPcnt" => "0.033325",
        //                     "highPrice24h" => "19675.00",
        //                     "lowPrice24h" => "18610.00",
        //                     "prevPrice1h" => "19278.00",
        //                     "markPrice" => "19255.00",
        //                     "indexPrice" => "19260.68",
        //                     "openInterest" => "48069.549",
        //                     "turnover24h" => "4686694853.047006",
        //                     "volume24h" => "243730.252",
        //                     "fundingRate" => "0.0001",
        //                     "nextFundingTime" => "1663689600000",
        //                     "predictedDeliveryPrice" => "",
        //                     "basisRate" => "",
        //                     "deliveryFeeRate" => "",
        //                     "deliveryTime" => "0"
        //                 }
        //             )
        //         ),
        //         "retExtInfo" => null,
        //         "time" => 1663670053454
        //     }
        //
        $tickerList = $this->safe_value($response, 'result', array());
        if (gettype($tickerList) !== 'array' || array_keys($tickerList) !== array_keys(array_keys($tickerList))) {
            $tickerList = $this->safe_value($tickerList, 'list');
        }
        $tickers = array();
        for ($i = 0; $i < count($tickerList); $i++) {
            $ticker = $this->parse_ticker($tickerList[$i]);
            $symbol = $ticker['symbol'];
            $tickers[$symbol] = $ticker;
        }
        return $this->filter_by_array($tickers, 'symbol', $symbols);
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        /**
         * fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
         * @see https://bybit-exchange.github.io/docs/futuresV2/linear/#t-latestsymbolinfo
         * @see https://bybit-exchange.github.io/docs/spot/v3/#t-spot_latestsymbolinfo
         * @param {[string]|null} $symbols unified $symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} an array of {@link https://docs.ccxt.com/en/latest/manual.html#ticker-structure ticker structures}
         */
        $this->load_markets();
        list($type, $query) = $this->handle_market_type_and_params('fetchTickers', null, $params);
        if ($type === 'spot') {
            return $this->fetch_spot_tickers($symbols, $query);
        } else {
            return $this->fetch_derivatives_tickers($symbols, $query);
        }
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        if (is_array($ohlcv) && array_key_exists('t', $ohlcv)) {
            return $this->parse_spot_ohlcv($ohlcv, $market);
        } else {
            return $this->parse_contract_ohlcv($ohlcv, $market);
        }
    }

    public function parse_spot_ohlcv($ohlcv, $market = null) {
        //
        // spot
        //     {
        //         "t" => "1666759020000",
        //         "s" => "AAVEUSDT",
        //         "sn" => "AAVEUSDT",
        //         "c" => "83",
        //         "h" => "83.4",
        //         "l" => "82.9",
        //         "o" => "83.4",
        //         "v" => "149.368"
        //     }
        //
        return array(
            $this->safe_integer($ohlcv, 't'),
            $this->safe_number($ohlcv, 'o'),
            $this->safe_number($ohlcv, 'h'),
            $this->safe_number($ohlcv, 'l'),
            $this->safe_number($ohlcv, 'c'),
            $this->safe_number($ohlcv, 'v'),
        );
    }

    public function parse_contract_ohlcv($ohlcv, $market = null) {
        //
        // Unified Margin
        //
        //     array(
        //         "1621162800",
        //         "49592.43",
        //         "49644.91",
        //         "49342.37",
        //         "49349.42",
        //         "1451.59",
        //         "2.4343353100000003"
        //     )
        //
        return array(
            $this->safe_number($ohlcv, 0),
            $this->safe_number($ohlcv, 1),
            $this->safe_number($ohlcv, 2),
            $this->safe_number($ohlcv, 3),
            $this->safe_number($ohlcv, 4),
            $this->safe_number($ohlcv, 5),
        );
    }

    public function fetch_spot_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $duration = $this->parse_timeframe($timeframe);
        $now = $this->seconds();
        $sinceTimestamp = null;
        if ($limit === null) {
            $limit = 200; // default is 200 when requested with `$since`
        }
        if ($since === null) {
            $sinceTimestamp = $now - $limit * $duration;
        } else {
            $sinceTimestamp = intval($since / 1000);
        }
        if ($limit !== null) {
            $request['limit'] = $limit; // max 200, default 200
        }
        $request['interval'] = $timeframe;
        $request['from'] = $sinceTimestamp;
        $response = $this->publicGetSpotV3PublicQuoteKline (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => {
        //         "list" => array(
        //             array(
        //             "t" => 1659430380000,
        //             "s" => "BTCUSDT",
        //             "sn" => "BTCUSDT",
        //             "c" => "21170.14",
        //             "h" => "21170.14",
        //             "l" => "21127.86",
        //             "o" => "21127.86",
        //             "v" => "0.907276"
        //             }
        //         )
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => 1659430400353
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $ohlcvs = $this->safe_value($result, 'list', array());
        return $this->parse_ohlcvs($ohlcvs, $market, $timeframe, $since, $limit);
    }

    public function fetch_derivatives_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        if ($market['option']) {
            throw new NotSupported($this->id . ' fetchOHLCV() is not supported for option markets');
        }
        $request = array(
            'symbol' => $market['id'],
        );
        $duration = $this->parse_timeframe($timeframe);
        $now = $this->milliseconds();
        if ($limit === null) {
            $limit = 200; // default is 200 when requested with `$since`
        } else {
            $request['limit'] = $limit;
        }
        if ($since === null) {
            $since = $now - ($limit * $duration * 1000);
        }
        // $end is required parameter
        $end = $this->safe_integer($params, 'end');
        if ($end === null) {
            $end = $this->sum($since, $limit * $duration * 1000);
        }
        if ($market['linear']) {
            $request['category'] = 'linear';
        } elseif ($market['inverse']) {
            $request['category'] = 'inverse';
        }
        $request['start'] = $since;
        $request['end'] = $end;
        $request['interval'] = $this->timeframes[$timeframe];
        $price = $this->safe_string($params, 'price');
        $params = $this->omit($params, 'price');
        $methods = array(
            'mark' => 'publicGetDerivativesV3PublicMarkPriceKline',
            'index' => 'publicGetDerivativesV3PublicIndexPriceKline',
        );
        $method = $this->safe_value($methods, $price, 'publicGetDerivativesV3PublicKline');
        $response = $this->$method (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg":"success",
        //         "result":{
        //             "category":"linear",
        //             "symbol":"BTCUSDT",
        //             "interval":"1",
        //             "list":array(
        //                 array(
        //                     "1621162800",
        //                     "49592.43",
        //                     "49644.91",
        //                     "49342.37",
        //                     "49349.42",
        //                     "1451.59",
        //                     "2.4343353100000003"
        //                 )
        //             )
        //         }
        //     }
        //
        $result = $this->safe_value($response, 'result');
        $ohlcvs = $this->safe_value($result, 'list', array());
        return $this->parse_ohlcvs($ohlcvs, $market, $timeframe, $since, $limit);
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        /**
         * fetches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
         * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
         * @param {string} $timeframe the length of time each candle represents
         * @param {int|null} $since timestamp in ms of the earliest candle to fetch
         * @param {int|null} $limit the maximum amount of candles to fetch
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
         */
        $this->load_markets();
        $market = $this->market($symbol);
        if ($market['spot']) {
            return $this->fetch_spot_ohlcv($symbol, $timeframe, $since, $limit, $params);
        } else {
            return $this->fetch_derivatives_ohlcv($symbol, $timeframe, $since, $limit, $params);
        }
    }

    public function fetch_funding_rate($symbol, $params = array ()) {
        /**
         * fetch the current funding rate
         * @param {string} $symbol unified $market $symbol
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#funding-rate-structure funding rate structure}
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $isUsdcSettled = $market['settle'] === 'USDC';
        $method = null;
        if ($isUsdcSettled) {
            $method = 'privatePostPerpetualUsdcOpenapiPrivateV1PredictedFunding';
        } else {
            $method = $market['linear'] ? 'privateGetPrivateLinearFundingPredictedFunding' : 'privateGetV2PrivateFundingPredictedFunding';
        }
        $response = $this->$method (array_merge($request, $params));
        //
        // linear
        //     {
        //       "ret_code" => 0,
        //       "ret_msg" => "OK",
        //       "ext_code" => "",
        //       "ext_info" => "",
        //       "result" => array(
        //         "predicted_funding_rate" => 0.0001,
        //         "predicted_funding_fee" => 0.00231849
        //       ),
        //       "time_now" => "1658446366.304113",
        //       "rate_limit_status" => 119,
        //       "rate_limit_reset_ms" => 1658446366300,
        //       "rate_limit" => 120
        //     }
        //
        // inverse
        //     {
        //       "ret_code" => 0,
        //       "ret_msg" => "OK",
        //       "ext_code" => "",
        //       "ext_info" => "",
        //       "result" => array(
        //         "predicted_funding_rate" => -0.00001769,
        //         "predicted_funding_fee" => 0
        //       ),
        //       "time_now" => "1658445512.778048",
        //       "rate_limit_status" => 119,
        //       "rate_limit_reset_ms" => 1658445512773,
        //       "rate_limit" => 120
        //     }
        //
        // usdc
        //     {
        //       "result" => array(
        //         "predictedFundingRate" => "0.0002213",
        //         "predictedFundingFee" => "0"
        //       ),
        //       "retCode" => 0,
        //       "retMsg" => "success"
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $fundingRate = $this->safe_number_2($result, 'predicted_funding_rate', 'predictedFundingRate');
        $timestamp = $this->safe_timestamp($response, 'time_now');
        return array(
            'info' => $response,
            'symbol' => $symbol,
            'markPrice' => null,
            'indexPrice' => null,
            'interestRate' => null,
            'estimatedSettlePrice' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'fundingRate' => $fundingRate,
            'fundingTimestamp' => null,
            'fundingDatetime' => null,
            'nextFundingRate' => null,
            'nextFundingTimestamp' => null,
            'nextFundingDatetime' => null,
            'previousFundingRate' => null,
            'previousFundingTimestamp' => null,
            'previousFundingDatetime' => null,
        );
    }

    public function fetch_funding_rate_history($symbol = null, $since = null, $limit = null, $params = array ()) {
        /**
         * fetches historical funding rate prices
         * @param {string|null} $symbol unified $symbol of the $market to fetch the funding rate history for
         * @param {int|null} $since $timestamp in ms of the earliest funding rate to fetch
         * @param {int|null} $limit the maximum amount of ~@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure funding rate structures~ to fetch
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @param {int|null} $params->until $timestamp in ms of the latest funding rate
         * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure funding rate structures~
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchFundingRateHistory() requires a symbol');
        }
        $this->load_markets();
        $request = array();
        $market = $this->market($symbol);
        $symbol = $market['symbol'];
        $request['symbol'] = $market['id'];
        if ($market['option']) {
            throw new NotSupported($this->id . ' fetchFundingRateHistory() is not supported for option markets');
        } elseif ($market['linear']) {
            $request['category'] = 'linear';
        } elseif ($market['inverse']) {
            $request['category'] = 'inverse';
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        $until = $this->safe_integer_2($params, 'until', 'till'); // unified in milliseconds
        $endTime = $this->safe_integer($params, 'endTime', $until); // exchange-specific in milliseconds
        $params = $this->omit($params, array( 'endTime', 'till', 'until' ));
        if ($endTime !== null) {
            $request['endTime'] = $endTime;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->publicGetDerivativesV3PublicFundingHistoryFundingRate (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => {
        //             "category" => "linear",
        //             "list" => array(
        //                 array(
        //                     "symbol" => "BTCUSDT",
        //                     "fundingRate" => "0.0001",
        //                     "fundingRateTimestamp" => "1657728000000"
        //                 ),
        //                 array(
        //                     "symbol" => "BTCUSDT",
        //                     "fundingRate" => "0.0001",
        //                     "fundingRateTimestamp" => "1657699200000"
        //                 }
        //             )
        //         ),
        //         "time" => 1657782323371
        //     }
        //
        $rates = array();
        $result = $this->safe_value($response, 'result');
        $resultList = $this->safe_value($result, 'list');
        for ($i = 0; $i < count($resultList); $i++) {
            $entry = $resultList[$i];
            $timestamp = $this->safe_integer($entry, 'fundingRateTimestamp');
            $rates[] = array(
                'info' => $entry,
                'symbol' => $this->safe_symbol($this->safe_string($entry, 'symbol')),
                'fundingRate' => $this->safe_number($entry, 'fundingRate'),
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
            );
        }
        $sorted = $this->sort_by($rates, 'timestamp');
        return $this->filter_by_symbol_since_limit($sorted, $symbol, $since, $limit);
    }

    public function fetch_index_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $request = array(
            'price' => 'index',
        );
        return $this->fetch_ohlcv($symbol, $timeframe, $since, $limit, array_merge($request, $params));
    }

    public function fetch_mark_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $request = array(
            'price' => 'mark',
        );
        return $this->fetch_ohlcv($symbol, $timeframe, $since, $limit, array_merge($request, $params));
    }

    public function fetch_premium_index_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $request = array(
            'price' => 'premiumIndex',
        );
        return $this->fetch_ohlcv($symbol, $timeframe, $since, $limit, array_merge($request, $params));
    }

    public function parse_trade($trade, $market = null) {
        $isSpotTrade = (is_array($trade) && array_key_exists('isBuyerMaker', $trade)) || (is_array($trade) && array_key_exists('feeTokenId', $trade));
        if ($isSpotTrade) {
            return $this->parse_spot_trade($trade, $market);
        } else {
            return $this->parse_contract_trade($trade, $market);
        }
    }

    public function parse_spot_trade($trade, $market = null) {
        //
        //   public:
        //     {
        //        "price" => "39548.68",
        //        "time" => "1651748717850",
        //        "qty" => "0.166872",
        //        "isBuyerMaker" => 0
        //     }
        //
        //   private:
        //     {
        //         "orderPrice" => "82.5",
        //         "creatTime" => "1666702226326",
        //         "orderQty" => "0.016",
        //         "isBuyer" => "0",
        //         "isMaker" => "0",
        //         "symbol" => "AAVEUSDT",
        //         "id" => "1274785101965716992",
        //         "orderId" => "1274784252359089664",
        //         "tradeId" => "2270000000031365639",
        //         "execFee" => "0",
        //         "feeTokenId" => "AAVE",
        //         "matchOrderId" => "1274785101865076224",
        //         "makerRebate" => "0",
        //         "executionTime" => "1666702226335"
        //     }
        //
        $timestamp = $this->safe_integer_n($trade, array( 'time', 'creatTime' ));
        $takerOrMaker = null;
        $side = null;
        $isBuyerMaker = $this->safe_integer($trade, 'isBuyerMaker');
        if ($isBuyerMaker !== null) {
            // if public response
            $side = ($isBuyerMaker === 1) ? 'buy' : 'sell';
        } else {
            // if private response
            $isBuyer = $this->safe_integer($trade, 'isBuyer');
            $isMaker = $this->safe_integer($trade, 'isMaker');
            $takerOrMaker = ($isMaker === 0) ? 'maker' : 'taker';
            $side = ($isBuyer === 0) ? 'buy' : 'sell';
        }
        $marketId = $this->safe_string($trade, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $fee = array();
        $feeToken = $this->safe_string($trade, 'feeTokenId');
        if ($feeToken !== null) {
            $feeCurrency = $this->safe_currency_code($feeToken);
            $feeCost = $this->safe_string($trade, 'execFee');
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrency,
            );
        }
        return $this->safe_trade(array(
            'id' => $this->safe_string($trade, 'id'),
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $market['symbol'],
            'order' => $this->safe_string($trade, 'orderId'),
            'type' => null,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $this->safe_string_2($trade, 'price', 'orderPrice'),
            'amount' => $this->safe_string_2($trade, 'qty', 'orderQty'),
            'cost' => null,
            'fee' => $fee,
        ), $market);
    }

    public function parse_contract_trade($trade, $market = null) {
        //
        // public spot
        //
        //     {
        //         "price" => "1162.51",
        //         "time" => "1669192055405",
        //         "qty" => "0.86013",
        //         "isBuyerMaker" => "0"
        //     }
        //
        // private spot
        //
        //     {
        //         "symbol" => "ETHUSDT",
        //         "id" => "1295416074059212032",
        //         "orderId" => "1295416073941829632",
        //         "tradeId" => "2280000000026848229",
        //         "orderPrice" => "1138.2",
        //         "orderQty" => "0.05",
        //         "execFee" => "0",
        //         "feeTokenId" => "ETH",
        //         "creatTime" => "1669161629850",
        //         "isBuyer" => "0",
        //         "isMaker" => "1",
        //         "matchOrderId" => "1295416073505583360",
        //         "makerRebate" => "0",
        //         "executionTime" => "1669161629861"
        //     }
        //
        // public contract
        //
        //     {
        //         "execId" => "666042b4-50c6-58f3-bd9c-89b2088663ff",
        //         "symbol" => "ETHUSD",
        //         "price" => "1162.95",
        //         "size" => "1",
        //         "side" => "Sell",
        //         "time" => "1669191277315",
        //         "isBlockTrade" => false
        //     }
        //
        // public unified margin
        //
        //     {
        //         "execId" => "da66abbc-f358-5864-8d34-84ef7274d853",
        //         "symbol" => "BTCUSDT",
        //         "price" => "20802.50",
        //         "size" => "0.200",
        //         "side" => "Sell",
        //         "time" => "1657870316630"
        //     }
        //
        // private contract trades
        //
        //     {
        //         "symbol" => "ETHUSD",
        //         "execFee" => "0.00005484",
        //         "execId" => "acf78206-d464-589b-b888-51bd130821c1",
        //         "execPrice" => "1367.80",
        //         "execQty" => "100",
        //         "execType" => "Trade",
        //         "execValue" => "0.0731101",
        //         "feeRate" => "0.00075",
        //         "lastLiquidityInd" => "RemovedLiquidity",
        //         "leavesQty" => "0",
        //         "orderId" => "fdc584c3-be5d-41ff-8f54-5be7649b1d1c",
        //         "orderLinkId" => "",
        //         "orderPrice" => "1299.50",
        //         "orderQty" => "100",
        //         "orderType" => "Market",
        //         "stopOrderType" => "UNKNOWN",
        //         "side" => "Sell",
        //         "execTime" => "1611528105547",
        //         "closedSize" => "100"
        //     }
        //
        // private unified margin
        //
        //     {
        //         "symbol" => "AAVEUSDT",
        //         "id" => "1274785101965716992",
        //         "orderId" => "1274784252359089664",
        //         "tradeId" => "2270000000031365639",
        //         "orderPrice" => "82.5",
        //         "orderQty" => "0.016",
        //         "execFee" => "0",
        //         "feeTokenId" => "AAVE",
        //         "creatTime" => "1666702226326",
        //         "isBuyer" => "0",
        //         "isMaker" => "0",
        //         "matchOrderId" => "1274785101865076224",
        //         "makerRebate" => "0",
        //         "executionTime" => "1666702226335"
        //     }
        //
        // private USDC settled trades
        //
        //     {
        //         "symbol" => "ETHPERP",
        //         "orderLinkId" => "",
        //         "side" => "Buy",
        //         "orderId" => "aad0ee44-ce12-4112-aeee-b7829f6c3a26",
        //         "execFee" => "0.0210",
        //         "feeRate" => "0.000600",
        //         "blockTradeId" => "",
        //         "tradeTime" => "1669196417930",
        //         "execPrice" => "1162.15",
        //         "lastLiquidityInd" => "TAKER",
        //         "execValue" => "34.8645",
        //         "execType" => "Trade",
        //         "execQty" => "0.030",
        //         "tradeId" => "0e94eaf5-b08e-5505-b43f-7f1f30b1ca80"
        //     }
        //
        $id = $this->safe_string_n($trade, array( 'execId', 'id', 'tradeId' ));
        $marketId = $this->safe_string($trade, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $amountString = $this->safe_string_n($trade, array( 'orderQty', 'size', 'execQty' ));
        $priceString = $this->safe_string_n($trade, array( 'orderPrice', 'price', 'execPrice' ));
        $costString = $this->safe_string($trade, 'execValue');
        $timestamp = $this->safe_integer_n($trade, array( 'time', 'execTime', 'tradeTime' ));
        $side = $this->safe_string_lower($trade, 'side');
        if ($side === null) {
            $isBuyer = $this->safe_integer($trade, 'isBuyer');
            if ($isBuyer !== null) {
                $side = $isBuyer ? 'buy' : 'sell';
            }
        }
        $isMaker = $this->safe_value($trade, 'isMaker');
        $takerOrMaker = null;
        if ($isMaker !== null) {
            $takerOrMaker = $isMaker ? 'maker' : 'taker';
        } else {
            $lastLiquidityInd = $this->safe_string($trade, 'lastLiquidityInd');
            if ($lastLiquidityInd === 'UNKNOWN') {
                $lastLiquidityInd = null;
            }
            if ($lastLiquidityInd !== null) {
                if (($lastLiquidityInd === 'TAKER') || ($lastLiquidityInd === 'MAKER')) {
                    $takerOrMaker = strtolower($lastLiquidityInd);
                } else {
                    $takerOrMaker = ($lastLiquidityInd === 'AddedLiquidity') ? 'maker' : 'taker';
                }
            }
        }
        $orderType = $this->safe_string_lower($trade, 'orderType');
        if ($orderType === 'unknown') {
            $orderType = null;
        }
        $feeCostString = $this->safe_string($trade, 'execFee');
        $fee = null;
        if ($feeCostString !== null) {
            $feeCurrencyCode = null;
            if ($market['spot']) {
                $feeCurrencyCode = $this->safe_string($trade, 'commissionAsset');
            } else {
                $feeCurrencyCode = $market['inverse'] ? $market['base'] : $market['settle'];
            }
            $fee = array(
                'cost' => $feeCostString,
                'currency' => $feeCurrencyCode,
            );
        }
        return $this->safe_trade(array(
            'id' => $id,
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'order' => $this->safe_string($trade, 'orderId'),
            'type' => $orderType,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $priceString,
            'amount' => $amountString,
            'cost' => $costString,
            'fee' => $fee,
        ), $market);
    }

    public function fetch_spot_trades($symbol, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit; // Default value is 60, max 60
        }
        $response = $this->publicGetSpotV3PublicQuoteTrades (array_merge($request, $params));
        //
        // spot
        //
        //    {
        //         "retCode" => "0",
        //         "retMsg" => "OK",
        //         "result" => array(
        //             "list" => array(
        //                 array(
        //                     "price" => "84",
        //                     "time" => "1666768241806",
        //                     "qty" => "0.122",
        //                     "isBuyerMaker" => "1"
        //                 ),
        //             )
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => "1666770562956"
        //     }
        //
        //
        //     {
        //         ret_code => 0,
        //         ret_msg => 'OK',
        //         ext_code => '',
        //         ext_info => '',
        //         $result => array(
        //             array(
        //                 "price" => "50005.12",
        //                 "time" => 1620822657672,
        //                 "qty" => "0.0001",
        //                 "isBuyerMaker" => true
        //             ),
        //         ),
        //         time_now => '1583954313.393362'
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $trades = $this->safe_value($result, 'list', array());
        return $this->parse_trades($trades, $market, $since, $limit);
    }

    public function fetch_derivatives_trades($symbol, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit; // Limit for data size per page, max size is 1000. Default as showing 500 pieces of data per page
        }
        if ($market['option']) {
            $request['category'] = 'option';
        } elseif ($market['linear']) {
            $request['category'] = 'linear';
        } elseif ($market['inverse']) {
            $request['category'] = 'inverse';
        }
        $response = $this->publicGetDerivativesV3PublicRecentTrade (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => {
        //             "category" => "linear",
        //             "list" => array(
        //                 array(
        //                     "execId" => "da66abbc-f358-5864-8d34-84ef7274d853",
        //                     "symbol" => "BTCUSDT",
        //                     "price" => "20802.50",
        //                     "size" => "0.200",
        //                     "side" => "Sell",
        //                     "time" => "1657870316630"
        //                 }
        //             )
        //         ),
        //         "time" => 1657870326247
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $trades = $this->safe_value($result, 'list', array());
        return $this->parse_trades($trades, $market, $since, $limit);
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        /**
         * get the list of most recent trades for a particular $symbol
         * @param {string} $symbol unified $symbol of the $market to fetch trades for
         * @param {int|null} $since timestamp in ms of the earliest trade to fetch
         * @param {int|null} $limit the maximum amount of trades to fetch
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-trades trade structures~
         */
        $this->load_markets();
        $market = $this->market($symbol);
        if ($market['type'] === 'spot') {
            return $this->fetch_spot_trades($symbol, $since, $limit, $params);
        } else {
            return $this->fetch_derivatives_trades($symbol, $since, $limit, $params);
        }
    }

    public function fetch_spot_order_book($symbol, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->publicGetSpotV3PublicQuoteDepth (array_merge($request, $params));
        //
        // spot
        //
        //    {
        //         "retCode" => "0",
        //         "retMsg" => "OK",
        //         "result" => array(
        //             "time" => "1620886105740",
        //             "bids" => array(
        //                 array( "84", "7.323" ),
        //                 array( "83.9", "101.711" ),
        //             ),
        //             "asks" => array(
        //                 array( "84.1", "5.898" ),
        //                 array( "84.2", "350.31" ),
        //             )
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => "1666771624950"
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $timestamp = $this->safe_integer($result, 'time');
        return $this->parse_order_book($result, $symbol, $timestamp);
    }

    public function fetch_derivatives_order_book($symbol, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        if ($market['option']) {
            $request['category'] = 'option';
        } elseif ($market['linear']) {
            $request['category'] = 'linear';
        } elseif ($market['inverse']) {
            $request['category'] = 'inverse';
        }
        $response = $this->publicGetDerivativesV3PublicOrderBookL2 (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "success",
        //         "result" => {
        //             "s" => "BTCUSDT",
        //             "b" => array(
        //                 array(
        //                     "28806",
        //                     "0.06"
        //                 ),
        //                 array(
        //                     "28807",
        //                     "5.005"
        //                 )
        //             ),
        //             "a" => array(
        //                 array(
        //                     "29004",
        //                     "0.001"
        //                 ),
        //                 array(
        //                     "29012",
        //                     "0.017"
        //                 )
        //             ),
        //             "ts" => 1653638043149,
        //             "u" => 4912426
        //         }
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $timestamp = $this->safe_integer($result, 'ts');
        return $this->parse_order_book($result, $symbol, $timestamp, 'b', 'a');
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        /**
         * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
         * @param {string} $symbol unified $symbol of the $market to fetch the order book for
         * @param {int|null} $limit the maximum amount of order book entries to return
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} A dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#order-book-structure order book structures} indexed by $market symbols
         */
        $this->load_markets();
        $market = $this->market($symbol);
        if ($market['spot']) {
            return $this->fetch_spot_order_book($symbol, $limit, $params);
        } else {
            return $this->fetch_derivatives_order_book($symbol, $limit, $params);
        }
    }

    public function parse_balance($response) {
        //
        // margin wallet
        //     array(
        //         array(
        //             "free" => "0.001143855",
        //             "interest" => "0",
        //             "loan" => "0",
        //             "locked" => "0",
        //             "tokenId" => "BTC",
        //             "total" => "0.001143855"
        //         ),
        //         array(
        //             "free" => "200.00005568",
        //             "interest" => "0.0008391",
        //             "loan" => "200",
        //             "locked" => "0",
        //             "tokenId" => "USDT",
        //             "total" => "200.00005568"
        //         ),
        //     )
        //
        // usdc wallet
        //    {
        //      "result" => array(
        //           "walletBalance" => "10.0000",
        //           "accountMM" => "0.0000",
        //           "bonus" => "0.0000",
        //           "accountIM" => "0.0000",
        //           "totalSessionRPL" => "0.0000",
        //           "equity" => "10.0000",
        //           "totalRPL" => "0.0000",
        //           "marginBalance" => "10.0000",
        //           "availableBalance" => "10.0000",
        //           "totalSessionUPL" => "0.0000"
        //       ),
        //       "retCode" => "0",
        //       "retMsg" => "Success."
        //    }
        //
        // Unified Margin
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "Success",
        //         "result" => {
        //             "totalEquity" => "112.21267421",
        //             "accountIMRate" => "0.6895",
        //             "totalMarginBalance" => "80.37711012",
        //             "totalInitialMargin" => "55.42180254",
        //             "totalAvailableBalance" => "24.95530758",
        //             "accountMMRate" => "0.0459",
        //             "totalPerpUPL" => "-16.69586570",
        //             "totalWalletBalance" => "97.07311619",
        //             "totalMaintenanceMargin" => "3.68580537",
        //             "coin" => array(
        //                 array(
        //                     "currencyCoin" => "ETH",
        //                     "availableToBorrow" => "0.00000000",
        //                     "borrowSize" => "0.00000000",
        //                     "bonus" => "0.00000000",
        //                     "accruedInterest" => "0.00000000",
        //                     "availableBalanceWithoutConvert" => "0.00000000",
        //                     "totalOrderIM" => "",
        //                     "equity" => "0.00000000",
        //                     "totalPositionMM" => "",
        //                     "usdValue" => "0.00000000",
        //                     "availableBalance" => "0.02441165",
        //                     "unrealisedPnl" => "",
        //                     "totalPositionIM" => "",
        //                     "marginBalanceWithoutConvert" => "0.00000000",
        //                     "walletBalance" => "0.00000000",
        //                     "cumRealisedPnl" => "",
        //                     "marginBalance" => "0.07862610"
        //                 }
        //             )
        //         ),
        //         "time" => 1657716037033
        //     }
        //
        // contract v3
        //
        //     array(
        //         array(
        //             "coin" => "BTC",
        //             "equity" => "0.00000002",
        //             "walletBalance" => "0.00000002",
        //             "positionMargin" => "0",
        //             "availableBalance" => "0.00000002",
        //             "orderMargin" => "0",
        //             "occClosingFee" => "0",
        //             "occFundingFee" => "0",
        //             "unrealisedPnl" => "0",
        //             "cumRealisedPnl" => "-0.00010941",
        //             "givenCash" => "0",
        //             "serviceCash" => "0"
        //         ),
        //         {
        //             "coin" => "USDT",
        //             "equity" => "3662.81038535",
        //             "walletBalance" => "3662.81038535",
        //             "positionMargin" => "0",
        //             "availableBalance" => "3662.81038535",
        //             "orderMargin" => "0",
        //             "occClosingFee" => "0",
        //             "occFundingFee" => "0",
        //             "unrealisedPnl" => "0",
        //             "cumRealisedPnl" => "-36.01761465",
        //             "givenCash" => "0",
        //             "serviceCash" => "0"
        //         }
        //     )
        // spot
        //     {
        //       retCode => '0',
        //       retMsg => 'OK',
        //       $result => {
        //         balances => array(
        //           array(
        //             coin => 'BTC',
        //             coinId => 'BTC',
        //             total => '0.00977041118',
        //             free => '0.00877041118',
        //             locked => '0.001'
        //           ),
        //           array(
        //             coin => 'EOS',
        //             coinId => 'EOS',
        //             total => '2000',
        //             free => '2000',
        //             locked => '0'
        //           }
        //         )
        //       ),
        //       retExtInfo => array(),
        //       time => '1670002625754'
        //  }
        //
        $result = array(
            'info' => $response,
        );
        $responseResult = $this->safe_value($response, 'result', array());
        $currencyList = $this->safe_value_n($responseResult, array( 'loanAccountList', 'list', 'coin', 'balances' ));
        if ($currencyList === null) {
            // usdc wallet
            $code = 'USDC';
            $account = $this->account();
            $account['free'] = $this->safe_string($responseResult, 'availableBalance');
            $account['total'] = $this->safe_string($responseResult, 'walletBalance');
            $result[$code] = $account;
        } else {
            for ($i = 0; $i < count($currencyList); $i++) {
                $entry = $currencyList[$i];
                $account = $this->account();
                $loan = $this->safe_string($entry, 'loan');
                $interest = $this->safe_string($entry, 'interest');
                if (($loan !== null) && ($interest !== null)) {
                    $account['debt'] = Precise::string_add($loan, $interest);
                }
                $account['total'] = $this->safe_string_2($entry, 'total', 'walletBalance');
                $account['free'] = $this->safe_string_n($entry, array( 'free', 'availableBalanceWithoutConvert', 'availableBalance' ));
                $account['used'] = $this->safe_string($entry, 'locked');
                $currencyId = $this->safe_string_n($entry, array( 'tokenId', 'coin', 'currencyCoin' ));
                $code = $this->safe_currency_code($currencyId);
                $result[$code] = $account;
            }
        }
        return $this->safe_balance($result);
    }

    public function fetch_spot_balance($params = array ()) {
        $this->load_markets();
        $marginMode = null;
        list($marginMode, $params) = $this->handle_margin_mode_and_params('fetchBalance', $params);
        $method = 'privateGetSpotV3PrivateAccount';
        if ($marginMode !== null) {
            $method = 'privateGetSpotV3PrivateCrossMarginAccount';
        }
        $response = $this->$method ($params);
        // spot wallet
        //     {
        //       retCode => '0',
        //       retMsg => 'OK',
        //       result => {
        //         balances => array(
        //           array(
        //             coin => 'BTC',
        //             coinId => 'BTC',
        //             total => '0.00977041118',
        //             free => '0.00877041118',
        //             locked => '0.001'
        //           ),
        //           array(
        //             coin => 'EOS',
        //             coinId => 'EOS',
        //             total => '2000',
        //             free => '2000',
        //             locked => '0'
        //           }
        //         )
        //       ),
        //       retExtInfo => array(),
        //       time => '1670002625754'
        //     }
        // cross
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "success",
        //         "result" => array(
        //             "acctBalanceSum" => "0.122995614474732872",
        //             "debtBalanceSum" => "0.011734191124529754",
        //             "loanAccountList" => array(
        //                 array(
        //                     "free" => "0.001143855",
        //                     "interest" => "0",
        //                     "loan" => "0",
        //                     "locked" => "0",
        //                     "tokenId" => "BTC",
        //                     "total" => "0.001143855"
        //                 ),
        //                 array(
        //                     "free" => "200.00005568",
        //                     "interest" => "0.0008391",
        //                     "loan" => "200",
        //                     "locked" => "0",
        //                     "tokenId" => "USDT",
        //                     "total" => "200.00005568"
        //                 ),
        //             ),
        //             "riskRate" => "0.0954",
        //             "status" => 1
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => 1669843584123
        //     }
        //
        return $this->parse_balance($response);
    }

    public function fetch_unified_margin_balance($params = array ()) {
        $this->load_markets();
        $response = $this->privateGetUnifiedV3PrivateAccountWalletBalance ($params);
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "Success",
        //         "result" => {
        //             "totalEquity" => "112.21267421",
        //             "accountIMRate" => "0.6895",
        //             "totalMarginBalance" => "80.37711012",
        //             "totalInitialMargin" => "55.42180254",
        //             "totalAvailableBalance" => "24.95530758",
        //             "accountMMRate" => "0.0459",
        //             "totalPerpUPL" => "-16.69586570",
        //             "totalWalletBalance" => "97.07311619",
        //             "totalMaintenanceMargin" => "3.68580537",
        //             "coin" => array(
        //                 array(
        //                     "currencyCoin" => "ETH",
        //                     "availableToBorrow" => "0.00000000",
        //                     "borrowSize" => "0.00000000",
        //                     "bonus" => "0.00000000",
        //                     "accruedInterest" => "0.00000000",
        //                     "availableBalanceWithoutConvert" => "0.00000000",
        //                     "totalOrderIM" => "",
        //                     "equity" => "0.00000000",
        //                     "totalPositionMM" => "",
        //                     "usdValue" => "0.00000000",
        //                     "availableBalance" => "0.02441165",
        //                     "unrealisedPnl" => "",
        //                     "totalPositionIM" => "",
        //                     "marginBalanceWithoutConvert" => "0.00000000",
        //                     "walletBalance" => "0.00000000",
        //                     "cumRealisedPnl" => "",
        //                     "marginBalance" => "0.07862610"
        //                 }
        //             )
        //         ),
        //         "time" => 1657716037033
        //     }
        //
        return $this->parse_balance($response);
    }

    public function fetch_derivatives_balance($params = array ()) {
        $this->load_markets();
        $request = array();
        $response = $this->privateGetContractV3PrivateAccountWalletBalance (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => array(
        //             "list" => array(
        //                 array(
        //                     "coin" => "BTC",
        //                     "equity" => "0.00000002",
        //                     "walletBalance" => "0.00000002",
        //                     "positionMargin" => "0",
        //                     "availableBalance" => "0.00000002",
        //                     "orderMargin" => "0",
        //                     "occClosingFee" => "0",
        //                     "occFundingFee" => "0",
        //                     "unrealisedPnl" => "0",
        //                     "cumRealisedPnl" => "-0.00010941",
        //                     "givenCash" => "0",
        //                     "serviceCash" => "0"
        //                 ),
        //                 array(
        //                     "coin" => "USDT",
        //                     "equity" => "3662.81038535",
        //                     "walletBalance" => "3662.81038535",
        //                     "positionMargin" => "0",
        //                     "availableBalance" => "3662.81038535",
        //                     "orderMargin" => "0",
        //                     "occClosingFee" => "0",
        //                     "occFundingFee" => "0",
        //                     "unrealisedPnl" => "0",
        //                     "cumRealisedPnl" => "-36.01761465",
        //                     "givenCash" => "0",
        //                     "serviceCash" => "0"
        //                 ),
        //             )
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => 1669845599631
        //     }
        //
        return $this->parse_balance($response);
    }

    public function fetch_usdc_balance($params = array ()) {
        $this->load_markets();
        $response = $this->privatePostOptionUsdcOpenapiPrivateV1QueryWalletBalance ($params);
        //
        //    {
        //      "result" => array(
        //           "walletBalance" => "10.0000",
        //           "accountMM" => "0.0000",
        //           "bonus" => "0.0000",
        //           "accountIM" => "0.0000",
        //           "totalSessionRPL" => "0.0000",
        //           "equity" => "10.0000",
        //           "totalRPL" => "0.0000",
        //           "marginBalance" => "10.0000",
        //           "availableBalance" => "10.0000",
        //           "totalSessionUPL" => "0.0000"
        //       ),
        //       "retCode" => "0",
        //       "retMsg" => "Success."
        //    }
        //
        return $this->parse_balance($response);
    }

    public function fetch_balance($params = array ()) {
        /**
         * query for balance and get the amount of funds available for trading or funds locked in orders
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} a ~@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure balance structure~
         */
        $this->load_markets();
        $type = null;
        list($type, $params) = $this->handle_market_type_and_params('fetchBalance', null, $params);
        if ($type === 'spot') {
            return $this->fetch_spot_balance($params);
        }
        $enableUnifiedMargin = $this->is_unified_margin_enabled();
        if ($enableUnifiedMargin) {
            return $this->fetch_unified_margin_balance($params);
        } else {
            // linear/inverse future/swap
            return $this->fetch_derivatives_balance($params);
        }
    }

    public function parse_order_status($status) {
        $statuses = array(
            // v3 spot
            'NEW' => 'open',
            'PARTIALLY_FILLED' => 'open',
            'FILLED' => 'closed',
            'CANCELED' => 'canceled',
            'PENDING_CANCEL' => 'open',
            'PENDING_NEW' => 'open',
            'REJECTED' => 'rejected',
            // v3 contract / unified margin
            'Created' => 'open',
            'New' => 'open',
            'Rejected' => 'rejected', // order is triggered but failed upon being placed
            'PartiallyFilled' => 'open',
            'Filled' => 'closed',
            'PendingCancel' => 'open',
            'Cancelled' => 'canceled',
            // below this line the $status only pertains to conditional orders
            'Untriggered' => 'open',
            'Deactivated' => 'canceled',
            'Triggered' => 'open',
            'Active' => 'open',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_time_in_force($timeInForce) {
        $timeInForces = array(
            'GoodTillCancel' => 'GTC',
            'ImmediateOrCancel' => 'IOC',
            'FillOrKill' => 'FOK',
            'PostOnly' => 'PO',
        );
        return $this->safe_string($timeInForces, $timeInForce, $timeInForce);
    }

    public function parse_order($order, $market = null) {
        $orderCategoryExists = (is_array($order) && array_key_exists('orderCategory', $order));
        if ($orderCategoryExists) {
            return $this->parse_spot_order($order, $market);
        }
        return $this->parse_contract_order($order, $market);
    }

    public function parse_contract_order($order, $market = null) {
        //
        // contract v3
        //
        //     {
        //         "symbol" => "XRPUSDT",
        //         "side" => "Buy",
        //         "orderType" => "Market",
        //         "price" => "0.3431",
        //         "qty" => "65",
        //         "reduceOnly" => true,
        //         "timeInForce" => "ImmediateOrCancel",
        //         "orderStatus" => "Filled",
        //         "leavesQty" => "0",
        //         "leavesValue" => "0",
        //         "cumExecQty" => "65",
        //         "cumExecValue" => "21.3265",
        //         "cumExecFee" => "0.0127959",
        //         "lastPriceOnCreated" => "0.0000",
        //         "rejectReason" => "EC_NoError",
        //         "orderLinkId" => "",
        //         "createdTime" => "1657526321499",
        //         "updatedTime" => "1657526321504",
        //         "orderId" => "ac0a8134-acb3-4ee1-a2d4-41891c9c46d7",
        //         "stopOrderType" => "UNKNOWN",
        //         "takeProfit" => "0.0000",
        //         "stopLoss" => "0.0000",
        //         "tpTriggerBy" => "UNKNOWN",
        //         "slTriggerBy" => "UNKNOWN",
        //         "triggerPrice" => "0.0000",
        //         "closeOnTrigger" => true,
        //         "triggerDirection" => 0,
        //         "positionIdx" => 2
        //     }
        //
        $marketId = $this->safe_string($order, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $timestamp = $this->safe_integer($order, 'createdTime');
        $id = $this->safe_string($order, 'orderId');
        $type = $this->safe_string_lower($order, 'orderType');
        $price = $this->safe_string($order, 'price');
        $amount = $this->safe_string($order, 'qty');
        $cost = $this->safe_string($order, 'cumExecValue');
        $filled = $this->safe_string($order, 'cumExecQty');
        $remaining = $this->safe_string($order, 'leavesQty');
        $lastTradeTimestamp = $this->safe_integer($order, 'updateTime');
        $rawStatus = $this->safe_string($order, 'orderStatus');
        $status = $this->parse_order_status($rawStatus);
        $side = $this->safe_string_lower($order, 'side');
        $fee = null;
        $isContract = $this->safe_value($market, 'contract');
        if ($isContract) {
            $feeCostString = $this->safe_string($order, 'cumExecFee');
            if ($feeCostString !== null) {
                $fee = array(
                    'cost' => $feeCostString,
                    'currency' => $market['settle'],
                );
            }
        }
        $clientOrderId = $this->safe_string($order, 'orderLinkId');
        if (($clientOrderId !== null) && (strlen($clientOrderId) < 1)) {
            $clientOrderId = null;
        }
        $rawTimeInForce = $this->safe_string($order, 'timeInForce');
        $timeInForce = $this->parse_time_in_force($rawTimeInForce);
        $stopPrice = $this->omit_zero($this->safe_string($order, 'triggerPrice'));
        return $this->safe_order(array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $lastTradeTimestamp,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => null,
            'side' => $side,
            'price' => $price,
            'triggerPrice' => $stopPrice,
            'stopPrice' => $stopPrice,
            'amount' => $amount,
            'cost' => $cost,
            'average' => null,
            'filled' => $filled,
            'remaining' => $remaining,
            'status' => $status,
            'fee' => $fee,
            'trades' => null,
        ), $market);
    }

    public function parse_spot_order($order, $market = null) {
        //
        //  createOrder, cancelOrer
        //
        //     {
        //         "orderId" => "1274754916287346280",
        //         "orderLinkId" => "1666798627015730",
        //         "symbol" => "AAVEUSDT",
        //         "createTime" => "1666698629821",
        //         "orderPrice" => "80",
        //         "orderQty" => "0.11",
        //         "orderType" => "LIMIT",
        //         "side" => "BUY",
        //         "status" => "NEW",
        //         "timeInForce" => "GTC",
        //         "accountId" => "13380434",
        //         "execQty" => "0",
        //         "orderCategory" => "0"
        //     }
        //
        //     fetchOrder, fetchOpenOrders, fetchClosedOrders (and also for conditional orders) there are also present these additional fields:
        //     {
        //         "cummulativeQuoteQty" => "0",
        //         "avgPrice" => "0",
        //         "stopPrice" => "0.0",
        //         "icebergQty" => "0.0",
        //         "updateTime" => "1666733357444",
        //         "isWorking" => "1",
        //         "locked" => "8.8",
        //         "executedOrderId" => "1279094037543962113", // in conditional $order
        //         "triggerPrice" => "0.99", // in conditional $order
        //     }
        //
        $marketId = $this->safe_string($order, 'symbol');
        $market = $this->safe_market($marketId, $market);
        $timestamp = $this->safe_integer($order, 'createTime');
        $type = $this->safe_string_lower($order, 'orderType');
        $price = $this->safe_string($order, 'orderPrice');
        if ($price === '0' && $type === 'market') {
            $price = null;
        }
        $filled = $this->safe_string($order, 'execQty');
        $side = $this->safe_string_lower($order, 'side');
        $timeInForce = $this->parse_time_in_force($this->safe_string($order, 'timeInForce'));
        $triggerPrice = $this->safe_string($order, 'triggerPrice');
        $postOnly = ($timeInForce === 'PO');
        $amount = $this->safe_string($order, 'orderQty');
        if ($amount === null || $amount === '0') {
            if ($market['spot'] && $type === 'market' && $side === 'buy') {
                $amount = $filled;
            }
        }
        return $this->safe_order(array(
            'id' => $this->safe_string($order, 'orderId'),
            'clientOrderId' => $this->safe_string($order, 'orderLinkId'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $this->safe_integer($order, 'updateTime'),
            'symbol' => $market['symbol'],
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => $postOnly,
            'side' => $side,
            'price' => $price,
            'triggerPrice' => $triggerPrice,
            'stopPrice' => $triggerPrice, // deprecated field
            'amount' => $amount,
            'cost' => $this->safe_string($order, 'cummulativeQuoteQty'),
            'average' => $this->safe_string($order, 'avgPrice'),
            'filled' => $filled,
            'remaining' => null,
            'status' => $this->parse_order_status($this->safe_string($order, 'status')),
            'fee' => null,
            'trades' => null,
            'info' => $order,
        ), $market);
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        /**
         * fetches information on an order made by the user
         * @param {string|null} $symbol unified $symbol of the $market the order was made in
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} An {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structure}
         */
        $this->load_markets();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
        }
        $type = null;
        list($type, $params) = $this->handle_market_type_and_params('fetchOrder', $market, $params);
        if ($type === 'spot') {
            // only spot markets have a dedicated endpoint for fetching a order
            $request = array(
                'orderId' => $id,
            );
            $response = $this->privateGetSpotV3PrivateOrder (array_merge($params, $request));
            //
            //    {
            //        "retCode" => "0",
            //        "retMsg" => "OK",
            //        "result" => array(
            //            "accountId" => "13380434",
            //            "symbol" => "AAVEUSDT",
            //            "orderLinkId" => "1666733357434617",
            //            "orderId" => "1275046248585414144",
            //            "orderPrice" => "80",
            //            "orderQty" => "0.11",
            //            "execQty" => "0",
            //            "cummulativeQuoteQty" => "0",
            //            "avgPrice" => "0",
            //            "status" => "NEW",
            //            "timeInForce" => "GTC",
            //            "orderType" => "LIMIT",
            //            "side" => "BUY",
            //            "stopPrice" => "0.0",
            //            "icebergQty" => "0.0",
            //            "createTime" => "1666733357438",
            //            "updateTime" => "1666733357444",
            //            "isWorking" => "1",
            //            "locked" => "8.8",
            //            "orderCategory" => "0"
            //        ),
            //        "retExtMap" => array(),
            //        "retExtInfo" => null,
            //        "time" => "1666733357744"
            //    }
            //
            $result = $this->safe_value($response, 'result', array());
            return $this->parse_order($result, $market);
        } else {
            if ($market === null) {
                throw new ArgumentsRequired($this->id . ' fetchOrder() requires a $symbol argument for ' . $type . ' markets');
            }
            $request = array(
                'orderId' => $id,
            );
            $result = $this->fetch_orders($symbol, null, null, array_merge($request, $params));
            $length = count($result);
            if ($length > 1) {
                throw new InvalidOrder($this->id . ' returned more than one order');
            }
            return $this->safe_value($result, 0);
        }
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        /**
         * create a trade order
         * @param {string} $symbol unified $symbol of the $market to create an order in
         * @param {string} $type 'market' or 'limit'
         * @param {string} $side 'buy' or 'sell'
         * @param {float} $amount how much of currency you want to trade in units of base currency
         * @param {float|null} $price the $price at which the order is to be fullfilled, in units of the quote currency, ignored in $market orders
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} an {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structure}
         */
        $this->load_markets();
        $market = $this->market($symbol);
        $symbol = $market['symbol'];
        $enableUnifiedMargin = $this->is_unified_margin_enabled();
        $isUSDCSettled = $market['settle'] === 'USDC';
        if ($market['spot']) {
            return $this->create_spot_order($symbol, $type, $side, $amount, $price, $params);
        } elseif ($enableUnifiedMargin && !$market['inverse']) {
            return $this->create_unified_margin_order($symbol, $type, $side, $amount, $price, $params);
        } elseif ($isUSDCSettled) {
            return $this->create_usdc_order($symbol, $type, $side, $amount, $price, $params);
        } else {
            return $this->create_contract_v3_order($symbol, $type, $side, $amount, $price, $params);
        }
    }

    public function create_spot_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        if (($type === 'market') && ($side === 'buy')) {
            // for $market buy it requires the $amount of quote currency to spend
            if ($this->options['createMarketBuyOrderRequiresPrice']) {
                $cost = $this->safe_number($params, 'cost');
                $params = $this->omit($params, 'cost');
                if ($price === null && $cost === null) {
                    throw new InvalidOrder($this->id . " createOrder() requires the $price argument with $market buy orders to calculate total $order $cost ($amount to spend), where $cost = $amount * $price-> Supply a $price argument to createOrder() call if you want the $cost to be calculated for you from $price and $amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the $cost in the $amount argument (the exchange-specific behaviour)");
                } else {
                    $amountString = $this->number_to_string($amount);
                    $priceString = $this->number_to_string($price);
                    $quoteAmount = Precise::string_mul($amountString, $priceString);
                    $amount = ($cost !== null) ? $cost : $this->parse_number($quoteAmount);
                }
            }
        }
        $upperCaseType = strtoupper($type);
        $request = array(
            'symbol' => $market['id'],
            'side' => $this->capitalize($side),
            'orderType' => $upperCaseType, // limit, $market or limit_maker
            'timeInForce' => 'GTC', // FOK, IOC
            'orderQty' => $this->amount_to_precision($symbol, $amount),
            // 'orderLinkId' => 'string', // unique client $order id, max 36 characters
        );
        if (($upperCaseType === 'LIMIT') || ($upperCaseType === 'LIMIT_MAKER')) {
            if ($price === null) {
                throw new InvalidOrder($this->id . ' createOrder requires a $price argument for a ' . $type . ' order');
            }
            $request['orderPrice'] = $this->price_to_precision($symbol, $price);
        }
        $isPostOnly = $this->is_post_only($upperCaseType === 'MARKET', $type === 'LIMIT_MAKER', $params);
        if ($isPostOnly) {
            $request['orderType'] = 'LIMIT_MAKER';
        }
        $clientOrderId = $this->safe_string_2($params, 'clientOrderId', 'orderLinkId');
        if ($clientOrderId !== null) {
            $request['orderLinkId'] = $clientOrderId;
        }
        $params = $this->omit($params, array( 'clientOrderId', 'orderLinkId', 'postOnly' ));
        $brokerId = $this->safe_string($this->options, 'brokerId');
        if ($brokerId !== null) {
            $request['agentSource'] = $brokerId;
        }
        $triggerPrice = $this->safe_number_2($params, 'triggerPrice', 'stopPrice');
        if ($triggerPrice !== null) {
            $params['triggerPrice'] = $this->price_to_precision($symbol, $triggerPrice);
        }
        $params = $this->omit($params, 'stopPrice');
        $response = $this->privatePostSpotV3PrivateOrder (array_merge($request, $params));
        //
        //    {
        //        "retCode" => "0",
        //        "retMsg" => "OK",
        //        "result" => array(
        //            "orderId" => "1274754916287346280",
        //            "orderLinkId" => "1666798627015730",
        //            "symbol" => "AAVEUSDT",
        //            "createTime" => "1666698629821",
        //            "orderPrice" => "80",
        //            "orderQty" => "0.11",
        //            "orderType" => "LIMIT",
        //            "side" => "BUY",
        //            "status" => "NEW",
        //            "timeInForce" => "GTC",
        //            "accountId" => "13380434",
        //            "execQty" => "0",
        //            "orderCategory" => "0"
        //        ),
        //        "retExtMap" => array(),
        //        "retExtInfo" => null,
        //        "time" => "1666698627926"
        //    }
        //
        $order = $this->safe_value($response, 'result', array());
        return $this->parse_order($order);
    }

    public function create_unified_margin_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        if (!$market['linear'] && !$market['option']) {
            throw new NotSupported($this->id . ' createOrder does not allow inverse $market orders for ' . $symbol . ' markets');
        }
        if ($price === null && $type === 'limit') {
            throw new ArgumentsRequired($this->id . ' createOrder requires a $price argument for limit orders');
        }
        $lowerCaseType = strtolower($type);
        $request = array(
            'symbol' => $market['id'],
            'side' => $this->capitalize($side),
            'orderType' => $this->capitalize($lowerCaseType), // limit or $market
            'timeInForce' => 'GoodTillCancel', // ImmediateOrCancel, FillOrKill, PostOnly
            'qty' => $this->amount_to_precision($symbol, $amount),
            // 'takeProfit' => 123.45, // take profit $price, only take effect upon opening the position
            // 'stopLoss' => 123.45, // stop loss $price, only take effect upon opening the position
            // 'reduceOnly' => false, // reduce only, required for linear orders
            // when creating a closing $order, bybit recommends a True value for
            //  closeOnTrigger to avoid failing due to insufficient available margin
            // 'closeOnTrigger' => false, required for linear orders
            // 'orderLinkId' => 'string', // unique client $order id, max 36 characters
            // 'triggerPrice' => 123.45, // trigger $price, required for conditional orders
            // 'triggerBy' => 'MarkPrice', // IndexPrice, MarkPrice
            // 'tptriggerby' => 'MarkPrice', // IndexPrice, MarkPrice
            // 'slTriggerBy' => 'MarkPrice', // IndexPrice, MarkPrice
            // 'mmp' => false // $market maker protection
            // 'positionIdx' => 0, // Position mode. unified margin account is only available in One-Way mode, which is 0
            // 'basePrice' => '0', // It will be used to compare with the value of $triggerPrice, to decide whether your conditional $order will be triggered by crossing trigger $price from upper $side or lower $side-> Mainly used to identify the expected direction of the current conditional $order->
            // 'iv' => '0', // Implied volatility, for options only; parameters are passed according to the real value; for example, for 10%, 0.1 is passed
        );
        if ($market['linear']) {
            $request['category'] = 'linear';
        } else {
            $request['category'] = 'option';
        }
        $isMarket = $lowerCaseType === 'market';
        $isLimit = $lowerCaseType === 'limit';
        if ($isLimit) {
            $request['price'] = $this->price_to_precision($symbol, $price);
        }
        $exchangeSpecificParam = $this->safe_string($params, 'time_in_force');
        $timeInForce = $this->safe_string_lower($params, 'timeInForce');
        $postOnly = $this->is_post_only($isMarket, $exchangeSpecificParam === 'PostOnly', $params);
        if ($postOnly) {
            $request['timeInForce'] = 'PostOnly';
        } elseif ($timeInForce === 'gtc') {
            $request['timeInForce'] = 'GoodTillCancel';
        } elseif ($timeInForce === 'fok') {
            $request['timeInForce'] = 'FillOrKill';
        } elseif ($timeInForce === 'ioc') {
            $request['timeInForce'] = 'ImmediateOrCancel';
        }
        $triggerPrice = $this->safe_value_2($params, 'stopPrice', 'triggerPrice');
        $stopLossPrice = $this->safe_value($params, 'stopLossPrice', $triggerPrice);
        $isStopLossOrder = $stopLossPrice !== null;
        $takeProfitPrice = $this->safe_value($params, 'takeProfitPrice');
        $isTakeProfitOrder = $takeProfitPrice !== null;
        if ($isStopLossOrder || $isTakeProfitOrder) {
            $request['triggerBy'] = 'LastPrice';
            $triggerAt = $isStopLossOrder ? $stopLossPrice : $takeProfitPrice;
            $preciseTriggerPrice = $this->price_to_precision($symbol, $triggerAt);
            $request['triggerPrice'] = $preciseTriggerPrice;
            $isBuy = $side === 'buy';
            // logical xor
            $ascending = $stopLossPrice ? !$isBuy : $isBuy;
            $delta = $this->number_to_string($market['precision']['price']);
            $request['basePrice'] = $ascending ? Precise::string_add($preciseTriggerPrice, $delta) : Precise::string_sub($preciseTriggerPrice, $delta);
        }
        $clientOrderId = $this->safe_string($params, 'clientOrderId');
        if ($clientOrderId !== null) {
            $request['orderLinkId'] = $clientOrderId;
        } elseif ($market['option']) {
            // mandatory field for options
            $request['orderLinkId'] = $this->uuid16();
        }
        $params = $this->omit($params, array( 'stopPrice', 'timeInForce', 'triggerPrice', 'stopLossPrice', 'takeProfitPrice', 'postOnly', 'clientOrderId' ));
        $response = $this->privatePostUnifiedV3PrivateOrderCreate (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => array(
        //             "orderId" => "e10b0716-7c91-4091-b98a-1fa0f401c7d5",
        //             "orderLinkId" => "test0000003"
        //         ),
        //         "retExtInfo" => null,
        //         "time" => 1664441344238
        //     }
        //
        $order = $this->safe_value($response, 'result', array());
        return $this->parse_order($order);
    }

    public function create_contract_v3_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        if (($price === null) && ($type === 'limit')) {
            throw new ArgumentsRequired($this->id . ' createContractV3Order requires a $price argument for limit orders');
        }
        $lowerCaseType = strtolower($type);
        $request = array(
            'symbol' => $market['id'],
            'side' => $this->capitalize($side),
            'orderType' => $this->capitalize($lowerCaseType), // limit or $market
            'timeInForce' => 'GoodTillCancel', // ImmediateOrCancel, FillOrKill, PostOnly
            'qty' => $this->amount_to_precision($symbol, $amount),
            // 'takeProfit' => 123.45, // take profit $price, only take effect upon opening the position
            // 'stopLoss' => 123.45, // stop loss $price, only take effect upon opening the position
            // 'reduceOnly' => false, // reduce only, required for linear orders
            // when creating a closing $order, bybit recommends a True value for
            //  closeOnTrigger to avoid failing due to insufficient available margin
            // 'closeOnTrigger' => false, required for linear orders
            // 'orderLinkId' => 'string', // unique client $order id, max 36 characters
            // 'triggerPrice' => 123.45, // trigger $price, required for conditional orders
            // 'triggerBy' => 'MarkPrice', // IndexPrice, MarkPrice
            // 'tptriggerby' => 'MarkPrice', // IndexPrice, MarkPrice
            // 'slTriggerBy' => 'MarkPrice', // IndexPrice, MarkPrice
            // 'positionIdx' => 0, // Position mode. unified margin account is only available in One-Way mode, which is 0
            // 'triggerDirection' => 1, // Trigger direction. Mainly used in conditional $order-> Trigger the $order when $market $price rises to $triggerPrice or falls to $triggerPrice-> 1 => rise; 2 => fall
        );
        if ($market['future']) {
            $positionIdx = $this->safe_integer($params, 'position_idx', 0); // 0 One-Way Mode, 1 Buy-$side, 2 Sell-$side
            $request['position_idx'] = $positionIdx;
            $params = $this->omit($params, 'position_idx');
        }
        $isMarket = $lowerCaseType === 'market';
        $isLimit = $lowerCaseType === 'limit';
        if ($isLimit) {
            $request['price'] = $this->price_to_precision($symbol, $price);
        }
        $exchangeSpecificParam = $this->safe_string($params, 'time_in_force');
        $timeInForce = $this->safe_string_lower($params, 'timeInForce');
        $postOnly = $this->is_post_only($isMarket, $exchangeSpecificParam === 'PostOnly', $params);
        if ($postOnly) {
            $request['timeInForce'] = 'PostOnly';
        } elseif ($timeInForce === 'gtc') {
            $request['timeInForce'] = 'GoodTillCancel';
        } elseif ($timeInForce === 'fok') {
            $request['timeInForce'] = 'FillOrKill';
        } elseif ($timeInForce === 'ioc') {
            $request['timeInForce'] = 'ImmediateOrCancel';
        }
        $triggerPrice = $this->safe_value_2($params, 'stopPrice', 'triggerPrice');
        $stopLossPrice = $this->safe_value($params, 'stopLossPrice', $triggerPrice);
        $isStopLossOrder = $stopLossPrice !== null;
        $takeProfitPrice = $this->safe_value($params, 'takeProfitPrice');
        $isTakeProfitOrder = $takeProfitPrice !== null;
        if ($isStopLossOrder || $isTakeProfitOrder) {
            $triggerAt = $isStopLossOrder ? $stopLossPrice : $takeProfitPrice;
            $preciseTriggerPrice = $this->price_to_precision($symbol, $triggerAt);
            $isBuy = $side === 'buy';
            // logical xor
            $ascending = $stopLossPrice ? !$isBuy : $isBuy;
            $request['triggerDirection'] = $ascending ? 2 : 1;
            $request['triggerBy'] = 'LastPrice';
            $request['triggerPrice'] = $this->price_to_precision($symbol, $preciseTriggerPrice);
        }
        $clientOrderId = $this->safe_string($params, 'clientOrderId');
        if ($clientOrderId !== null) {
            $request['orderLinkId'] = $clientOrderId;
        } elseif ($market['option']) {
            // mandatory field for options
            $request['orderLinkId'] = $this->uuid16();
        }
        $params = $this->omit($params, array( 'stopPrice', 'timeInForce', 'triggerPrice', 'stopLossPrice', 'takeProfitPrice', 'postOnly', 'clientOrderId' ));
        $response = $this->privatePostContractV3PrivateOrderCreate (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => array(
        //             "orderId" => "e10b0716-7c91-4091-b98a-1fa0f401c7d5",
        //             "orderLinkId" => "test0000003"
        //         ),
        //         "retExtInfo" => null,
        //         "time" => 1664441344238
        //     }
        //
        $order = $this->safe_value($response, 'result', array());
        return $this->parse_order($order);
    }

    public function create_usdc_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        if ($type === 'market') {
            throw new NotSupported($this->id . 'createOrder does not allow $market orders for ' . $symbol . ' markets');
        }
        if ($price === null && $type === 'limit') {
            throw new ArgumentsRequired($this->id . ' createOrder requires a $price argument for limit orders');
        }
        $lowerCaseType = strtolower($type);
        $request = array(
            'symbol' => $market['id'],
            'side' => $this->capitalize($side),
            'orderType' => $this->capitalize($lowerCaseType), // limit or $market
            'timeInForce' => 'GoodTillCancel', // ImmediateOrCancel, FillOrKill, PostOnly
            'orderQty' => $this->amount_to_precision($symbol, $amount),
            // 'takeProfit' => 123.45, // take profit $price, only take effect upon opening the position
            // 'stopLoss' => 123.45, // stop loss $price, only take effect upon opening the position
            // 'reduceOnly' => false, // reduce only, required for linear orders
            // when creating a closing $order, bybit recommends a True value for
            //  closeOnTrigger to avoid failing due to insufficient available margin
            // 'closeOnTrigger' => false, required for linear orders
            // 'orderLinkId' => 'string', // unique client $order id, max 36 characters
            // 'triggerPrice' => 123.45, // trigger $price, required for conditional orders
            // 'trigger_by' => 'MarkPrice', // IndexPrice, MarkPrice
            // 'tptriggerby' => 'MarkPrice', // IndexPrice, MarkPrice
            // 'slTriggerBy' => 'MarkPrice', // IndexPrice, MarkPrice
            // 'orderFilter' => 'Order' or 'StopOrder'
            // 'mmp' => false // $market maker protection
        );
        $isMarket = $lowerCaseType === 'market';
        $isLimit = $lowerCaseType === 'limit';
        if ($isLimit !== null) {
            $request['orderPrice'] = $this->price_to_precision($symbol, $price);
        }
        $exchangeSpecificParam = $this->safe_string($params, 'time_in_force');
        $timeInForce = $this->safe_string_lower($params, 'timeInForce');
        $postOnly = $this->is_post_only($isMarket, $exchangeSpecificParam === 'PostOnly', $params);
        if ($postOnly) {
            $request['time_in_force'] = 'PostOnly';
        } elseif ($timeInForce === 'gtc') {
            $request['time_in_force'] = 'GoodTillCancel';
        } elseif ($timeInForce === 'fok') {
            $request['time_in_force'] = 'FillOrKill';
        } elseif ($timeInForce === 'ioc') {
            $request['time_in_force'] = 'ImmediateOrCancel';
        }
        if ($market['swap']) {
            $triggerPrice = $this->safe_value_2($params, 'stopPrice', 'triggerPrice');
            $stopLossPrice = $this->safe_value($params, 'stopLossPrice', $triggerPrice);
            $isStopLossOrder = $stopLossPrice !== null;
            $takeProfitPrice = $this->safe_value($params, 'takeProfitPrice');
            $isTakeProfitOrder = $takeProfitPrice !== null;
            $isStopOrder = $isStopLossOrder || $isTakeProfitOrder;
            if ($isStopOrder) {
                $request['orderFilter'] = 'StopOrder';
                $request['trigger_by'] = 'LastPrice';
                $stopPx = $isStopLossOrder ? $stopLossPrice : $takeProfitPrice;
                $preciseStopPrice = $this->price_to_precision($symbol, $stopPx);
                $request['triggerPrice'] = $preciseStopPrice;
                $delta = $this->number_to_string($market['precision']['price']);
                $request['basePrice'] = $isStopLossOrder ? Precise::string_sub($preciseStopPrice, $delta) : Precise::string_add($preciseStopPrice, $delta);
            } else {
                $request['orderFilter'] = 'Order';
            }
        }
        $clientOrderId = $this->safe_string($params, 'clientOrderId');
        if ($clientOrderId !== null) {
            $request['orderLinkId'] = $clientOrderId;
        } elseif ($market['option']) {
            // mandatory field for options
            $request['orderLinkId'] = $this->uuid16();
        }
        $params = $this->omit($params, array( 'stopPrice', 'timeInForce', 'triggerPrice', 'stopLossPrice', 'takeProfitPrice', 'postOnly', 'clientOrderId' ));
        $method = $market['option'] ? 'privatePostOptionUsdcOpenapiPrivateV1PlaceOrder' : 'privatePostPerpetualUsdcOpenapiPrivateV1PlaceOrder';
        $response = $this->$method (array_merge($request, $params));
        //
        //     {
        //         "retCode":0,
        //         "retMsg":"",
        //         "result":{
        //            "orderId":"34450a59-325e-4296-8af0-63c7c524ae33",
        //            "orderLinkId":"",
        //            "mmp":false,
        //            "symbol":"BTCPERP",
        //            "orderType":"Limit",
        //            "side":"Buy",
        //            "orderQty":"0.00100000",
        //            "orderPrice":"20000.00",
        //            "iv":"0",
        //            "timeInForce":"GoodTillCancel",
        //            "orderStatus":"Created",
        //            "createdAt":"1652261746007873",
        //            "basePrice":"0.00",
        //            "triggerPrice":"0.00",
        //            "takeProfit":"0.00",
        //            "stopLoss":"0.00",
        //            "slTriggerBy":"UNKNOWN",
        //            "tpTriggerBy":"UNKNOWN"
        //     }
        //
        $order = $this->safe_value($response, 'result', array());
        return $this->parse_order($order);
    }

    public function edit_unified_margin_order($id, $symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        if (!$market['linear'] && !$market['option']) {
            throw new NotSupported($this->id . ' editOrder does not allow inverse $market orders for ' . $symbol . ' markets');
        }
        if ($price === null && $type === 'limit') {
            throw new ArgumentsRequired($this->id . ' editOrder requires a $price argument for limit orders');
        }
        $lowerCaseType = strtolower($type);
        $request = array(
            'orderId' => $id,
            'symbol' => $market['id'],
            'side' => $this->capitalize($side),
            'orderType' => $this->capitalize($lowerCaseType), // limit or $market
            'timeInForce' => 'GoodTillCancel', // ImmediateOrCancel, FillOrKill, PostOnly
            'qty' => $this->amount_to_precision($symbol, $amount),
            // 'takeProfit' => 123.45, // take profit $price, only take effect upon opening the position
            // 'stopLoss' => 123.45, // stop loss $price, only take effect upon opening the position
            // 'orderLinkId' => 'string', // unique client $order $id, max 36 characters
            // 'triggerPrice' => 123.45, // trigger $price, required for conditional orders
            // 'triggerBy' => 'MarkPrice', // IndexPrice, MarkPrice
            // 'tptriggerby' => 'MarkPrice', // IndexPrice, MarkPrice
            // 'slTriggerBy' => 'MarkPrice', // IndexPrice, MarkPrice
            // 'iv' => '0', // Implied volatility, for options only; parameters are passed according to the real value; for example, for 10%, 0.1 is passed
        );
        if ($market['linear']) {
            $request['category'] = 'linear';
        } else {
            $request['category'] = 'option';
        }
        $isMarket = $lowerCaseType === 'market';
        $isLimit = $lowerCaseType === 'limit';
        if ($isLimit) {
            $request['price'] = $this->price_to_precision($symbol, $price);
        }
        $exchangeSpecificParam = $this->safe_string($params, 'time_in_force');
        $timeInForce = $this->safe_string_lower($params, 'timeInForce');
        $postOnly = $this->is_post_only($isMarket, $exchangeSpecificParam === 'PostOnly', $params);
        if ($postOnly) {
            $request['timeInForce'] = 'PostOnly';
        } elseif ($timeInForce === 'gtc') {
            $request['timeInForce'] = 'GoodTillCancel';
        } elseif ($timeInForce === 'fok') {
            $request['timeInForce'] = 'FillOrKill';
        } elseif ($timeInForce === 'ioc') {
            $request['timeInForce'] = 'ImmediateOrCancel';
        }
        $triggerPrice = $this->safe_value_2($params, 'stopPrice', 'triggerPrice');
        $stopLossPrice = $this->safe_value($params, 'stopLossPrice');
        $isStopLossOrder = $stopLossPrice !== null;
        $takeProfitPrice = $this->safe_value($params, 'takeProfitPrice');
        $isTakeProfitOrder = $takeProfitPrice !== null;
        if ($isStopLossOrder) {
            $request['stopLoss'] = $this->price_to_precision($symbol, $stopLossPrice);
        }
        if ($isTakeProfitOrder) {
            $request['takeProfit'] = $this->price_to_precision($symbol, $takeProfitPrice);
        }
        if ($triggerPrice !== null) {
            $request['triggerBy'] = 'LastPrice';
            $request['triggerPrice'] = $this->price_to_precision($symbol, $triggerPrice);
        }
        $clientOrderId = $this->safe_string($params, 'clientOrderId');
        if ($clientOrderId !== null) {
            $request['orderLinkId'] = $clientOrderId;
        }
        $params = $this->omit($params, array( 'stopPrice', 'timeInForce', 'triggerPrice', 'stopLossPrice', 'takeProfitPrice', 'postOnly', 'clientOrderId' ));
        $response = $this->privatePostUnifiedV3PrivateOrderReplace (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => {
        //             "orderId" => "42c86d66331e41998d12c2440ce90c1a",
        //             "orderLinkId" => "e80d558e-ed"
        //         }
        //     }
        //
        $order = $this->safe_value($response, 'result', array());
        return $this->parse_order($order);
    }

    public function edit_contract_v3_order($id, $symbol, $type, $side, $amount = null, $price = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'orderId' => $id,
            'qty' => $this->amount_to_precision($symbol, $amount),
        );
        if ($price !== null) {
            $request['price'] = $this->price_to_precision($symbol, $price);
        }
        $triggerPrice = $this->safe_value_2($params, 'stopPrice', 'triggerPrice');
        $stopLossPrice = $this->safe_value($params, 'stopLossPrice');
        $isStopLossOrder = $stopLossPrice !== null;
        $takeProfitPrice = $this->safe_value($params, 'takeProfitPrice');
        $isTakeProfitOrder = $takeProfitPrice !== null;
        if ($isStopLossOrder) {
            $request['stopLoss'] = $this->price_to_precision($symbol, $stopLossPrice);
        }
        if ($isTakeProfitOrder) {
            $request['takeProfit'] = $this->price_to_precision($symbol, $takeProfitPrice);
        }
        if ($triggerPrice !== null) {
            $request['triggerPrice'] = $this->price_to_precision($symbol, $triggerPrice);
        }
        $params = $this->omit($params, array( 'stopPrice', 'triggerPrice', 'stopLossPrice', 'takeProfitPrice' ));
        $response = $this->privatePostContractV3PrivateOrderReplace (array_merge($request, $params));
        //
        // contract v3
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => array(
        //             "orderId" => "db8b74b3-72d3-4264-bf3f-52d39b41956e",
        //             "orderLinkId" => "x002"
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => 1658902610749
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        return array(
            'info' => $response,
            'id' => $this->safe_string($result, 'orderId'),
        );
    }

    public function edit_order($id, $symbol, $type, $side, $amount = null, $price = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' editOrder() requires an $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $enableUnifiedMargin = $this->is_unified_margin_enabled();
        if ($market['spot']) {
            throw new NotSupported($this->id . ' editOrder() does not support spot markets');
        } elseif ($enableUnifiedMargin && !$market['inverse']) {
            return $this->edit_unified_margin_order($id, $symbol, $type, $side, $amount, $price, $params);
        }
        return $this->edit_contract_v3_order($id, $symbol, $type, $side, $amount, $price, $params);
    }

    public function cancel_spot_order($id, $symbol = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            // 'order_link_id' => 'string', // one of order_id, stop_order_id or order_link_id is required
            // 'orderId' => $id
        );
        if ($id !== null) { // The user can also use argument $params["order_link_id"]
            $request['orderId'] = $id;
        }
        $response = $this->privatePostSpotV3PrivateCancelOrder (array_merge($request, $params));
        //
        //     {
        //         "retCode" => "0",
        //         "retMsg" => "OK",
        //         "result" => array(
        //             "orderId" => "1275046248585414144",
        //             "orderLinkId" => "1666733357434617",
        //             "symbol" => "AAVEUSDT",
        //             "status" => "NEW",
        //             "accountId" => "13380434",
        //             "createTime" => "1666733357438",
        //             "orderPrice" => "80",
        //             "orderQty" => "0.11",
        //             "execQty" => "0",
        //             "timeInForce" => "GTC",
        //             "orderType" => "LIMIT",
        //             "side" => "BUY",
        //             "orderCategory" => "0"
        //         ),
        //         "retExtMap" => array(),
        //         "retExtInfo" => null,
        //         "time" => "1666733839493"
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        return $this->parse_order($result, $market);
    }

    public function cancel_unified_margin_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelUnifiedMarginOrder() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            // 'orderLinkId' => 'string',
            // 'orderId' => $id,
            // conditional orders
            // 'orderFilter' => '',
            // 'category' => '',
        );
        $isStop = $this->safe_value($params, 'stop', false);
        $params = $this->omit($params, array( 'stop' ));
        $request['orderFilter'] = $isStop ? 'StopOrder' : 'Order';
        if ($id !== null) { // The user can also use argument $params["orderLinkId"]
            $request['orderId'] = $id;
        }
        if ($market['option']) {
            $request['category'] = 'option';
        } elseif ($market['linear']) {
            $request['category'] = 'linear';
        } else {
            throw new NotSupported($this->id . ' cancelUnifiedMarginOrder() does not allow inverse $market orders for ' . $symbol . ' markets');
        }
        $response = $this->privatePostUnifiedV3PrivateOrderCancel (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => {
        //             "orderId" => "42c86d66331e41998d12c2440ce90c1a",
        //             "orderLinkId" => "e80d558e-ed"
        //         }
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        return $this->parse_order($result, $market);
    }

    public function cancel_usdc_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelUSDCOrder() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            // 'orderLinkId' => 'string', // one of order_id, stop_order_id or order_link_id is required
            // 'orderId' => $id,
        );
        $isStop = $this->safe_value($params, 'stop', false);
        $params = $this->omit($params, array( 'stop' ));
        $method = null;
        if ($id !== null) { // The user can also use argument $params["order_link_id"]
            $request['orderId'] = $id;
        }
        if ($market['option']) {
            $method = 'privatePostOptionUsdcOpenapiPrivateV1CancelOrder';
        } else {
            $method = 'privatePostPerpetualUsdcOpenapiPrivateV1CancelOrder';
            $request['orderFilter'] = $isStop ? 'StopOrder' : 'Order';
        }
        $response = $this->$method (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => array(
        //             "outRequestId" => "",
        //             "symbol" => "BTC-13MAY22-40000-C",
        //             "orderId" => "8c65df91-91fc-461d-9b14-786379ef138c",
        //             "orderLinkId" => ""
        //         ),
        //         "retExtMap" => array()
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        return $this->parse_order($result, $market);
    }

    public function cancel_derivatives_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelDerivativesOrder() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'orderId' => $id,
        );
        $response = $this->privatePostContractV3PrivateOrderCancel (array_merge($request, $params));
        //
        // contract v3
        //
        //     {
        //         "retCode":0,
        //         "retMsg":"OK",
        //         "result":array(
        //             "orderId" => "4030430d-1dba-4134-ac77-3d81c14aaa00",
        //             "orderLinkId" => ""
        //         ),
        //         "retExtInfo":null,
        //         "time":1658850321861
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        return $this->parse_order($result, $market);
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        /**
         * cancels an open order
         * @param {string} $id order $id
         * @param {string} $symbol unified $symbol of the $market the order was made in
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} An {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structure}
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $enableUnifiedMargin = $this->is_unified_margin_enabled();
        $isUsdcSettled = $market['settle'] === 'USDC';
        if ($market['spot']) {
            return $this->cancel_spot_order($id, $symbol, $params);
        } elseif ($enableUnifiedMargin && !$market['inverse']) {
            return $this->cancel_unified_margin_order($id, $symbol, $params);
        } elseif ($isUsdcSettled) {
            return $this->cancel_usdc_order($id, $symbol, $params);
        }
        return $this->cancel_derivatives_order($id, $symbol, $params);
    }

    public function cancel_all_spot_orders($symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelAllSpotOrders() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = $this->privateDeleteSpotOrderBatchCancel (array_merge($request, $params));
        //
        //    {
        //        "ret_code" => 0,
        //        "ret_msg" => "",
        //        "ext_code" => null,
        //        "ext_info" => null,
        //        "result" => {
        //            "success" => true
        //        }
        //    }
        //
        $result = $this->safe_value($response, 'result', array());
        if (gettype($result) !== 'array' || array_keys($result) !== array_keys(array_keys($result))) {
            return $response;
        }
        return $this->parse_orders($result, $market);
    }

    public function cancel_all_unified_margin_orders($symbol = null, $params = array ()) {
        $this->load_markets();
        $market = null;
        $settle = null;
        $request = array();
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $settle = $market['settle'];
            $request['symbol'] = $market['id'];
        }
        $subType = null;
        list($subType, $params) = $this->handle_sub_type_and_params('cancelAllOrders', $market, $params);
        $request['category'] = $subType;
        list($settle, $params) = $this->handle_option_and_params($params, 'cancelAllOrders', 'settle', $settle);
        if ($settle !== null) {
            $request['settleCoin'] = $settle;
        }
        $isStop = $this->safe_value($params, 'stop', false);
        $params = $this->omit($params, array( 'stop' ));
        if ($isStop) {
            $request['orderFilter'] = 'StopOrder';
        }
        $response = $this->privatePostUnifiedV3PrivateOrderCancelAll (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => {
        //             "list" => [array(
        //                     "category" => "option",
        //                     "symbol" => "BTC-24JUN22-45000-P",
        //                     "orderId" => "bd5f3b34-d64d-4b60-8188-438fbea4c552",
        //                     "orderLinkId" => "ac4e3b34-d64d-4b60-8188-438fbea4c552",
        //                 ), array(
        //                     "category" => "option",
        //                     "symbol" => "BTC-24JUN22-45000-P",
        //                     "orderId" => "4ddd727a-2af8-430e-a293-42895e594d18",
        //                     "orderLinkId" => "5cee727a-2af8-430e-a293-42895e594d18",
        //                 }
        //             ]
        //         ),
        //         "retExtInfo" => array(
        //             "list" => [array(
        //                 "code" => 0,
        //                 "msg" => "OK"
        //             ), array(
        //                 "code" => 0,
        //                 "msg" => "OK"
        //             )]
        //         ),
        //         "time" => 1657200736570
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $orders = $this->safe_value($result, 'list');
        if (gettype($orders) !== 'array' || array_keys($orders) !== array_keys(array_keys($orders))) {
            return $response;
        }
        return $this->parse_orders($orders, $market);
    }

    public function cancel_all_usdc_orders($symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelAllUSDCOrders() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $method = null;
        $request = array(
            'symbol' => $market['id'],
        );
        if ($market['option']) {
            $method = 'privatePostOptionUsdcOpenapiPrivateV1CancelAll';
        } else {
            $method = 'privatePostPerpetualUsdcOpenapiPrivateV1CancelAll';
            $isStop = $this->safe_value($params, 'stop', false);
            if ($isStop) {
                $request['orderFilter'] = 'StopOrder';
            } else {
                $request['orderFilter'] = 'Order';
            }
            $params = $this->omit($params, array( 'stop' ));
        }
        $response = $this->$method (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "retExtMap" => array(),
        //         "result" => array(
        //             {
        //                 "outRequestId" => "cancelAll-290119-1652176443114-0",
        //                 "symbol" => "BTC-13MAY22-40000-C",
        //                 "orderId" => "fa6cd740-56ed-477d-9385-90ccbfee49ca",
        //                 "orderLinkId" => "",
        //                 "errorCode" => 0,
        //                 "errorDesc" => ""
        //             }
        //         )
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        if (gettype($result) !== 'array' || array_keys($result) !== array_keys(array_keys($result))) {
            return $response;
        }
        return $this->parse_orders($result, $market);
    }

    public function cancel_all_derivatives_orders($symbol = null, $params = array ()) {
        $this->load_markets();
        $market = null;
        $settle = null;
        $request = array();
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $settle = $market['settle'];
            $request['symbol'] = $market['id'];
        }
        list($settle, $params) = $this->handle_option_and_params($params, 'cancelAllOrders', 'settle', $settle);
        if ($settle !== null) {
            $request['settleCoin'] = $settle;
        }
        $response = $this->privatePostContractV3PrivateOrderCancelAll (array_merge($request, $params));
        //
        // contract v3
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => {
        //             "list" => array(
        //                 array(
        //                     "orderId" => "4030430d-1dba-4134-ac77-3d81c14aaa00",
        //                     "orderLinkId" => "x001"
        //                 }
        //             )
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => 1658901359225
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $orders = $this->safe_value($result, 'list', array());
        return $this->parse_orders($orders, $market);
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        /**
         * cancel all open orders
         * @param {string|null} $symbol unified $market $symbol, only orders in the $market of this $symbol are cancelled when $symbol is not null
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
         */
        $this->load_markets();
        $market = null;
        $settle = $this->safe_string($params, 'settleCoin');
        if ($settle === null) {
            list($settle, $params) = $this->handle_option_and_params($params, 'cancelAllOrders', 'settle', $settle);
        }
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $settle = $market['settle'];
        }
        $subType = null;
        list($subType, $params) = $this->handle_sub_type_and_params('cancelAllOrders', $market, $params);
        $isUsdcSettled = $settle === 'USDC';
        $isInverse = $subType === 'inverse';
        $isLinearSettle = $isUsdcSettled || ($settle === 'USDT');
        if ($isInverse && $isLinearSettle) {
            throw new ArgumentsRequired($this->id . ' cancelAllOrders with inverse $subType requires $settle to not be USDT or USDC');
        }
        list($type, $query) = $this->handle_market_type_and_params('cancelAllOrders', $market, $params);
        $enableUnifiedMargin = $this->is_unified_margin_enabled();
        if ($type === 'spot') {
            return $this->cancel_all_spot_orders($symbol, $query);
        } elseif ($enableUnifiedMargin && !$isInverse) {
            return $this->cancel_all_unified_margin_orders($symbol, $query);
        } elseif ($isUsdcSettled) {
            return $this->cancel_all_usdc_orders($symbol, $query);
        } else {
            return $this->cancel_all_derivatives_orders($symbol, $query);
        }
    }

    public function fetch_unified_margin_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array(
            // 'symbol' => $market['id'],
            // 'category' => string, Type of derivatives product => linear or option.
            // 'baseCoin' => string, Base coin. When category=option. If not passed, BTC by default; when category=linear, if BTC passed, BTCPERP & BTCUSDT returned.
            // 'orderId' => string, Order ID
            // 'orderLinkId' => string, Unique user-set order ID
            // 'orderStatus' => string, Query list of orders in designated states. If this parameter is not passed, the orders in all states shall be enquired by default. This parameter supports multi-state inquiry. States should be separated with English commas.
            // 'orderFilter' => string, Conditional order or active order
            // 'direction' => string, prev => prev, next => next.
            // 'limit' => number, Data quantity per page => Max $data value per page is 50, and default value at 20.
            // 'cursor' => string, API pass-through. accountType . category . cursor +. If inconsistent, the following should be returned => The account type does not match the service inquiry.
        );
        $market = null;
        if ($symbol === null) {
            $subType = null;
            list($subType, $params) = $this->handle_sub_type_and_params('fetchUnifiedMarginOrders', $market, $params);
            $request['category'] = $subType;
        } else {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
            if ($market['option']) {
                $request['category'] = 'option';
            } elseif ($market['linear']) {
                $request['category'] = 'linear';
            } else {
                throw new NotSupported($this->id . ' fetchUnifiedMarginOrders() does not allow inverse $market orders for ' . $symbol . ' markets');
            }
        }
        $isStop = $this->safe_value($params, 'stop', false);
        $params = $this->omit($params, array( 'stop' ));
        if ($isStop) {
            $request['orderFilter'] = 'StopOrder';
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->privateGetUnifiedV3PrivateOrderList (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "Success",
        //         "result" => array(
        //         "nextPageCursor" => "7d17d359-4e38-4d3a-9a31-29791ef2dfd7%3A1657711949928%2C7d17d359-4e38-4d3a-9a31-29791ef2dfd7%3A1657711949928",
        //         "category" => "linear",
        //         "list" => [
        //             array(
        //                 "symbol" => "ETHUSDT",
        //                 "orderType" => "Market",
        //                 "orderLinkId" => "",
        //                 "orderId" => "7d17d359-4e38-4d3a-9a31-29791ef2dfd7",
        //                 "stopOrderType" => "UNKNOWN",
        //                 "orderStatus" => "Filled",
        //                 "takeProfit" => "",
        //                 "cumExecValue" => "536.92500000",
        //                 "blockTradeId" => "",
        //                 "rejectReason" => "EC_NoError",
        //                 "price" => "1127.10000000",
        //                 "createdTime" => 1657711949928,
        //                 "tpTriggerBy" => "UNKNOWN",
        //                 "timeInForce" => "ImmediateOrCancel",
        //                 "basePrice" => "",
        //                 "leavesValue" => "0.00000000",
        //                 "updatedTime" => 1657711949945,
        //                 "side" => "Buy",
        //                 "triggerPrice" => "",
        //                 "cumExecFee" => "0.32215500",
        //                 "slTriggerBy" => "UNKNOWN",
        //                 "leavesQty" => "0.0000",
        //                 "closeOnTrigger" => false,
        //                 "cumExecQty" => "0.5000",
        //                 "reduceOnly" => false,
        //                 "qty" => "0.5000",
        //                 "stopLoss" => "",
        //                 "triggerBy" => "UNKNOWN",
        //                 "orderIM" => ""
        //             )]
        //         ),
        //         "time" => 1657713451741
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $data = $this->safe_value($result, 'list', array());
        return $this->parse_orders($data, $market, $since, $limit);
    }

    public function fetch_derivatives_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = null;
        $settle = null;
        $request = array(
            // 'symbol' => $market['id'],
            // 'order_id' => 'string'
            // 'order_link_id' => 'string', // unique client order id, max 36 characters
            // 'symbol' => $market['id'], // default BTCUSD
            // 'order' => 'desc', // asc
            // 'page' => 1,
            // 'limit' => 20, // max 50
            // 'order_status' => 'Created,New'
            // conditional orders ---------------------------------------------
            // 'stop_order_id' => 'string',
            // 'stop_order_status' => 'Untriggered',
        );
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $settle = $market['settle'];
            $request['symbol'] = $market['id'];
        }
        list($settle, $params) = $this->handle_option_and_params($params, 'cancelAllOrders', 'settle', $settle);
        if ($settle !== null) {
            $request['settleCoin'] = $settle;
        }
        $isStop = $this->safe_value($params, 'stop', false);
        $params = $this->omit($params, array( 'stop' ));
        if ($isStop) {
            $request['orderFilter'] = 'StopOrder';
        }
        $response = $this->privateGetContractV3PrivateOrderList (array_merge($request, $params));
        //
        // contract v3
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => {
        //             "list" => array(
        //                 array(
        //                     "symbol" => "XRPUSDT",
        //                     "side" => "Buy",
        //                     "orderType" => "Market",
        //                     "price" => "0.3431",
        //                     "qty" => "65",
        //                     "reduceOnly" => true,
        //                     "timeInForce" => "ImmediateOrCancel",
        //                     "orderStatus" => "Filled",
        //                     "leavesQty" => "0",
        //                     "leavesValue" => "0",
        //                     "cumExecQty" => "65",
        //                     "cumExecValue" => "21.3265",
        //                     "cumExecFee" => "0.0127959",
        //                     "lastPriceOnCreated" => "0.0000",
        //                     "rejectReason" => "EC_NoError",
        //                     "orderLinkId" => "",
        //                     "createdTime" => "1657526321499",
        //                     "updatedTime" => "1657526321504",
        //                     "orderId" => "ac0a8134-acb3-4ee1-a2d4-41891c9c46d7",
        //                     "stopOrderType" => "UNKNOWN",
        //                     "takeProfit" => "0.0000",
        //                     "stopLoss" => "0.0000",
        //                     "tpTriggerBy" => "UNKNOWN",
        //                     "slTriggerBy" => "UNKNOWN",
        //                     "triggerPrice" => "0.0000",
        //                     "closeOnTrigger" => true,
        //                     "triggerDirection" => 0,
        //                     "positionIdx" => 2
        //             ),
        //             "nextPageCursor" => "K0crQkZRL0MyQVpiN0tVSDFTS0RlMk9DemNCWHZaRHp3aFZ4Y1Yza2MyWT0="
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => 1658899014975
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $data = $this->safe_value_2($result, 'data', 'list', array());
        return $this->parse_orders($data, $market, $since, $limit);
    }

    public function fetch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        /**
         * fetches information on multiple orders made by the user
         * @param {string} $symbol unified $market $symbol of the $market orders were made in
         * @param {int|null} $since the earliest time in ms to fetch orders for
         * @param {int|null} $limit the maximum number of  orde structures to retrieve
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
         */
        $this->load_markets();
        $market = null;
        $settle = $this->safe_string($params, 'settleCoin');
        if ($settle === null) {
            list($settle, $params) = $this->handle_option_and_params($params, 'fetchOrders', 'settle', $settle);
        }
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $settle = $market['settle'];
        }
        $subType = null;
        list($subType, $params) = $this->handle_sub_type_and_params('fetchOpenOrders', $market, $params);
        $isInverse = $subType === 'inverse';
        $isUsdcSettled = $settle === 'USDC';
        $isLinearSettle = $isUsdcSettled || ($settle === 'USDT');
        if ($isInverse && $isLinearSettle) {
            throw new ArgumentsRequired($this->id . ' fetchOrders with inverse $subType requires $settle to not be USDT or USDC');
        }
        list($type, $query) = $this->handle_market_type_and_params('fetchOpenOrders', $market, $params);
        $enableUnifiedMargin = $this->is_unified_margin_enabled();
        if ($type === 'spot') {
            throw new NotSupported($this->id . ' fetchOrders() does not support ' . $market['type'] . ' markets, use exchange.fetch_open_orders() and exchange.fetchClosedOrders () instead');
        } elseif ($enableUnifiedMargin && !$isInverse) {
            return $this->fetch_unified_margin_orders($symbol, $since, $limit, $query);
        } else {
            return $this->fetch_derivatives_orders($symbol, $since, $limit, $query);
        }
    }

    public function fetch_spot_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
        }
        $request = array();
        if ($symbol !== null) {
            $request['symbol'] = $market['id'];
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        $response = $this->privateGetSpotV3PrivateHistoryOrders (array_merge($request, $params));
        $result = $this->safe_value($response, 'result', array());
        //
        //    {
        //        "retCode" => "0",
        //        "retMsg" => "OK",
        //        "result" => array(
        //            "list" => array(
        //                array(
        //                    "accountId" => "13380434",
        //                    "symbol" => "AAVEUSDT",
        //                    "orderLinkId" => "1666697847966604",
        //                    "orderId" => "1274748373594828288",
        //                    "orderPrice" => "80",
        //                    "orderQty" => "0.11",
        //                    "execQty" => "0",
        //                    "cummulativeQuoteQty" => "0",
        //                    "avgPrice" => "0",
        //                    "status" => "CANCELED",
        //                    "timeInForce" => "GTC",
        //                    "orderType" => "LIMIT",
        //                    "side" => "BUY",
        //                    "stopPrice" => "0.0",
        //                    "icebergQty" => "0.0",
        //                    "createTime" => "1666697847972",
        //                    "updateTime" => "1666697865809",
        //                    "isWorking" => "1",
        //                    "orderCategory" => "0"
        //                ),
        //            )
        //        ),
        //        "retExtInfo" => null,
        //        "time" => "1666732287588"
        //    }
        //
        $orders = $this->safe_value($result, 'list', array());
        return $this->parse_orders($orders, $market, $since, $limit);
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        /**
         * fetches information on multiple closed orders made by the user
         * @param {string|null} $symbol unified $market $symbol of the $market orders were made in
         * @param {int|null} $since the earliest time in ms to fetch orders for
         * @param {int|null} $limit the maximum number of  orde structures to retrieve
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
         */
        $this->load_markets();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
        }
        $type = null;
        list($type, $params) = $this->handle_market_type_and_params('fetchClosedOrders', $market, $params);
        if ($type === 'spot') {
            return $this->fetch_spot_closed_orders($symbol, $since, $limit, $params);
        }
        $request = array();
        $enableUnifiedMargin = $this->is_unified_margin_enabled();
        if ($enableUnifiedMargin) {
            $request['orderStatus'] = 'Canceled';
        } else {
            $request['orderStatus'] = array( 'Filled', 'Canceled' );
        }
        return $this->fetch_orders($symbol, $since, $limit, array_merge($request, $params));
    }

    public function fetch_spot_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $symbol;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->privateGetSpotV3PrivateOpenOrders (array_merge($request, $params));
        //
        //    {
        //         "retCode" => "0",
        //         "retMsg" => "OK",
        //         "result" => {
        //             "list" => array(
        //                 array(
        //                     "accountId" => "13380434",
        //                     "symbol" => "AAVEUSDT",
        //                     "orderLinkId" => "1666734005300717",
        //                     "orderId" => "1275051683279281664",
        //                     "orderPrice" => "80",
        //                     "orderQty" => "0.11",
        //                     "execQty" => "0",
        //                     "cummulativeQuoteQty" => "0",
        //                     "avgPrice" => "0",
        //                     "status" => "NEW",
        //                     "timeInForce" => "GTC",
        //                     "orderType" => "LIMIT",
        //                     "side" => "BUY",
        //                     "stopPrice" => "0.0",
        //                     "icebergQty" => "0.0",
        //                     "createTime" => "1666734005304",
        //                     "updateTime" => "1666734005309",
        //                     "isWorking" => "1",
        //                     "orderCategory" => "0"
        //                 }
        //             )
        //         ),
        //         "retExtInfo" => null,
        //         "time" => "1666734031592"
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $orders = $this->safe_value($result, 'list', array());
        return $this->parse_orders($orders, $market, $since, $limit);
    }

    public function fetch_unified_margin_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol === null) {
            $subType = null;
            list($subType, $params) = $this->handle_sub_type_and_params('fetchUnifiedMarginOrders', $market, $params);
            $request['category'] = $subType;
        } else {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
            if ($market['option']) {
                $request['category'] = 'option';
            } elseif ($market['linear']) {
                $request['category'] = 'linear';
            } else {
                throw new NotSupported($this->id . ' fetchUnifiedMarginOpenOrders() does not allow inverse $market $orders for ' . $symbol . ' markets');
            }
        }
        $type = null;
        list($type, $params) = $this->handle_market_type_and_params('fetchUnifiedMarginOpenOrders', $market, $params);
        $isStop = $this->safe_value($params, 'stop', false);
        $isConditional = $isStop || ($type === 'stop') || ($type === 'conditional');
        $params = $this->omit($params, array( 'stop' ));
        if ($isConditional) {
            $request['orderFilter'] = 'StopOrder';
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->privateGetUnifiedV3PrivateOrderUnfilledOrders (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "Success",
        //         "result" => {
        //             "nextPageCursor" => "135ccc0d-8136-4e1b-8af3-07b11ee158d1%3A1665565610526%2C135ccc0d-8136-4e1b-8af3-07b11ee158d1%3A1665565610526",
        //             "category" => "linear",
        //             "list" => array(
        //                 array(
        //                     "symbol" => "ETHUSDT",
        //                     "orderType" => "Limit",
        //                     "orderLinkId" => "test0000005",
        //                     "orderId" => "135ccc0d-8136-4e1b-8af3-07b11ee158d1",
        //                     "stopOrderType" => "UNKNOWN",
        //                     "orderStatus" => "New",
        //                     "takeProfit" => "",
        //                     "cumExecValue" => "0.00000000",
        //                     "blockTradeId" => "",
        //                     "price" => "700.00000000",
        //                     "createdTime" => 1665565610526,
        //                     "tpTriggerBy" => "UNKNOWN",
        //                     "timeInForce" => "GoodTillCancel",
        //                     "basePrice" => "",
        //                     "updatedTime" => 1665565610533,
        //                     "side" => "Buy",
        //                     "triggerPrice" => "",
        //                     "cumExecFee" => "0.00000000",
        //                     "slTriggerBy" => "UNKNOWN",
        //                     "leavesQty" => "0.1000",
        //                     "closeOnTrigger" => false,
        //                     "cumExecQty" => "0.00000000",
        //                     "reduceOnly" => false,
        //                     "qty" => "0.1000",
        //                     "stopLoss" => "",
        //                     "triggerBy" => "UNKNOWN",
        //                     "orderIM" => "0.00000000"
        //                 }
        //             )
        //         ),
        //         "retExtInfo" => null,
        //         "time" => 1665565614320
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $orders = $this->safe_value($result, 'list', array());
        return $this->parse_orders($orders, $market, $since, $limit);
    }

    public function fetch_derivatives_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = null;
        $settle = null;
        $request = array();
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $settle = $market['settle'];
            $request['symbol'] = $market['id'];
        }
        list($settle, $params) = $this->handle_option_and_params($params, 'cancelAllOrders', 'settle', $settle);
        if ($settle !== null) {
            $request['settleCoin'] = $settle;
        }
        $isStop = $this->safe_value($params, 'stop', false);
        $params = $this->omit($params, array( 'stop' ));
        if ($isStop) {
            $request['orderFilter'] = 'StopOrder';
        }
        $response = $this->privateGetContractV3PrivateOrderUnfilledOrders (array_merge($request, $params));
        //
        // contract v3
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => {
        //             "list" => array(
        //                 array(
        //                     "symbol" => "XRPUSDT",
        //                     "orderId" => "db8b74b3-72d3-4264-bf3f-52d39b41956e",
        //                     "side" => "Sell",
        //                     "orderType" => "Limit",
        //                     "stopOrderType" => "Stop",
        //                     "price" => "0.4000",
        //                     "qty" => "15",
        //                     "timeInForce" => "GoodTillCancel",
        //                     "orderStatus" => "UnTriggered",
        //                     "triggerPrice" => "0.1000",
        //                     "orderLinkId" => "x002",
        //                     "createdTime" => "1658901865082",
        //                     "updatedTime" => "1658902610748",
        //                     "takeProfit" => "0.2000",
        //                     "stopLoss" => "1.6000",
        //                     "tpTriggerBy" => "UNKNOWN",
        //                     "slTriggerBy" => "UNKNOWN",
        //                     "triggerBy" => "MarkPrice",
        //                     "reduceOnly" => false,
        //                     "leavesQty" => "15",
        //                     "leavesValue" => "6",
        //                     "cumExecQty" => "0",
        //                     "cumExecValue" => "0",
        //                     "cumExecFee" => "0",
        //                     "triggerDirection" => 2
        //                 }
        //             ),
        //             "nextPageCursor" => ""
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => 1658902847238
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $orders = $this->safe_value($result, 'list', array());
        return $this->parse_orders($orders, $market, $since, $limit);
    }

    public function fetch_usdc_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        $type = null;
        list($type, $params) = $this->handle_market_type_and_params('fetchUSDCOpenOrders', $market, $params);
        $request['category'] = ($type === 'swap') ? 'perpetual' : 'option';
        $response = $this->privatePostOptionUsdcOpenapiPrivateV1QueryActiveOrders (array_merge($request, $params));
        $result = $this->safe_value($response, 'result', array());
        $orders = $this->safe_value($result, 'dataList', array());
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => {
        //             "resultTotalSize" => 1,
        //             "cursor" => "id%3D1662019818569%23df31e03b-fc00-4b4c-bd1c-b97fd72b5c5c",
        //             "dataList" => array(
        //                 {
        //                     "orderId" => "df31e03b-fc00-4b4c-bd1c-b97fd72b5c5c",
        //                     "orderLinkId" => "",
        //                     "symbol" => "BTC-2SEP22-18000-C",
        //                     "orderStatus" => "New",
        //                     "orderPrice" => "500",
        //                     "side" => "Buy",
        //                     "remainingQty" => "0.1",
        //                     "orderType" => "Limit",
        //                     "qty" => "0.1",
        //                     "iv" => "0.0000",
        //                     "cancelType" => "",
        //                     "updateTimestamp" => "1662019818579"
        //                 }
        //             )
        //         }
        //     }
        //
        return $this->parse_orders($orders, $market, $since, $limit);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        /**
         * fetch all unfilled currently open orders
         * @param {string|null} $symbol unified $market $symbol
         * @param {int|null} $since the earliest time in ms to fetch open orders for
         * @param {int|null} $limit the maximum number of  open orders structures to retrieve
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
         */
        $this->load_markets();
        $market = null;
        $settle = $this->safe_string($params, 'settleCoin');
        if ($settle === null) {
            list($settle, $params) = $this->handle_option_and_params($params, 'fetchOpenOrders', 'settle', $settle);
        }
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $settle = $market['settle'];
        }
        $subType = null;
        list($subType, $params) = $this->handle_sub_type_and_params('fetchOpenOrders', $market, $params);
        $isInverse = $subType === 'inverse';
        $isUsdcSettled = $settle === 'USDC';
        $isLinearSettle = $isUsdcSettled || ($settle === 'USDT');
        if ($isInverse && $isLinearSettle) {
            throw new ArgumentsRequired($this->id . ' fetchOpenOrders with inverse $subType requires $settle to not be USDT or USDC');
        }
        list($type, $query) = $this->handle_market_type_and_params('fetchOpenOrders', $market, $params);
        $enableUnifiedMargin = $this->is_unified_margin_enabled();
        if ($type === 'spot') {
            return $this->fetch_spot_open_orders($symbol, $since, $limit, $query);
        } elseif ($enableUnifiedMargin && !$isInverse) {
            return $this->fetch_unified_margin_open_orders($symbol, $since, $limit, $query);
        } elseif ($isUsdcSettled) {
            return $this->fetch_usdc_open_orders($symbol, $since, $limit, $query);
        } else {
            return $this->fetch_derivatives_open_orders($symbol, $since, $limit, $query);
        }
    }

    public function fetch_order_trades($id, $symbol = null, $since = null, $limit = null, $params = array ()) {
        /**
         * fetch all the trades made from a single order
         * @param {string} $id order $id
         * @param {string|null} $symbol unified market $symbol
         * @param {int|null} $since the earliest time in ms to fetch trades for
         * @param {int|null} $limit the maximum number of trades to retrieve
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#trade-structure trade structures}
         */
        $request = array(
            'orderId' => $id,
        );
        return $this->fetch_my_trades($symbol, $since, $limit, array_merge($request, $params));
    }

    public function fetch_my_spot_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchMySpotTrades() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            // 'orderId' => 'f185806b-b801-40ff-adec-52289370ed62', // if not provided will return user's trading records
            // 'startTime' => intval($since / 1000),
            // 'endTime' => 0,
            // 'fromTradeId' => '',
            // 'toTradeId' => '',
            // 'limit' 20, // max 50
        );
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit; // default 20, max 50
        }
        $response = $this->privateGetSpotV3PrivateMyTrades (array_merge($request, $params));
        //
        //    {
        //         "retCode" => "0",
        //         "retMsg" => "OK",
        //         "result" => array(
        //             "list" => array(
        //                 array(
        //                     "symbol" => "AAVEUSDT",
        //                     "id" => "1274785101965716992",
        //                     "orderId" => "1274784252359089664",
        //                     "tradeId" => "2270000000031365639",
        //                     "orderPrice" => "82.5",
        //                     "orderQty" => "0.016",
        //                     "execFee" => "0",
        //                     "feeTokenId" => "AAVE",
        //                     "creatTime" => "1666702226326",
        //                     "isBuyer" => "0",
        //                     "isMaker" => "0",
        //                     "matchOrderId" => "1274785101865076224",
        //                     "makerRebate" => "0",
        //                     "executionTime" => "1666702226335"
        //                 ),
        //             )
        //         ),
        //         "retExtMap" => array(),
        //         "retExtInfo" => null,
        //         "time" => "1666768215157"
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $trades = $this->safe_value($result, 'list', array());
        return $this->parse_trades($trades, $market, $since, $limit);
    }

    public function fetch_my_unified_margin_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $this->load_markets();
        $market = null;
        $settle = null;
        $request = array(
            // 'symbol' => $market['id'],
            // 'orderId' => 'f185806b-b801-40ff-adec-52289370ed62', // if not provided will return user's trading records
            // 'startTime' => intval($since / 1000),
            // 'endTime' => 0,
            // 'category' => ''
            // 'limit' 20, // max 50
        );
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $settle = $market['settle'];
            $request['symbol'] = $market['id'];
        }
        $subType = null;
        list($subType, $params) = $this->handle_sub_type_and_params('fetchMyTrades', $market, $params);
        $request['category'] = $subType;
        list($settle, $params) = $this->handle_option_and_params($params, 'cancelAllOrders', 'settle', $settle);
        if ($settle !== null) {
            $request['settleCoin'] = $settle;
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit; // default 20, max 50
        }
        $response = $this->privateGetUnifiedV3PrivateExecutionList (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "Success",
        //         "result" => {
        //             "nextPageCursor" => "1565%3A0%2C1565%3A0",
        //             "category" => "option",
        //             "list" => array(
        //                 array(
        //                     "orderType" => "Limit",
        //                     "symbol" => "BTC-14JUL22-17500-C",
        //                     "orderLinkId" => "188889689-yuanzhen-558998998898",
        //                     "side" => "Buy",
        //                     "orderId" => "09c5836f-81ef-4208-a5b4-43135d3e02a2",
        //                     "leavesQty" => "0.0000",
        //                     "execTime" => 1657714122417,
        //                     "execFee" => "0.11897082",
        //                     "feeRate" => "0.000300",
        //                     "execId" => "6e492560-78b4-5d2b-b331-22921d3173c9",
        //                     "blockTradeId" => "",
        //                     "execPrice" => "2360.00000000",
        //                     "lastLiquidityInd" => "TAKER",
        //                     "orderQty" => "0.0200",
        //                     "orderPrice" => "2360.00000000",
        //                     "execValue" => "47.20000000",
        //                     "execType" => "Trade",
        //                     "execQty" => "0.0200"
        //                 }
        //             )
        //         ),
        //         "time" => 1657714292783
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $trades = $this->safe_value($result, 'list', array());
        return $this->parse_trades($trades, $market, $since, $limit);
    }

    public function fetch_my_contract_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchMyContractTrades() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            // 'order_id' => 'f185806b-b801-40ff-adec-52289370ed62', // if not provided will return user's trading records
            // 'start_time' => intval($since / 1000),
            // 'page' => 1,
            // 'limit' 20, // max 50
        );
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit; // default 20, max 50
        }
        $response = $this->privateGetContractV3PrivateExecutionList (array_merge($request, $params));
        //
        // contract v3
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => {
        //             "list" => array(
        //                 array(
        //                     "symbol" => "BITUSDT",
        //                     "execFee" => "0.001356",
        //                     "execId" => "499e1a2a-c664-55db-bbf0-78ad31b7b033",
        //                     "execPrice" => "0.452",
        //                     "execQty" => "5.0",
        //                     "execType" => "Trade",
        //                     "execValue" => "2.26",
        //                     "feeRate" => "0.0006",
        //                     "lastLiquidityInd" => "RemovedLiquidity",
        //                     "leavesQty" => "0.0",
        //                     "orderId" => "1d40db82-b1f6-4340-9190-650eeddd440b",
        //                     "orderLinkId" => "",
        //                     "orderPrice" => "0.430",
        //                     "orderQty" => "5.0",
        //                     "orderType" => "Market",
        //                     "stopOrderType" => "UNKNOWN",
        //                     "side" => "Sell",
        //                     "execTime" => "1657269236943",
        //                     "closedSize" => "5.0"
        //                 ),
        //                 array(
        //                     "symbol" => "BITUSDT",
        //                     "execFee" => "0.004068",
        //                     "execId" => "ed090e6a-afc0-5cb5-b51d-039592a44ec5",
        //                     "execPrice" => "0.452",
        //                     "execQty" => "15.0",
        //                     "execType" => "Trade",
        //                     "execValue" => "6.78",
        //                     "feeRate" => "0.0006",
        //                     "lastLiquidityInd" => "RemovedLiquidity",
        //                     "leavesQty" => "0.0",
        //                     "orderId" => "d34d40a1-2475-4552-9e54-347a27282ec0",
        //                     "orderLinkId" => "",
        //                     "orderPrice" => "0.429",
        //                     "orderQty" => "15.0",
        //                     "orderType" => "Market",
        //                     "stopOrderType" => "UNKNOWN",
        //                     "side" => "Sell",
        //                     "execTime" => "1657268340170",
        //                     "closedSize" => "15.0"
        //                 }
        //             ),
        //             "nextPageCursor" => ""
        //         ),
        //         "retExtInfo" => null,
        //         "time" => 1658911518442
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $trades = $this->safe_value($result, 'list', array());
        return $this->parse_trades($trades, $market, $since, $limit);
    }

    public function fetch_my_usdc_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = null;
        $request = array();
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
            $request['category'] = $market['option'] ? 'OPTION' : 'PERPETUAL';
        } else {
            $request['category'] = 'PERPETUAL';
        }
        $response = $this->privatePostOptionUsdcOpenapiPrivateV1ExecutionList (array_merge($request, $params));
        //
        //     {
        //       "result" => array(
        //         "cursor" => "29%3A1%2C28%3A1",
        //         "resultTotalSize" => 2,
        //         "dataList" => array(
        //           array(
        //             "symbol" => "ETHPERP",
        //             "orderLinkId" => "",
        //             "side" => "Sell",
        //             "orderId" => "d83f8b4d-2f60-4e04-a64a-a3f207989dc6",
        //             "execFee" => "0.0210",
        //             "feeRate" => "0.000600",
        //             "blockTradeId" => "",
        //             "tradeTime" => "1669196423581",
        //             "execPrice" => "1161.45",
        //             "lastLiquidityInd" => "TAKER",
        //             "execValue" => "34.8435",
        //             "execType" => "Trade",
        //             "execQty" => "0.030",
        //             "tradeId" => "d9aa8590-9e6a-575e-a1be-d6261e6ed2e5"
        //           ), ...
        //         )
        //       ),
        //       "retCode" => 0,
        //       "retMsg" => "Success."
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $dataList = $this->safe_value($result, 'dataList', array());
        return $this->parse_trades($dataList, $market, $since, $limit);
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        /**
         * fetch all trades made by the user
         * @param {string} $symbol unified $market $symbol
         * @param {int|null} $since the earliest time in ms to fetch trades for
         * @param {int|null} $limit the maximum number of trades structures to retrieve
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#trade-structure trade structures}
         */
        $this->load_markets();
        $market = null;
        $settle = $this->safe_string($params, 'settleCoin');
        if ($settle === null) {
            list($settle, $params) = $this->handle_option_and_params($params, 'fetchMyTrades', 'settle', $settle);
        }
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $settle = $market['settle'];
        }
        $subType = null;
        list($subType, $params) = $this->handle_sub_type_and_params('fetchMyTrades', $market, $params);
        $isInverse = $subType === 'inverse';
        $isUsdcSettled = $settle === 'USDC';
        $isLinearSettle = $isUsdcSettled || ($settle === 'USDT');
        if ($isInverse && $isLinearSettle) {
            throw new ArgumentsRequired($this->id . ' fetchMyTrades with inverse $subType requires $settle to not be USDT or USDC');
        }
        list($type, $query) = $this->handle_market_type_and_params('fetchMyTrades', $market, $params);
        $enableUnifiedMargin = $this->is_unified_margin_enabled();
        if ($type === 'spot') {
            return $this->fetch_my_spot_trades($symbol, $since, $limit, $query);
        } elseif ($enableUnifiedMargin && !$isInverse) {
            return $this->fetch_my_unified_margin_trades($symbol, $since, $limit, $query);
        } elseif ($isUsdcSettled) {
            return $this->fetch_my_usdc_trades($symbol, $since, $limit, $query);
        } else {
            return $this->fetch_my_contract_trades($symbol, $since, $limit, $query);
        }
    }

    public function parse_deposit_address($depositAddress, $currency = null) {
        //
        //     {
        //         chainType => 'ERC20',
        //         addressDeposit => '0xf56297c6717c1d1c42c30324468ed50a9b7402ee',
        //         tagDeposit => '',
        //         $chain => 'ETH'
        //     }
        //
        $address = $this->safe_string($depositAddress, 'addressDeposit');
        $tag = $this->safe_string($depositAddress, 'tagDeposit');
        $code = $this->safe_string($currency, 'code');
        $chain = $this->safe_string($depositAddress, 'chain');
        $this->check_address($address);
        return array(
            'currency' => $code,
            'address' => $address,
            'tag' => $tag,
            'network' => $chain,
            'info' => $depositAddress,
        );
    }

    public function fetch_deposit_addresses_by_network($code, $params = array ()) {
        /**
         * fetch a dictionary of addresses for a $currency, indexed by network
         * @param {string} $code unified $currency $code of the $currency for the deposit address
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} a dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#address-structure address structures} indexed by the network
         */
        $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'coin' => $currency['id'],
        );
        $response = $this->privateGetAssetV3PrivateDepositAddressQuery (array_merge($request, $params));
        //
        //    {
        //         "retCode" => "0",
        //         "retMsg" => "success",
        //         "result" => array(
        //             "coin" => "USDT",
        //             "chains" => array(
        //                 array(
        //                     "chainType" => "ERC20",
        //                     "addressDeposit" => "0xf56297c6717c1d1c42c30324468ed50a9b7402ee",
        //                     "tagDeposit" => "",
        //                     "chain" => "ETH"
        //                 ),
        //                 array(
        //                     "chainType" => "TRC20",
        //                     "addressDeposit" => "TC6TAC5WSVCCiaD3nWZXyW62ZKKPwm55a",
        //                     "tagDeposit" => "",
        //                     "chain" => "TRX"
        //                 ),
        //             )
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => "1666882145079"
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $chains = $this->safe_value($result, 'chains', array());
        $coin = $this->safe_string($result, 'coin');
        $currency = $this->currency($coin);
        $parsed = $this->parse_deposit_addresses($chains, array( $code ), false, array(
            'currency' => $currency['id'],
        ));
        return $this->index_by($parsed, 'network');
    }

    public function fetch_deposit_address($code, $params = array ()) {
        /**
         * fetch the deposit address for a $currency associated with this account
         * @param {string} $code unified $currency $code
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} an {@link https://docs.ccxt.com/en/latest/manual.html#address-structure address structure}
         */
        $this->load_markets();
        list($networkCode, $query) = $this->handle_network_code_and_params($params);
        $networkId = $this->network_code_to_id($networkCode);
        $currency = $this->currency($code);
        $request = array(
            'coin' => $currency['id'],
        );
        if ($networkId !== null) {
            $request['chainType'] = $networkId;
        }
        $response = $this->privateGetAssetV3PrivateDepositAddressQuery (array_merge($request, $query));
        //
        //    {
        //         "retCode" => "0",
        //         "retMsg" => "success",
        //         "result" => array(
        //             "coin" => "USDT",
        //             "chains" => array(
        //                 array(
        //                     "chainType" => "TRC20",
        //                     "addressDeposit" => "TC6NCAC5WSVCCiaD3kWZXyW91ZKKhLm53b",
        //                     "tagDeposit" => "",
        //                     "chain" => "TRX"
        //                 ),
        //             )
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => "1666895654316"
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $chains = $this->safe_value($result, 'chains', array());
        $chainsIndexedById = $this->index_by($chains, 'chain');
        $selectedNetworkId = $this->select_network_id_from_raw_networks($code, $networkCode, $chainsIndexedById);
        $addressObject = $this->safe_value($chainsIndexedById, $selectedNetworkId, array());
        return $this->parse_deposit_address($addressObject, $currency);
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        /**
         * fetch all deposits made to an account
         * @param {string|null} $code unified $currency $code
         * @param {int|null} $since the earliest time in ms to fetch deposits for
         * @param {int|null} $limit the maximum number of deposits structures to retrieve
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#transaction-structure transaction structures}
         */
        $this->load_markets();
        $request = array(
            // 'coin' => $currency['id'],
            // 'currency' => $currency['id'], // alias
            // 'start_date' => $this->iso8601($since),
            // 'end_date' => $this->iso8601(till),
            'wallet_fund_type' => 'Deposit', // Deposit, Withdraw, RealisedPNL, Commission, Refund, Prize, ExchangeOrderWithdraw, ExchangeOrderDeposit
            // 'page' => 1,
            // 'limit' => 20, // max 50
        );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['coin'] = $currency['id'];
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        // Currently only works for deposits prior to 2021-07-15
        // will be updated soon
        $response = $this->privateGetAssetV3PrivateDepositRecordQuery (array_merge($request, $params));
        //
        //    {
        //         "retCode" => "0",
        //         "retMsg" => "success",
        //         "result" => array(
        //             "rows" => array(
        //                 array(
        //                     "coin" => "USDT",
        //                     "chain" => "TRX",
        //                     "amount" => "44",
        //                     "txID" => "0b038ea12fa1575e2d66693db3c346b700d4b28347afc39f80321cf089acc960",
        //                     "status" => "3",
        //                     "toAddress" => "TC6NCAC5WSVCCiaD3kWZXyW91ZKKhLm53b",
        //                     "tag" => "",
        //                     "depositFee" => "",
        //                     "successAt" => "1665142507000",
        //                     "confirmations" => "100",
        //                     "txIndex" => "0",
        //                     "blockHash" => "0000000002ac3b1064aee94bca1bd0b58c4c09c65813b084b87a2063d961129e"
        //                 ),
        //             ),
        //             "nextPageCursor" => "eyJtaW5JRCI6MTE5OTUyNjgsIm1heElEIjoxMjI2OTA2OH0="
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => "1666883499086"
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $data = $this->safe_value($result, 'rows', array());
        return $this->parse_transactions($data, $currency, $since, $limit);
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        /**
         * fetch all withdrawals made from an account
         * @param {string} $code unified $currency $code
         * @param {int|null} $since the earliest time in ms to fetch withdrawals for
         * @param {int|null} $limit the maximum number of withdrawals structures to retrieve
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#transaction-structure transaction structures}
         */
        $this->load_markets();
        $request = array(
            // 'coin' => $currency['id'],
            // 'start_date' => $this->iso8601($since),
            // 'end_date' => $this->iso8601(till),
            // 'status' => 'Pending', // ToBeConfirmed, UnderReview, Pending, Success, CancelByUser, Reject, Expire
            // 'page' => 1,
            // 'limit' => 20, // max 50
        );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['coin'] = $currency['id'];
        }
        if ($since !== null) {
            $request['startTime'] = $this->yyyymmdd($since);
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->privateGetAssetV3PrivateWithdrawRecordQuery (array_merge($request, $params));
        //
        //    {
        //         "retCode" => "0",
        //         "retMsg" => "success",
        //         "result" => array(
        //             "rows" => array(
        //                 array(
        //                     "coin" => "USDT",
        //                     "chain" => "TRX",
        //                     "amount" => "12.34",
        //                     "txID" => "de5ea0a2f2e59dc9a714837dd3ddc6d5e151b56ec5d786d351c4f52336f80d3c",
        //                     "status" => "success",
        //                     "toAddress" => "TQdmFKUoe1Lk2iwZuwRJEHJreTUBoN3BAw",
        //                     "tag" => "",
        //                     "withdrawFee" => "0.5",
        //                     "createTime" => "1665144183000",
        //                     "updateTime" => "1665144256000",
        //                     "withdrawId" => "8839035"
        //                 ),
        //             ),
        //             "nextPageCursor" => "eyJtaW5JRCI6ODczMzUyMiwibWF4SUQiOjg4MzkwMzV9"
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => "1666887679223"
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $data = $this->safe_value($result, 'rows', array());
        return $this->parse_transactions($data, $currency, $since, $limit);
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            // v1/v2
            'ToBeConfirmed' => 'pending',
            'UnderReview' => 'pending',
            'Success' => 'ok',
            'Expire' => 'expired',
            // v3 deposit $status
            '0' => 'unknown',
            '1' => 'pending',
            '2' => 'processing',
            '3' => 'ok',
            '4' => 'fail',
            // v3 withdrawal $status
            'SecurityCheck' => 'pending',
            'Pending' => 'pending',
            'success' => 'ok',
            'CancelByUser' => 'canceled',
            'Reject' => 'rejected',
            'Fail' => 'failed',
            'BlockchainConfirmed' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // fetchWithdrawals
        //
        //     {
        //         "coin" => "USDT",
        //         "chain" => "TRX",
        //         "amount" => "12.34",
        //         "txID" => "de5ea0a2f2e59dc9a714837dd3ddc6d5e151b56ec5d786d351c4f52336f80d3c",
        //         "status" => "success",
        //         "toAddress" => "TQdmFKUoe1Lk2iwZuwRJEHJreTUBoN3BAw",
        //         "tag" => "",
        //         "withdrawFee" => "0.5",
        //         "createTime" => "1665144183000",
        //         "updateTime" => "1665144256000",
        //         "withdrawId" => "8839035"
        //     }
        //
        // fetchDeposits
        //
        //     {
        //         "coin" => "USDT",
        //         "chain" => "TRX",
        //         "amount" => "44",
        //         "txID" => "0b038ea12fa1575e2d66693db3c346b700d4b28347afc39f80321cf089acc960",
        //         "status" => "3",
        //         "toAddress" => "TC6NCAC5WSVCCiaD3kWZXyW91ZKKhLm53b",
        //         "tag" => "",
        //         "depositFee" => "",
        //         "successAt" => "1665142507000",
        //         "confirmations" => "100",
        //         "txIndex" => "0",
        //         "blockHash" => "0000000002ac3b1064aee94bca1bd0b58c4c09c65813b084b87a2063d961129e"
        //     }
        //
        // withdraw
        //
        //     {
        //         "id" => "9377266"
        //     }
        //
        $currencyId = $this->safe_string($transaction, 'coin');
        $code = $this->safe_currency_code($currencyId, $currency);
        $timestamp = $this->safe_integer_2($transaction, 'createTime', 'successAt');
        $updated = $this->safe_integer($transaction, 'updateTime');
        $status = $this->parse_transaction_status($this->safe_string($transaction, 'status'));
        $feeCost = $this->safe_number_2($transaction, 'depositFee', 'withdrawFee', 0);
        $type = (is_array($transaction) && array_key_exists('depositFee', $transaction)) ? 'deposit' : 'withdrawal';
        $fee = null;
        if ($feeCost !== null) {
            $fee = array(
                'cost' => $feeCost,
                'currency' => $code,
            );
        }
        $toAddress = $this->safe_string($transaction, 'toAddress');
        return array(
            'info' => $transaction,
            'id' => $this->safe_string_2($transaction, 'id', 'withdrawId'),
            'txid' => $this->safe_string($transaction, 'txID'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'network' => $this->network_id_to_code($this->safe_string($transaction, 'chain')),
            'address' => null,
            'addressTo' => $toAddress,
            'addressFrom' => null,
            'tag' => $this->safe_string($transaction, 'tag'),
            'tagTo' => null,
            'tagFrom' => null,
            'type' => $type,
            'amount' => $this->safe_number($transaction, 'amount'),
            'currency' => $code,
            'status' => $status,
            'updated' => $updated,
            'fee' => $fee,
        );
    }

    public function fetch_ledger($code = null, $since = null, $limit = null, $params = array ()) {
        /**
         * fetch the history of changes, actions done by the user or operations that altered balance of the user
         * @param {string|null} $code unified $currency $code, default is null
         * @param {int|null} $since timestamp in ms of the earliest ledger entry, default is null
         * @param {int|null} $limit max number of ledger entrys to return, default is null
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#ledger-structure ledger structure}
         */
        $this->load_markets();
        $request = array(
            // 'coin' => $currency['id'],
            // 'currency' => $currency['id'], // alias
            // 'start_date' => $this->iso8601($since),
            // 'end_date' => $this->iso8601(till),
            // 'wallet_fund_type' => 'Deposit', // Withdraw, RealisedPNL, Commission, Refund, Prize, ExchangeOrderWithdraw, ExchangeOrderDeposit
            // 'page' => 1,
            // 'limit' => 20, // max 50
        );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['coin'] = $currency['id'];
        }
        if ($since !== null) {
            $request['start_date'] = $this->yyyymmdd($since);
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->privateGetV2PrivateWalletFundRecords (array_merge($request, $params));
        //
        //     {
        //         "ret_code" => 0,
        //         "ret_msg" => "ok",
        //         "ext_code" => "",
        //         "result" => {
        //             "data" => array(
        //                 array(
        //                     "id" => 234467,
        //                     "user_id" => 1,
        //                     "coin" => "BTC",
        //                     "wallet_id" => 27913,
        //                     "type" => "Realized P&L",
        //                     "amount" => "-0.00000006",
        //                     "tx_id" => "",
        //                     "address" => "BTCUSD",
        //                     "wallet_balance" => "0.03000330",
        //                     "exec_time" => "2019-12-09T00:00:25.000Z",
        //                     "cross_seq" => 0
        //                 }
        //             )
        //         ),
        //         "ext_info" => null,
        //         "time_now" => "1577481867.115552",
        //         "rate_limit_status" => 119,
        //         "rate_limit_reset_ms" => 1577481867122,
        //         "rate_limit" => 120
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $data = $this->safe_value($result, 'data', array());
        return $this->parse_ledger($data, $currency, $since, $limit);
    }

    public function parse_ledger_entry($item, $currency = null) {
        //
        //     {
        //         "id" => 234467,
        //         "user_id" => 1,
        //         "coin" => "BTC",
        //         "wallet_id" => 27913,
        //         "type" => "Realized P&L",
        //         "amount" => "-0.00000006",
        //         "tx_id" => "",
        //         "address" => "BTCUSD",
        //         "wallet_balance" => "0.03000330",
        //         "exec_time" => "2019-12-09T00:00:25.000Z",
        //         "cross_seq" => 0
        //     }
        //
        $currencyId = $this->safe_string($item, 'coin');
        $code = $this->safe_currency_code($currencyId, $currency);
        $amount = $this->safe_string($item, 'amount');
        $after = $this->safe_string($item, 'wallet_balance');
        $direction = Precise::string_lt($amount, '0') ? 'out' : 'in';
        $before = null;
        if ($after !== null && $amount !== null) {
            $difference = ($direction === 'out') ? $amount : Precise::string_neg($amount);
            $before = Precise::string_add($after, $difference);
        }
        $timestamp = $this->parse8601($this->safe_string($item, 'exec_time'));
        $type = $this->parse_ledger_entry_type($this->safe_string($item, 'type'));
        $id = $this->safe_string($item, 'id');
        $referenceId = $this->safe_string($item, 'tx_id');
        return array(
            'id' => $id,
            'currency' => $code,
            'account' => $this->safe_string($item, 'wallet_id'),
            'referenceAccount' => null,
            'referenceId' => $referenceId,
            'status' => null,
            'amount' => $this->parse_number($amount),
            'before' => $this->parse_number($before),
            'after' => $this->parse_number($after),
            'fee' => null,
            'direction' => $direction,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'type' => $type,
            'info' => $item,
        );
    }

    public function parse_ledger_entry_type($type) {
        $types = array(
            'Deposit' => 'transaction',
            'Withdraw' => 'transaction',
            'RealisedPNL' => 'trade',
            'Commission' => 'fee',
            'Refund' => 'cashback',
            'Prize' => 'prize', // ?
            'ExchangeOrderWithdraw' => 'transaction',
            'ExchangeOrderDeposit' => 'transaction',
        );
        return $this->safe_string($types, $type, $type);
    }

    public function withdraw($code, $amount, $address, $tag = null, $params = array ()) {
        /**
         * make a withdrawal
         * @param {string} $code unified $currency $code
         * @param {float} $amount the $amount to withdraw
         * @param {string} $address the $address to withdraw to
         * @param {string|null} $tag
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#transaction-structure transaction structure}
         */
        list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
        $this->load_markets();
        $this->check_address($address);
        $currency = $this->currency($code);
        $request = array(
            'coin' => $currency['id'],
            'amount' => $this->number_to_string($amount),
            'address' => $address,
        );
        if ($tag !== null) {
            $request['tag'] = $tag;
        }
        list($networkCode, $query) = $this->handle_network_code_and_params($params);
        $networkId = $this->network_code_to_id($networkCode);
        if ($networkId !== null) {
            $request['chain'] = strtoupper($networkId);
        }
        $response = $this->privatePostAssetV3PrivateWithdrawCreate (array_merge($request, $query));
        //
        //    {
        //         "retCode" => "0",
        //         "retMsg" => "success",
        //         "result" => array(
        //             "id" => "9377266"
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => "1666892894902"
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        return $this->parse_transaction($result, $currency);
    }

    public function fetch_position($symbol = null, $params = array ()) {
        /**
         * fetch data on a single open contract trade $position
         * @param {string} $symbol unified $market $symbol of the $market the $position is held in, default is null
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#$position-structure $position structure}
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchPosition() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $method = null;
        $enableUnifiedMargin = $this->is_unified_margin_enabled();
        $isUsdcSettled = $market['settle'] === 'USDC';
        if ($enableUnifiedMargin) {
            $method = 'privateGetUnifiedV3PrivatePositionList';
            if ($market['option']) {
                $request['category'] = 'option';
            } elseif ($market['linear']) {
                $request['category'] = 'linear';
            } else {
                throw new NotSupported($this->id . ' fetchPosition() does not allow inverse $market orders for ' . $symbol . ' markets');
            }
        } elseif ($isUsdcSettled) {
            $method = 'privatePostOptionUsdcOpenapiPrivateV1QueryPosition';
            if ($market['option']) {
                $request['category'] = 'OPTION';
            } elseif ($market['linear']) {
                $request['category'] = 'PERPETUAL';
            }
        } else {
            $method = 'privateGetContractV3PrivatePositionList';
        }
        $response = $this->$method (array_merge($request, $params));
        //
        // unified margin
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "Success",
        //         "result" => {
        //             "nextPageCursor" => "0%3A1657711949945%2C0%3A1657711949945",
        //             "category" => "linear",
        //             "list" => array(
        //                 array(
        //                     "symbol" => "ETHUSDT",
        //                     "leverage" => "10",
        //                     "updatedTime" => 1657711949945,
        //                     "side" => "Buy",
        //                     "positionValue" => "536.92500000",
        //                     "takeProfit" => "",
        //                     "tpslMode" => "Full",
        //                     "riskId" => 11,
        //                     "trailingStop" => "",
        //                     "entryPrice" => "1073.85000000",
        //                     "unrealisedPnl" => "",
        //                     "markPrice" => "1080.65000000",
        //                     "size" => "0.5000",
        //                     "positionStatus" => "normal",
        //                     "stopLoss" => "",
        //                     "cumRealisedPnl" => "-0.32215500",
        //                     "positionMM" => "2.97456450",
        //                     "createdTime" => 1657711949928,
        //                     "positionIdx" => 0,
        //                     "positionIM" => "53.98243950"
        //                 }
        //             )
        //         ),
        //         "time" => 1657713693182
        //     }
        //
        // contract v3
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => {
        //             "list" => array(
        //                 array(
        //                     "positionIdx" => 1,
        //                     "riskId" => "41",
        //                     "symbol" => "XRPUSDT",
        //                     "side" => "Buy",
        //                     "size" => "0",
        //                     "positionValue" => "0",
        //                     "entryPrice" => "0",
        //                     "tradeMode" => 0,
        //                     "autoAddMargin" => 0,
        //                     "leverage" => "10",
        //                     "positionBalance" => "0",
        //                     "liqPrice" => "0.0000",
        //                     "bustPrice" => "0.0000",
        //                     "takeProfit" => "0.0000",
        //                     "stopLoss" => "0.0000",
        //                     "trailingStop" => "0.0000",
        //                     "unrealisedPnl" => "0",
        //                     "createdTime" => "1658827444328",
        //                     "updatedTime" => "1658904863412",
        //                     "tpSlMode" => "Full",
        //                     "riskLimitValue" => "200000",
        //                     "activePrice" => "0.0000"
        //                 ),
        //                 array(
        //                     "positionIdx" => 2,
        //                     "riskId" => "41",
        //                     "symbol" => "XRPUSDT",
        //                     "side" => "Sell",
        //                     "size" => "50",
        //                     "positionValue" => "16.68",
        //                     "entryPrice" => "0.3336",
        //                     "tradeMode" => 0,
        //                     "autoAddMargin" => 0,
        //                     "leverage" => "10",
        //                     "positionBalance" => "1.6790088",
        //                     "liqPrice" => "12.4835",
        //                     "bustPrice" => "12.4869",
        //                     "takeProfit" => "0.0000",
        //                     "stopLoss" => "0.0000",
        //                     "trailingStop" => "0.0000",
        //                     "unrealisedPnl" => "0",
        //                     "createdTime" => "1658827444328",
        //                     "updatedTime" => "1658904863412",
        //                     "tpSlMode" => "Full",
        //                     "riskLimitValue" => "200000",
        //                     "activePrice" => "0.0000"
        //                 }
        //             )
        //         ),
        //         "retExtInfo" => null,
        //         "time" => 1658904877942
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $positions = $this->safe_value_2($result, 'list', 'dataList', array());
        $timestamp = $this->safe_integer($response, 'time');
        $first = $this->safe_value($positions, 0);
        $position = $this->parse_position($first);
        return array_merge($position, array(
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
        ));
    }

    public function fetch_unified_margin_positions($symbols = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $type = null;
        if (gettype($symbols) === 'array' && array_keys($symbols) === array_keys(array_keys($symbols))) {
            if (strlen($symbols) > 1) {
                throw new ArgumentsRequired($this->id . ' fetchPositions() does not accept an array with more than one symbol');
            }
        } elseif ($symbols !== null) {
            $symbols = array( $symbols );
        }
        $symbols = $this->market_symbols($symbols);
        // market null
        list($type, $params) = $this->handle_market_type_and_params('fetchPositions', null, $params);
        $subType = null;
        list($subType, $params) = $this->handle_sub_type_and_params('fetchPositions', null, $params);
        $request['category'] = $subType;
        if ($type === 'option') {
            $request['category'] = 'option';
        }
        $response = $this->privateGetUnifiedV3PrivatePositionList (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "Success",
        //         "result" => {
        //             "nextPageCursor" => "0%3A1657711949945%2C0%3A1657711949945",
        //             "category" => "linear",
        //             "list" => array(
        //                 array(
        //                     "symbol" => "ETHUSDT",
        //                     "leverage" => "10",
        //                     "updatedTime" => 1657711949945,
        //                     "side" => "Buy",
        //                     "positionValue" => "536.92500000",
        //                     "takeProfit" => "",
        //                     "tpslMode" => "Full",
        //                     "riskId" => 11,
        //                     "trailingStop" => "",
        //                     "entryPrice" => "1073.85000000",
        //                     "unrealisedPnl" => "",
        //                     "markPrice" => "1080.65000000",
        //                     "size" => "0.5000",
        //                     "positionStatus" => "normal",
        //                     "stopLoss" => "",
        //                     "cumRealisedPnl" => "-0.32215500",
        //                     "positionMM" => "2.97456450",
        //                     "createdTime" => 1657711949928,
        //                     "positionIdx" => 0,
        //                     "positionIM" => "53.98243950"
        //                 }
        //             )
        //         ),
        //         "time" => 1657713693182
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $positions = $this->safe_value($result, 'list', array());
        $results = array();
        for ($i = 0; $i < count($positions); $i++) {
            $rawPosition = $positions[$i];
            if ((is_array($rawPosition) && array_key_exists('data', $rawPosition)) && (is_array($rawPosition) && array_key_exists('is_valid', $rawPosition))) {
                // futures only
                $rawPosition = $this->safe_value($rawPosition, 'data');
            }
            $results[] = $this->parse_position($rawPosition);
        }
        return $this->filter_by_array($results, 'symbol', $symbols, false);
    }

    public function fetch_usdc_positions($symbols = null, $params = array ()) {
        $this->load_markets();
        $symbols = $this->market_symbols($symbols);
        $request = array();
        $market = null;
        $type = null;
        if (gettype($symbols) === 'array' && array_keys($symbols) === array_keys(array_keys($symbols))) {
            $length = count($symbols);
            if ($length !== 1) {
                throw new ArgumentsRequired($this->id . ' fetchUSDCPositions() takes an array with exactly one symbol');
            }
            $symbol = $this->safe_string($symbols, 0);
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        } elseif ($symbols !== null) {
            $market = $this->market($symbols);
            $request['symbol'] = $market['id'];
        }
        list($type, $params) = $this->handle_market_type_and_params('fetchUSDCPositions', $market, $params);
        $request['category'] = ($type === 'option') ? 'OPTION' : 'PERPETUAL';
        $response = $this->privatePostOptionUsdcOpenapiPrivateV1QueryPosition (array_merge($request, $params));
        //
        //     {
        //         "result" => {
        //             "cursor" => "BTC-31DEC21-24000-P%3A1640834421431%2CBTC-31DEC21-24000-P%3A1640834421431",
        //             "resultTotalSize" => 1,
        //             "dataList" => array(
        //                 array(
        //                 "symbol" => "BTC-31DEC21-24000-P",
        //                 "leverage" => "",
        //                 "occClosingFee" => "",
        //                 "liqPrice" => "",
        //                 "positionValue" => "",
        //                 "takeProfit" => "",
        //                 "riskId" => "",
        //                 "trailingStop" => "",
        //                 "unrealisedPnl" => "",
        //                 "createdAt" => "1640834421431",
        //                 "markPrice" => "0.00",
        //                 "cumRealisedPnl" => "",
        //                 "positionMM" => "359.5271",
        //                 "positionIM" => "467.0633",
        //                 "updatedAt" => "1640834421431",
        //                 "tpSLMode" => "",
        //                 "side" => "Sell",
        //                 "bustPrice" => "",
        //                 "deleverageIndicator" => 0,
        //                 "entryPrice" => "1.4",
        //                 "size" => "-0.100",
        //                 "sessionRPL" => "",
        //                 "positionStatus" => "",
        //                 "sessionUPL" => "",
        //                 "stopLoss" => "",
        //                 "orderMargin" => "",
        //                 "sessionAvgPrice" => "1.5"
        //                 }
        //             )
        //         ),
        //         "retCode" => 0,
        //         "retMsg" => "Success."
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $positions = $this->safe_value($result, 'dataList', array());
        $results = array();
        for ($i = 0; $i < count($positions); $i++) {
            $rawPosition = $positions[$i];
            if ((is_array($rawPosition) && array_key_exists('data', $rawPosition)) && (is_array($rawPosition) && array_key_exists('is_valid', $rawPosition))) {
                // futures only
                $rawPosition = $this->safe_value($rawPosition, 'data');
            }
            $results[] = $this->parse_position($rawPosition, $market);
        }
        return $this->filter_by_array($results, 'symbol', $symbols, false);
    }

    public function fetch_derivatives_positions($symbols = null, $params = array ()) {
        $this->load_markets();
        if (gettype($symbols) === 'array' && array_keys($symbols) === array_keys(array_keys($symbols))) {
            if (strlen($symbols) > 1) {
                throw new ArgumentsRequired($this->id . ' fetchPositions() does not accept an array with more than one symbol');
            }
        } elseif ($symbols !== null) {
            $symbols = array( $symbols );
        }
        $symbols = $this->market_symbols($symbols);
        $request = array(
            'dataFilter' => 'valid',
        );
        $settle = null;
        list($settle, $params) = $this->handle_option_and_params($params, 'fetchPositions', 'settle', $settle);
        if ($settle !== null) {
            $request['settleCoin'] = $settle;
        }
        $response = $this->privateGetContractV3PrivatePositionList (array_merge($request, $params));
        //
        // contract v3
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => {
        //             "list" => array(
        //                 array(
        //                     "positionIdx" => 1,
        //                     "riskId" => "41",
        //                     "symbol" => "XRPUSDT",
        //                     "side" => "Buy",
        //                     "size" => "0",
        //                     "positionValue" => "0",
        //                     "entryPrice" => "0",
        //                     "tradeMode" => 0,
        //                     "autoAddMargin" => 0,
        //                     "leverage" => "10",
        //                     "positionBalance" => "0",
        //                     "liqPrice" => "0.0000",
        //                     "bustPrice" => "0.0000",
        //                     "takeProfit" => "0.0000",
        //                     "stopLoss" => "0.0000",
        //                     "trailingStop" => "0.0000",
        //                     "unrealisedPnl" => "0",
        //                     "createdTime" => "1658827444328",
        //                     "updatedTime" => "1658904863412",
        //                     "tpSlMode" => "Full",
        //                     "riskLimitValue" => "200000",
        //                     "activePrice" => "0.0000"
        //                 ),
        //                 array(
        //                     "positionIdx" => 2,
        //                     "riskId" => "41",
        //                     "symbol" => "XRPUSDT",
        //                     "side" => "Sell",
        //                     "size" => "50",
        //                     "positionValue" => "16.68",
        //                     "entryPrice" => "0.3336",
        //                     "tradeMode" => 0,
        //                     "autoAddMargin" => 0,
        //                     "leverage" => "10",
        //                     "positionBalance" => "1.6790088",
        //                     "liqPrice" => "12.4835",
        //                     "bustPrice" => "12.4869",
        //                     "takeProfit" => "0.0000",
        //                     "stopLoss" => "0.0000",
        //                     "trailingStop" => "0.0000",
        //                     "unrealisedPnl" => "0",
        //                     "createdTime" => "1658827444328",
        //                     "updatedTime" => "1658904863412",
        //                     "tpSlMode" => "Full",
        //                     "riskLimitValue" => "200000",
        //                     "activePrice" => "0.0000"
        //                 }
        //             )
        //         ),
        //         "retExtInfo" => null,
        //         "time" => 1658904877942
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $positions = $this->safe_value($result, 'list', array());
        return $this->parse_positions($positions, $symbols, $params);
    }

    public function fetch_positions($symbols = null, $params = array ()) {
        /**
         * fetch all open positions
         * @param {[string]|null} $symbols list of unified market $symbols
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#position-structure position structure}
         */
        if (gettype($symbols) === 'array' && array_keys($symbols) === array_keys(array_keys($symbols))) {
            if (strlen($symbols) > 1) {
                throw new ArgumentsRequired($this->id . ' fetchPositions() does not accept an array with more than one symbol');
            }
        } elseif ($symbols !== null) {
            $symbols = array( $symbols );
        }
        $this->load_markets();
        $symbols = $this->market_symbols($symbols);
        $enableUnifiedMargin = $this->is_unified_margin_enabled();
        $settle = $this->safe_string($params, 'settleCoin');
        if ($settle === null) {
            list($settle, $params) = $this->handle_option_and_params($params, 'fetchPositions', 'settle', $settle);
        }
        $isUsdcSettled = $settle === 'USDC';
        list($subType, $query) = $this->handle_sub_type_and_params('fetchPositions', null, $params);
        $isInverse = $subType === 'inverse';
        $isLinearSettle = $isUsdcSettled || ($settle === 'USDT');
        if ($isInverse && $isLinearSettle) {
            throw new ArgumentsRequired($this->id . ' fetchPositions with inverse $subType requires $settle to not be USDT or USDC');
        }
        if ($enableUnifiedMargin && !$isInverse) {
            return $this->fetch_unified_margin_positions($symbols, $query);
        } elseif ($isUsdcSettled) {
            return $this->fetch_usdc_positions($symbols, $query);
        } else {
            return $this->fetch_derivatives_positions($symbols, $query);
        }
    }

    public function parse_position($position, $market = null) {
        //
        // linear swap
        //
        //     {
        //         "positionIdx" => 0,
        //         "riskId" => "11",
        //         "symbol" => "ETHUSDT",
        //         "side" => "Buy",
        //         "size" => "0.10",
        //         "positionValue" => "119.845",
        //         "entryPrice" => "1198.45",
        //         "tradeMode" => 1,
        //         "autoAddMargin" => 0,
        //         "leverage" => "4.2",
        //         "positionBalance" => "28.58931118",
        //         "liqPrice" => "919.10",
        //         "bustPrice" => "913.15",
        //         "takeProfit" => "0.00",
        //         "stopLoss" => "0.00",
        //         "trailingStop" => "0.00",
        //         "unrealisedPnl" => "0.083",
        //         "createdTime" => "1669097244192",
        //         "updatedTime" => "1669413126190",
        //         "tpSlMode" => "Full",
        //         "riskLimitValue" => "900000",
        //         "activePrice" => "0.00"
        //     }
        //
        // usdc
        //    {
        //       "symbol":"BTCPERP",
        //       "leverage":"1.00",
        //       "occClosingFee":"0.0000",
        //       "liqPrice":"",
        //       "positionValue":"30.8100",
        //       "takeProfit":"0.0",
        //       "riskId":"10001",
        //       "trailingStop":"0.0000",
        //       "unrealisedPnl":"0.0000",
        //       "createdAt":"1652451795305",
        //       "markPrice":"30809.41",
        //       "cumRealisedPnl":"0.0000",
        //       "positionMM":"0.1541",
        //       "positionIM":"30.8100",
        //       "updatedAt":"1652451795305",
        //       "tpSLMode":"UNKNOWN",
        //       "side":"Buy",
        //       "bustPrice":"",
        //       "deleverageIndicator":"0",
        //       "entryPrice":"30810.0",
        //       "size":"0.001",
        //       "sessionRPL":"0.0000",
        //       "positionStatus":"NORMAL",
        //       "sessionUPL":"-0.0006",
        //       "stopLoss":"0.0",
        //       "orderMargin":"0.0000",
        //       "sessionAvgPrice":"30810.0"
        //    }
        //
        // unified margin
        //
        //     {
        //         "symbol" => "ETHUSDT",
        //         "leverage" => "10",
        //         "updatedTime" => 1657711949945,
        //         "side" => "Buy",
        //         "positionValue" => "536.92500000",
        //         "takeProfit" => "",
        //         "tpslMode" => "Full",
        //         "riskId" => 11,
        //         "trailingStop" => "",
        //         "entryPrice" => "1073.85000000",
        //         "unrealisedPnl" => "",
        //         "markPrice" => "1080.65000000",
        //         "size" => "0.5000",
        //         "positionStatus" => "normal",
        //         "stopLoss" => "",
        //         "cumRealisedPnl" => "-0.32215500",
        //         "positionMM" => "2.97456450",
        //         "createdTime" => 1657711949928,
        //         "positionIdx" => 0,
        //         "positionIM" => "53.98243950"
        //     }
        //
        $contract = $this->safe_string($position, 'symbol');
        $market = $this->safe_market($contract, $market);
        $size = Precise::string_abs($this->safe_string($position, 'size'));
        $side = $this->safe_string($position, 'side');
        $side = ($side === 'Buy') ? 'long' : 'short';
        $notional = $this->safe_string($position, 'positionValue');
        $unrealisedPnl = $this->omit_zero($this->safe_string($position, 'unrealisedPnl'));
        $initialMarginString = $this->safe_string($position, 'positionIM');
        $maintenanceMarginString = $this->safe_string($position, 'positionMM');
        $timestamp = $this->parse8601($this->safe_string($position, 'updated_at'));
        if ($timestamp === null) {
            $timestamp = $this->safe_integer($position, 'updatedAt');
        }
        // default to cross of USDC margined positions
        $autoAddMargin = $this->safe_integer($position, 'autoAddMargin', 1);
        $marginMode = $autoAddMargin ? 'cross' : 'isolated';
        $collateralString = $this->safe_string($position, 'positionBalance');
        $entryPrice = $this->omit_zero($this->safe_string($position, 'entryPrice'));
        $liquidationPrice = $this->omit_zero($this->safe_string($position, 'liqPrice'));
        $leverage = $this->safe_string($position, 'leverage');
        if ($liquidationPrice !== null) {
            if ($market['settle'] === 'USDC') {
                //  (Entry price - Liq price) * Contracts . Maintenance Margin . (unrealised pnl) = Collateral
                $difference = Precise::string_abs(Precise::string_sub($entryPrice, $liquidationPrice));
                $collateralString = Precise::string_add(Precise::string_add(Precise::string_mul($difference, $size), $maintenanceMarginString), $unrealisedPnl);
            } else {
                $bustPrice = $this->safe_string($position, 'bustPrice');
                if ($market['linear']) {
                    // derived from the following formulas
                    //  (Entry price - Bust price) * Contracts = Collateral
                    //  (Entry price - Liq price) * Contracts = Collateral - Maintenance Margin
                    // Maintenance Margin = (Bust price - Liq price) x Contracts
                    $maintenanceMarginPriceDifference = Precise::string_abs(Precise::string_sub($liquidationPrice, $bustPrice));
                    $maintenanceMarginString = Precise::string_mul($maintenanceMarginPriceDifference, $size);
                    // Initial Margin = Contracts x Entry Price / Leverage
                    $initialMarginString = Precise::string_div(Precise::string_mul($size, $entryPrice), $leverage);
                } else {
                    // Contracts * (1 / Entry price - 1 / Bust price) = Collateral
                    // Contracts * (1 / Entry price - 1 / Liq price) = Collateral - Maintenance Margin
                    // Maintenance Margin = Contracts * (1 / Liq price - 1 / Bust price)
                    // Maintenance Margin = Contracts * (Bust price - Liq price) / (Liq price x Bust price)
                    $difference = Precise::string_abs(Precise::string_sub($bustPrice, $liquidationPrice));
                    $multiply = Precise::string_mul($bustPrice, $liquidationPrice);
                    $maintenanceMarginString = Precise::string_div(Precise::string_mul($size, $difference), $multiply);
                    // Initial Margin = Leverage x Contracts / EntryPrice
                    $initialMarginString = Precise::string_div($size, Precise::string_mul($entryPrice, $leverage));
                }
            }
        }
        $maintenanceMarginPercentage = Precise::string_div($maintenanceMarginString, $notional);
        $percentage = Precise::string_mul(Precise::string_div($unrealisedPnl, $initialMarginString), '100');
        $marginRatio = Precise::string_div($maintenanceMarginString, $collateralString, 4);
        return array(
            'info' => $position,
            'id' => null,
            'symbol' => $market['symbol'],
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'initialMargin' => $this->parse_number($initialMarginString),
            'initialMarginPercentage' => $this->parse_number(Precise::string_div($initialMarginString, $notional)),
            'maintenanceMargin' => $this->parse_number($maintenanceMarginString),
            'maintenanceMarginPercentage' => $this->parse_number($maintenanceMarginPercentage),
            'entryPrice' => $this->parse_number($entryPrice),
            'notional' => $this->parse_number($notional),
            'leverage' => $this->parse_number($leverage),
            'unrealizedPnl' => $this->parse_number($unrealisedPnl),
            'contracts' => $this->parse_number($size), // in USD for inverse swaps
            'contractSize' => $this->safe_number($market, 'contractSize'),
            'marginRatio' => $this->parse_number($marginRatio),
            'liquidationPrice' => $this->parse_number($liquidationPrice),
            'markPrice' => $this->safe_number($position, 'markPrice'),
            'collateral' => $this->parse_number($collateralString),
            'marginMode' => $marginMode,
            'side' => $side,
            'percentage' => $this->parse_number($percentage),
        );
    }

    public function set_margin_mode($marginMode, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' setMarginMode() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        if ($market['settle'] === 'USDC') {
            throw new NotSupported($this->id . ' setMarginMode() does not support $market ' . $symbol . '');
        }
        $marginMode = strtoupper($marginMode);
        if (($marginMode !== 'ISOLATED') && ($marginMode !== 'CROSS')) {
            throw new BadRequest($this->id . ' setMarginMode() $marginMode must be either isolated or cross');
        }
        $leverage = $this->safe_string($params, 'leverage');
        $sellLeverage = null;
        $buyLeverage = null;
        if ($leverage === null) {
            $sellLeverage = $this->safe_number_2($params, 'sell_leverage', 'sellLeverage');
            $buyLeverage = $this->safe_number_2($params, 'buy_leverage', 'buyLeverage');
            if ($sellLeverage === null || $buyLeverage === null) {
                throw new ArgumentsRequired($this->id . ' setMarginMode() requires a $leverage parameter or sell_leverage and buy_leverage parameters');
            }
            $params = $this->omit($params, array( 'buy_leverage', 'sell_leverage', 'sellLeverage', 'buyLeverage' ));
        } else {
            $params = $this->omit($params, 'leverage');
            $sellLeverage = $leverage;
            $buyLeverage = $leverage;
        }
        $tradeMode = ($marginMode === 'ISOLATED') ? 1 : 0;
        $request = array(
            'symbol' => $market['id'],
            'tradeMode' => $tradeMode,
            'buyLeverage' => $leverage,
            'sellLeverage' => $leverage,
        );
        $response = $this->privatePostContractV3PrivatePositionSwitchIsolated (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => array(),
        //         "retExtInfo" => null,
        //         "time" => 1658908532580
        //     }
        //
        return $response;
    }

    public function set_leverage($leverage, $symbol = null, $params = array ()) {
        /**
         * set the level of $leverage for a $market
         * @param {float} $leverage the rate of $leverage
         * @param {string} $symbol unified $market $symbol
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} response from the exchange
         */
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' setLeverage() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        // WARNING => THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        $isUsdcSettled = $market['settle'] === 'USDC';
        $enableUnifiedMargin = $this->is_unified_margin_enabled();
        // engage in $leverage setting
        // we reuse the code here instead of having two methods
        $leverage = $this->number_to_string($leverage);
        $method = null;
        $request = null;
        if ($enableUnifiedMargin || !$isUsdcSettled) {
            $request = array(
                'symbol' => $market['id'],
                'buyLeverage' => $leverage,
                'sellLeverage' => $leverage,
            );
            if ($enableUnifiedMargin && !$market['inverse']) {
                if ($market['option']) {
                    $request['category'] = 'option';
                } elseif ($market['linear']) {
                    $request['category'] = 'linear';
                } else {
                    throw new NotSupported($this->id . ' setUnifiedMarginLeverage() $leverage doesn\'t support inverse $market in unified margin');
                }
                $method = 'privatePostUnifiedV3PrivatePositionSetLeverage';
            } else {
                $method = 'privatePostContractV3PrivatePositionSetLeverage';
            }
        } else {
            $request = array(
                'symbol' => $market['id'],
                'leverage' => $leverage,
            );
            $method = 'privatePostOptionUsdcOpenapiPrivateV1PositionSetLeverage';
        }
        return $this->$method (array_merge($request, $params));
    }

    public function set_position_mode($hedged, $symbol = null, $params = array ()) {
        $this->load_markets();
        $mode = null;
        if ($hedged) {
            $mode = 3;
        } else {
            $mode = 0;
        }
        $request = array(
            'mode' => $mode,
        );
        if ($symbol === null) {
            $request['coin'] = 'USDT';
        } else {
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        //
        //     {
        //         "ret_code" => 0,
        //         "ret_msg" => "ok",
        //         "ext_code" => "",
        //         "result" => null,
        //         "ext_info" => null,
        //         "time_now" => "1577477968.175013",
        //         "rate_limit_status" => 74,
        //         "rate_limit_reset_ms" => 1577477968183,
        //         "rate_limit" => 75
        //     }
        //
        return $this->privatePostContractV3PrivatePositionSwitchMode (array_merge($request, $params));
    }

    public function fetch_derivatives_open_interest_history($symbol, $timeframe = '1h', $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $subType = $market['linear'] ? 'linear' : 'inverse';
        $category = $this->safe_string($params, 'category', $subType);
        $request = array(
            'symbol' => $market['id'],
            'interval' => $timeframe,
            'category' => $category,
        );
        if ($since !== null) {
            $request['since'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->publicGetDerivativesV3PublicOpenInterest (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => array(
        //             "symbol" => "BTCUSDT",
        //             "category" => "linear",
        //             "list" => array(
        //                 array(
        //                     "openInterest" => "64757.62400000",
        //                     "timestamp" => "1665784800000"
        //                 ),
        //                 ...
        //             )
        //         ),
        //         "retExtInfo" => null,
        //         "time" => 1665784849646
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $id = $this->safe_string($result, 'symbol');
        $market = $this->safe_market($id, $market);
        $data = $this->safe_value($result, 'list', array());
        return $this->parse_open_interests($data, $market, $since, $limit);
    }

    public function fetch_open_interest($symbol, $params = array ()) {
        /**
         * Retrieves the open interest of a derivative trading pair
         * @see https://bybit-exchange.github.io/docs/derivativesV3/contract/#t-dv_marketopeninterest
         * @param {string} $symbol Unified CCXT $market $symbol
         * @param {array} $params exchange specific parameters
         * @param {string|null} $params->interval 5m, 15m, 30m, 1h, 4h, 1d
         * @param {string|null} $params->category "linear" or "inverse"
         * @return {array} an open interest structurearray(@link https://docs.ccxt.com/en/latest/manual.html#interest-history-structure)
         */
        $this->load_markets();
        $market = $this->market($symbol);
        if (!$market['contract']) {
            throw new BadRequest($this->id . ' fetchOpenInterest() supports contract markets only');
        }
        $timeframe = $this->safe_string($params, 'interval', '1h');
        if ($timeframe === '1m') {
            throw new BadRequest($this->id . ' fetchOpenInterest() cannot use the 1m timeframe');
        }
        $subType = $market['linear'] ? 'linear' : 'inverse';
        $category = $this->safe_string($params, 'category', $subType);
        $request = array(
            'symbol' => $market['id'],
            'interval' => $timeframe,
            'category' => $category,
        );
        $response = $this->publicGetDerivativesV3PublicOpenInterest (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => array(
        //             "symbol" => "BTCUSDT",
        //             "category" => "linear",
        //             "list" => array(
        //                 array(
        //                     "openInterest" => "64757.62400000",
        //                     "timestamp" => "1665784800000"
        //                 ),
        //                 ...
        //             )
        //         ),
        //         "retExtInfo" => null,
        //         "time" => 1665784849646
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $id = $this->safe_string($result, 'symbol');
        $market = $this->safe_market($id, $market);
        $data = $this->safe_value($result, 'list', array());
        return $this->parse_open_interest($data[0], $market);
    }

    public function fetch_open_interest_history($symbol, $timeframe = '1h', $since = null, $limit = null, $params = array ()) {
        /**
         * Gets the total amount of unsettled contracts. In other words, the total number of contracts held in open positions
         * @param {string} $symbol Unified $market $symbol
         * @param {string} $timeframe "5m", 15m, 30m, 1h, 4h, 1d
         * @param {int} $since Not used by Bybit
         * @param {int} $limit The number of open interest structures to return. Max 200, default 50
         * @param {array} $params Exchange specific parameters
         * @return An array of open interest structures
         */
        if ($timeframe === '1m') {
            throw new BadRequest($this->id . 'fetchOpenInterestHistory cannot use the 1m timeframe');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        if ($market['spot'] || $market['option']) {
            throw new BadRequest($this->id . ' fetchOpenInterestHistory() $symbol does not support $market ' . $symbol);
        }
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        return $this->fetch_derivatives_open_interest_history($symbol, $timeframe, $since, $limit, $params);
    }

    public function parse_open_interest($interest, $market = null) {
        //
        //    {
        //        "openInterest" => 64757.62400000,
        //        "timestamp" => 1665784800000,
        //    }
        //
        $timestamp = $this->safe_integer($interest, 'timestamp');
        $value = $this->safe_number_2($interest, 'open_interest', 'openInterest');
        return array(
            'symbol' => $this->safe_symbol($market['id']),
            'openInterestAmount' => null,
            'openInterestValue' => $value,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'info' => $interest,
        );
    }

    public function fetch_borrow_rate($code, $params = array ()) {
        /**
         * fetch the rate of interest to borrow a $currency for margin trading
         * @see https://bybit-exchange.github.io/docs/spot/v3/#t-queryinterestquota
         * @param {string} $code unified $currency $code
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#borrow-rate-structure borrow rate structure}
         */
        $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'coin' => $currency['id'],
        );
        $response = $this->privateGetSpotV3PrivateCrossMarginLoanInfo (array_merge($request, $params));
        //
        //    {
        //         "retCode" => "0",
        //         "retMsg" => "success",
        //         "result" => array(
        //             "coin" => "USDT",
        //             "interestRate" => "0.000107000000",
        //             "loanAbleAmount" => "",
        //             "maxLoanAmount" => "79999.999"
        //         ),
        //         "retExtInfo" => null,
        //         "time" => "1666734490778"
        //     }
        //
        $data = $this->safe_value($response, 'result', array());
        return $this->parse_borrow_rate($data, $currency);
    }

    public function parse_borrow_rate($info, $currency = null) {
        //
        //     {
        //         "coin" => "USDT",
        //         "interestRate" => "0.000107000000",
        //         "loanAbleAmount" => "",
        //         "maxLoanAmount" => "79999.999"
        //     }
        //
        $timestamp = $this->milliseconds();
        $currencyId = $this->safe_string($info, 'coin');
        return array(
            'currency' => $this->safe_currency_code($currencyId, $currency),
            'rate' => $this->safe_number($info, 'interestRate'),
            'period' => 86400000, // Daily
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'info' => $info,
        );
    }

    public function fetch_borrow_interest($code = null, $symbol = null, $since = null, $limit = null, $params = array ()) {
        /**
         * fetch the $interest owed by the user for borrowing currency for margin trading
         * @param {string|null} $code unified currency $code
         * @param {string|null} $symbol unified market $symbol when fetch $interest in isolated markets
         * @param {number|null} $since the earliest time in ms to fetch borrrow $interest for
         * @param {number|null} $limit the maximum number of structures to retrieve
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#borrow-$interest-structure borrow $interest structures}
         */
        $this->load_markets();
        $request = array();
        $response = $this->privateGetSpotV3PrivateCrossMarginAccount (array_merge($request, $params));
        //
        //     {
        //         "ret_code" => 0,
        //         "ret_msg" => "",
        //         "ext_code" => null,
        //         "ext_info" => null,
        //         "result" => {
        //             "status" => "1",
        //             "riskRate" => "0",
        //             "acctBalanceSum" => "0.000486213817680857",
        //             "debtBalanceSum" => "0",
        //             "loanAccountList" => array(
        //                 array(
        //                     "tokenId" => "BTC",
        //                     "total" => "0.00048621",
        //                     "locked" => "0",
        //                     "loan" => "0",
        //                     "interest" => "0",
        //                     "free" => "0.00048621"
        //                 ),
        //                 ...
        //             )
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'result', array());
        $rows = $this->safe_value($data, 'loanAccountList', array());
        $interest = $this->parse_borrow_interests($rows, null);
        return $this->filter_by_currency_since_limit($interest, $code, $since, $limit);
    }

    public function parse_borrow_interest($info, $market) {
        //
        //     array(
        //         "tokenId" => "BTC",
        //         "total" => "0.00048621",
        //         "locked" => "0",
        //         "loan" => "0",
        //         "interest" => "0",
        //         "free" => "0.00048621"
        //     ),
        //
        return array(
            'symbol' => null,
            'marginMode' => 'cross',
            'currency' => $this->safe_currency_code($this->safe_string($info, 'tokenId')),
            'interest' => $this->safe_number($info, 'interest'),
            'interestRate' => null,
            'amountBorrowed' => $this->safe_number($info, 'loan'),
            'timestamp' => null,
            'datetime' => null,
            'info' => $info,
        );
    }

    public function transfer($code, $amount, $fromAccount, $toAccount, $params = array ()) {
        /**
         * $transfer $currency internally between wallets on the same account
         * @see https://bybit-exchange.github.io/docs/account_asset/#t-createinternaltransfer
         * @see https://bybit-exchange.github.io/docs/account_asset/v3/#t-createinternaltransfer
         * @param {string} $code unified $currency $code
         * @param {float} $amount amount to $transfer
         * @param {string} $fromAccount account to $transfer from
         * @param {string} $toAccount account to $transfer to
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @param {string} $params->transferId UUID, which is unique across the platform
         * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#$transfer-structure $transfer structure}
         */
        $this->load_markets();
        $transferId = $this->safe_string($params, 'transferId', $this->uuid());
        $accountTypes = $this->safe_value($this->options, 'accountsByType', array());
        $fromId = $this->safe_string($accountTypes, $fromAccount, $fromAccount);
        $toId = $this->safe_string($accountTypes, $toAccount, $toAccount);
        $currency = $this->currency($code);
        $amountToPrecision = $this->currency_to_precision($code, $amount);
        $method = null;
        list($method, $params) = $this->handle_option_and_params($params, 'transfer', 'method', 'privatePostAssetV1PrivateTransfer'); // v1 preferred atm, because it supports funding
        $request = null;
        if ($method === 'privatePostAssetV3PrivateTransferInterTransfer') {
            $request = array(
                'transferId' => $transferId,
                'fromAccountType' => $fromId,
                'toAccountType' => $toId,
                'coin' => $currency['id'],
                'amount' => $amountToPrecision,
            );
        } else {
            $request = array(
                'transfer_id' => $transferId,
                'from_account_type' => $fromId,
                'to_account_type' => $toId,
                'coin' => $currency['id'],
                'amount' => $amountToPrecision,
            );
        }
        $response = $this->$method (array_merge($request, $params));
        //
        // {
        //     "retCode" => 0,
        //     "retMsg" => "success",
        //     "result" => array(
        //         "transferId" => "4244af44-f3b0-4cf6-a743-b56560e987bc" // transfer_id in v1
        //     ),
        //     "retExtInfo" => array(),
        //     "time" => 1666875857205
        // }
        //
        $timestamp = $this->safe_integer_2($response, 'time', 'time_now');
        $transfer = $this->safe_value($response, 'result', array());
        $statusRaw = $this->safe_string_n($response, array( 'retCode', 'retMsg', 'ret_code', 'ret_msg' ));
        $status = $this->parse_transfer_status($statusRaw);
        return array_merge($this->parse_transfer($transfer, $currency), array(
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'amount' => $this->parse_number($amountToPrecision),
            'fromAccount' => $fromAccount,
            'toAccount' => $toAccount,
            'status' => $status,
        ));
    }

    public function fetch_transfers($code = null, $since = null, $limit = null, $params = array ()) {
        /**
         * fetch a history of internal $transfers made on an account
         * @see https://bybit-exchange.github.io/docs/account_asset/v3/#t-querytransferlist
         * @param {string|null} $code unified $currency $code of the $currency transferred
         * @param {int|null} $since the earliest time in ms to fetch $transfers for
         * @param {int|null} $limit the maximum number of  $transfers structures to retrieve
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#transfer-structure transfer structures}
         */
        $this->load_markets();
        $currency = null;
        $request = array();
        if ($code !== null) {
            $currency = $this->safe_currency_code($code);
            $request['coin'] = $currency['id'];
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->privateGetAssetV3PrivateTransferInterTransferListQuery (array_merge($request, $params));
        //
        //    {
        //         "retCode" => "0",
        //         "retMsg" => "success",
        //         "result" => array(
        //             "list" => array(
        //                 array(
        //                     "transferId" => "e9c421c4-b010-4b16-abd6-106179f27732",
        //                     "coin" => "USDT",
        //                     "amount" => "8",
        //                     "fromAccountType" => "FUND",
        //                     "toAccountType" => "SPOT",
        //                     "timestamp" => "1666879426000",
        //                     "status" => "SUCCESS"
        //                 ),
        //             ),
        //             "nextPageCursor" => "eyJtaW5JRCI6MTY3NTM4NDcsIm1heElEIjo0OTI0ODc5NX1="
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => "1666880800063"
        //     }
        //
        $data = $this->safe_value($response, 'result', array());
        $transfers = $this->safe_value($data, 'list', array());
        return $this->parse_transfers($transfers, $currency, $since, $limit);
    }

    public function borrow_margin($code, $amount, $symbol = null, $params = array ()) {
        /**
         * create a loan to borrow margin
         * @see https://bybit-exchange.github.io/docs/spot/v3/#t-borrowmarginloan
         * @param {string} $code unified $currency $code of the $currency to borrow
         * @param {float} $amount the $amount to borrow
         * @param {string|null} $symbol not used by bybit.borrowMargin ()
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure margin loan structure}
         */
        $this->load_markets();
        $currency = $this->currency($code);
        list($marginMode, $query) = $this->handle_margin_mode_and_params('borrowMargin', $params);
        if ($marginMode === 'isolated') {
            throw new NotSupported($this->id . ' borrowMargin () cannot use isolated margin');
        }
        $request = array(
            'coin' => $currency['id'],
            'qty' => $this->currency_to_precision($code, $amount),
        );
        $response = $this->privatePostSpotV3PrivateCrossMarginLoan (array_merge($request, $query));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "success",
        //         "result" => array(
        //             "transactId" => "14143"
        //         ),
        //         "retExtInfo" => null,
        //         "time" => 1662617848970
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $transaction = $this->parse_margin_loan($result, $currency);
        return array_merge($transaction, array(
            'symbol' => $symbol,
            'amount' => $amount,
        ));
    }

    public function repay_margin($code, $amount, $symbol = null, $params = array ()) {
        /**
         * repay borrowed margin and interest
         * @see https://bybit-exchange.github.io/docs/spot/v3/#t-repaymarginloan
         * @param {string} $code unified $currency $code of the $currency to repay
         * @param {float} $amount the $amount to repay
         * @param {string|null} $symbol not used by bybit.repayMargin ()
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#margin-loan-structure margin loan structure}
         */
        $this->load_markets();
        $currency = $this->currency($code);
        list($marginMode, $query) = $this->handle_margin_mode_and_params('repayMargin', $params);
        if ($marginMode === 'isolated') {
            throw new NotSupported($this->id . ' repayMargin () cannot use isolated margin');
        }
        $request = array(
            'coin' => $currency['id'],
            'qty' => $this->number_to_string($amount),
        );
        $response = $this->privatePostSpotV3PrivateCrossMarginRepay (array_merge($request, $query));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "success",
        //         "result" => array(
        //            "repayId" => "12128"
        //         ),
        //         "retExtInfo" => null,
        //         "time" => 1662618298452
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $transaction = $this->parse_margin_loan($result, $currency);
        return array_merge($transaction, array(
            'symbol' => $symbol,
            'amount' => $amount,
        ));
    }

    public function parse_margin_loan($info, $currency = null) {
        //
        // borrowMargin
        //
        //     {
        //         "transactId" => "14143"
        //     }
        //
        // repayMargin
        //
        //     {
        //         "repayId" => "12128"
        //     }
        //
        return array(
            'id' => $this->safe_string_2($info, 'transactId', 'repayId'),
            'currency' => $this->safe_string($currency, 'code'),
            'amount' => null,
            'symbol' => null,
            'timestamp' => null,
            'datetime' => null,
            'info' => $info,
        );
    }

    public function parse_transfer_status($status) {
        $statuses = array(
            '0' => 'ok',
            'OK' => 'ok',
            'SUCCESS' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_transfer($transfer, $currency = null) {
        //
        // $transfer
        //
        //     {
        //         "transferId" => "22c2bc11-ed5b-49a4-8647-c4e0f5f6f2b2" // transfer_id in v1
        //     }
        //
        // fetchTransfers
        //
        //     {
        //         "transferId" => "e9c421c4-b010-4b16-abd6-106179f27702", // transfer_id in v1
        //         "coin" => "USDT",
        //         "amount" => "8",
        //         "fromAccountType" => "FUND", // from_account_type in v1
        //         "toAccountType" => "SPOT", // to_account_type in v1
        //         "timestamp" => "1666879426000",
        //         "status" => "SUCCESS"
        //      }
        //
        $currencyId = $this->safe_string($transfer, 'coin');
        $timestamp = $this->safe_timestamp($transfer, 'timestamp');
        $fromAccountId = $this->safe_string_2($transfer, 'fromAccountType', 'from_account_type');
        $toAccountId = $this->safe_string_2($transfer, 'toAccountType', 'to_account_type');
        $accountIds = $this->safe_value($this->options, 'accountsById', array());
        $fromAccount = $this->safe_string($accountIds, $fromAccountId, $fromAccountId);
        $toAccount = $this->safe_string($accountIds, $toAccountId, $toAccountId);
        return array(
            'info' => $transfer,
            'id' => $this->safe_string_2($transfer, 'transferId', 'transfer_id'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'currency' => $this->safe_currency_code($currencyId, $currency),
            'amount' => $this->safe_number($transfer, 'amount'),
            'fromAccount' => $fromAccount,
            'toAccount' => $toAccount,
            'status' => $this->parse_transfer_status($this->safe_string($transfer, 'status')),
        );
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $url = $this->implode_hostname($this->urls['api'][$api]) . '/' . $path;
        if ($api === 'public') {
            if ($params) {
                $url .= '?' . $this->rawencode($params);
            }
        } elseif ($api === 'private') {
            $this->check_required_credentials();
            $isOpenapi = mb_strpos($url, 'openapi') !== false;
            $isV3UnifiedMargin = mb_strpos($url, 'unified/v3') !== false;
            $timestamp = (string) $this->nonce();
            if ($isOpenapi) {
                if ($params) {
                    $body = $this->json($params);
                } else {
                    // this fix for PHP is required otherwise it generates
                    // '[]' on empty arrays even when forced to use objects
                    $body = '{}';
                }
                $payload = $timestamp . $this->apiKey . $body;
                $signature = $this->hmac($this->encode($payload), $this->encode($this->secret), 'sha256', 'hex');
                $headers = array(
                    'Content-Type' => 'application/json',
                    'X-BAPI-API-KEY' => $this->apiKey,
                    'X-BAPI-TIMESTAMP' => $timestamp,
                    'X-BAPI-SIGN' => $signature,
                );
            } elseif ($isV3UnifiedMargin) {
                $headers = array(
                    'Content-Type' => 'application/json',
                    'X-BAPI-API-KEY' => $this->apiKey,
                    'X-BAPI-SIGN-TYPE' => '2',
                    'X-BAPI-TIMESTAMP' => $timestamp,
                    'X-BAPI-RECV-WINDOW' => (string) $this->options['recvWindow'],
                );
                $query = $params;
                $queryEncoded = $this->rawencode($query);
                $auth_base = (string) $timestamp . $this->apiKey . (string) $this->options['recvWindow'];
                $authFull = null;
                if ($method === 'POST') {
                    $body = $this->json($query);
                    $authFull = $auth_base . $body;
                } else {
                    $authFull = $auth_base . $queryEncoded;
                    if ($path === 'unified/v3/private/order/list') {
                        $url .= '?' . $this->rawencode($query);
                    } else {
                        $url .= '?' . $this->urlencode($query);
                    }
                }
                $headers['X-BAPI-SIGN'] = $this->hmac($this->encode($authFull), $this->encode($this->secret));
            } else {
                $query = array_merge($params, array(
                    'api_key' => $this->apiKey,
                    'recv_window' => $this->options['recvWindow'],
                    'timestamp' => $timestamp,
                ));
                $sortedQuery = $this->keysort($query);
                $auth = $this->rawencode($sortedQuery);
                $signature = $this->hmac($this->encode($auth), $this->encode($this->secret));
                if ($method === 'POST') {
                    $isSpot = mb_strpos($url, 'spot') !== false;
                    $extendedQuery = array_merge($query, array(
                        'sign' => $signature,
                    ));
                    if ($isSpot) {
                        $body = $this->urlencode($extendedQuery);
                        $headers = array(
                            'Content-Type' => 'application/x-www-form-urlencoded',
                        );
                    } else {
                        $body = $this->json($extendedQuery);
                        $headers = array(
                            'Content-Type' => 'application/json',
                        );
                    }
                } else {
                    if ($path === 'contract/v3/private/order/list') {
                        $url .= '?' . $this->rawencode($sortedQuery);
                    } else {
                        $url .= '?' . $this->urlencode($sortedQuery);
                    }
                    $url .= '&sign=' . $signature;
                }
            }
        }
        if ($method === 'POST') {
            $brokerId = $this->safe_string($this->options, 'brokerId');
            if ($brokerId !== null) {
                $headers['Referer'] = $brokerId;
            }
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($httpCode, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if (!$response) {
            return; // fallback to default error handler
        }
        //
        //     {
        //         ret_code => 10001,
        //         ret_msg => 'ReadMapCB => expect { or n, but found \u0000, error ' +
        //         'found in #0 byte of ...||..., bigger context ' +
        //         '...||...',
        //         ext_code => '',
        //         ext_info => '',
        //         result => null,
        //         time_now => '1583934106.590436'
        //     }
        //
        //     {
        //         "retCode":10001,
        //         "retMsg":"symbol params err",
        //         "result":array("symbol":"","bid":"","bidIv":"","bidSize":"","ask":"","askIv":"","askSize":"","lastPrice":"","openInterest":"","indexPrice":"","markPrice":"","markPriceIv":"","change24h":"","high24h":"","low24h":"","volume24h":"","turnover24h":"","totalVolume":"","totalTurnover":"","fundingRate":"","predictedFundingRate":"","nextFundingTime":"","countdownHour":"0","predictedDeliveryPrice":"","underlyingPrice":"","delta":"","gamma":"","vega":"","theta":"")
        //     }
        //
        $errorCode = $this->safe_string_2($response, 'ret_code', 'retCode');
        if ($errorCode !== '0') {
            if ($errorCode === '30084') {
                // not an error
                // https://github.com/ccxt/ccxt/issues/11268
                // https://github.com/ccxt/ccxt/pull/11624
                // POST https://api.bybit.com/v2/private/position/switch-isolated 200 OK
                // array("ret_code":30084,"ret_msg":"Isolated not modified","ext_code":"","ext_info":"","result":null,"time_now":"1642005219.937988","rate_limit_status":73,"rate_limit_reset_ms":1642005219894,"rate_limit":75)
                return null;
            }
            $feedback = null;
            if ($errorCode === '10005') {
                $feedback = $this->id . ' private api uses /user/v3/private/query-api to check if you have a unified account. The API key of user id must own one of permissions => "Account Transfer", "Subaccount Transfer", "Withdrawal" ' . $body;
            } else {
                $feedback = $this->id . ' ' . $body;
            }
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $body, $feedback);
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
            throw new ExchangeError($feedback); // unknown message
        }
    }

    public function fetch_derivatives_market_leverage_tiers($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($market['linear']) {
            $request['category'] = 'linear';
        } elseif ($market['inverse']) {
            $request['category'] = 'inverse';
        }
        $response = $this->publicGetDerivativesV3PublicRiskLimitList (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => {
        //             "category" => "linear",
        //             "list" => array(
        //                 array(
        //                     "id" => 1,
        //                     "symbol" => "BTCUSDT",
        //                     "limit" => "2000000",
        //                     "maintainMargin" => "0.005",
        //                     "initialMargin" => "0.01",
        //                     "section" => array(
        //                         "1",
        //                         "3",
        //                         "5",
        //                         "10",
        //                         "25",
        //                         "50",
        //                         "80"
        //                     ),
        //                     "isLowestRisk" => 1,
        //                     "maxLeverage" => "100.00"
        //                 }
        //             )
        //         ),
        //         "time" => 1657797260220
        //     }
        //
        $result = $this->safe_value($response, 'result');
        $tiers = $this->safe_value($result, 'list');
        return $this->parse_market_leverage_tiers($tiers, $market);
    }

    public function fetch_market_leverage_tiers($symbol, $params = array ()) {
        /**
         * retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes for a single $market
         * @param {string} $symbol unified $market $symbol
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#leverage-tiers-structure leverage tiers structure}
         */
        $this->load_markets();
        $request = array();
        $market = null;
        $market = $this->market($symbol);
        if ($market['spot'] || $market['option']) {
            throw new BadRequest($this->id . ' fetchMarketLeverageTiers() $symbol does not support $market ' . $symbol);
        }
        $request['symbol'] = $market['id'];
        return $this->fetch_derivatives_market_leverage_tiers($symbol, $params);
    }

    public function parse_market_leverage_tiers($info, $market) {
        //
        //    Linear
        //    array(
        //        array(
        //            id => '11',
        //            symbol => 'ETHUSDT',
        //            limit => '800000',
        //            maintain_margin => '0.01',
        //            starting_margin => '0.02',
        //            section => array(
        //                '1',  '2',  '3',
        //                '5',  '10', '15',
        //                '25'
        //            ),
        //            is_lowest_risk => '1',
        //            created_at => '2022-02-04 23:30:33.555252',
        //            updated_at => '2022-02-04 23:30:33.555254',
        //            max_leverage => '50'
        //        ),
        //        ...
        //    )
        //
        //    Inverse
        //    array(
        //        {
        //            id => '180',
        //            is_lowest_risk => '0',
        //            section => array(
        //                '1', '2', '3',
        //                '4', '5', '7',
        //                '8', '9'
        //            ),
        //            symbol => 'ETHUSDH22',
        //            limit => '30000',
        //            max_leverage => '9',
        //            starting_margin => '11',
        //            maintain_margin => '5.5',
        //            coin => 'ETH',
        //            created_at => '2021-04-22T15:00:00Z',
        //            updated_at => '2021-04-22T15:00:00Z'
        //        }
        //        ...
        //    )
        //
        // usdc swap
        //
        //    {
        //        "riskId":"10001",
        //        "symbol":"BTCPERP",
        //        "limit":"1000000",
        //        "startingMargin":"0.0100",
        //        "maintainMargin":"0.0050",
        //        "isLowestRisk":true,
        //        "section":array(
        //           "1",
        //           "2",
        //           "3",
        //           "5",
        //           "10",
        //           "25",
        //           "50",
        //           "100"
        //        ),
        //        "maxLeverage":"100.00"
        //    }
        //
        // Unified Margin
        //
        //     array(
        //         {
        //             "id" => 1,
        //             "symbol" => "BTCUSDT",
        //             "limit" => "2000000",
        //             "maintainMargin" => "0.005",
        //             "initialMargin" => "0.01",
        //             "section" => array(
        //                 "1",
        //                 "3",
        //                 "5",
        //                 "10",
        //                 "25",
        //                 "50",
        //                 "80"
        //             ),
        //             "isLowestRisk" => 1,
        //             "maxLeverage" => "100.00"
        //         }
        //     )
        //
        $minNotional = 0;
        $tiers = array();
        for ($i = 0; $i < count($info); $i++) {
            $item = $info[$i];
            $maxNotional = $this->safe_number($item, 'limit');
            $tiers[] = array(
                'tier' => $this->sum($i, 1),
                'currency' => $market['base'],
                'minNotional' => $minNotional,
                'maxNotional' => $maxNotional,
                'maintenanceMarginRate' => $this->safe_number_2($item, 'maintain_margin', 'maintainMargin'),
                'maxLeverage' => $this->safe_number_2($item, 'max_leverage', 'maxLeverage'),
                'info' => $item,
            );
            $minNotional = $maxNotional;
        }
        return $tiers;
    }

    public function parse_trading_fee($fee, $market = null) {
        //
        //     {
        //         "symbol" => "ETHUSDT",
        //         "makerFeeRate" => 0.001,
        //         "takerFeeRate" => 0.001
        //     }
        //
        $marketId = $this->safe_string($fee, 'symbol');
        $symbol = $this->safe_symbol($marketId);
        return array(
            'info' => $fee,
            'symbol' => $symbol,
            'maker' => $this->safe_number($fee, 'makerFeeRate'),
            'taker' => $this->safe_number($fee, 'takerFeeRate'),
        );
    }

    public function fetch_trading_fee($symbol, $params = array ()) {
        /**
         * fetch the trading $fees for a $market
         * @param {string} $symbol unified $market $symbol
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#fee-structure fee structure}
         */
        if ($this->version !== 'v3') {
            throw new NotSupported($this->id . ' fetchTradingFee() is only support for v3');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        if ($market['spot']) {
            throw new NotSupported($this->id . ' fetchTradingFee() is not supported for spot market');
        }
        $request = array(
            'symbol' => $market['id'],
        );
        $response = $this->privateGetContractV3PrivateAccountFeeRate (array_merge($request, $params));
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => {
        //             "list" => array(
        //                 array(
        //                     "symbol" => "ETHUSDT",
        //                     "takerFeeRate" => "0.0006",
        //                     "makerFeeRate" => "0.0001"
        //                 }
        //             )
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => 1658739027301
        //     }
        //
        $result = $this->safe_value($response, 'result', array());
        $fees = $this->safe_value($result, 'list', array());
        $first = $this->safe_value($fees, 0, array());
        return $this->parse_trading_fee($first);
    }

    public function fetch_trading_fees($params = array ()) {
        /**
         * fetch the trading $fees for multiple markets
         * @param {array} $params extra parameters specific to the bybit api endpoint
         * @return {array} a dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#$fee-structure $fee structures} indexed by market symbols
         */
        if ($this->version !== 'v3') {
            throw new NotSupported($this->id . ' fetchTradingFees() is only support for v3');
        }
        $this->load_markets();
        $type = null;
        list($type, $params) = $this->handle_option_and_params($params, 'fetchTradingFees', 'type', 'future');
        if ($type === 'spot') {
            throw new NotSupported($this->id . ' fetchTradingFees() is not supported for spot market');
        }
        $response = $this->privateGetContractV3PrivateAccountFeeRate ($params);
        //
        //     {
        //         "retCode" => 0,
        //         "retMsg" => "OK",
        //         "result" => {
        //             "list" => array(
        //                 array(
        //                     "symbol" => "ETHUSDT",
        //                     "takerFeeRate" => "0.0006",
        //                     "makerFeeRate" => "0.0001"
        //                 }
        //             )
        //         ),
        //         "retExtInfo" => array(),
        //         "time" => 1658739027301
        //     }
        //
        $fees = $this->safe_value($response, 'result', array());
        $fees = $this->safe_value($fees, 'list', array());
        $result = array();
        for ($i = 0; $i < count($fees); $i++) {
            $fee = $this->parse_trading_fee($fees[$i]);
            $symbol = $fee['symbol'];
            $result[$symbol] = $fee;
        }
        return $result;
    }
}
